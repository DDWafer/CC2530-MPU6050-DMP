###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         21/Dec/2018  21:18:01 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\Source\MPU6050_DMP\inv_mpu.c                    #
#    Command line       =  -f F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú #
#                          \ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Samp #
#                          leApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cf #
#                          g (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS) -f  #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg  #
#                          (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR      #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\Source\MPU6050_DMP\inv_mpu.c -D ZIGBEEPRO -D    #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D xMT_TASK -D           #
#                          xMT_SYS_FUNC -D xMT_ZDO_FUNC -D                    #
#                          LCD_SUPPORTED=DEBUG -lC F:\key_pro\AAAAAgraduation #
#                          _project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Project #
#                          s\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pr #
#                          o\List\ -lA F:\key_pro\AAAAAgraduation_project\Ωªª #
#                          •œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\EndDeviceEB-Pro\List\      #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB-Pro\Obj\ -e --debug        #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I F:\key_pro\AAAAAgraduation #
#                          _project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Project #
#                          s\zstack\Samples\SampleApp\CC2530DB\ -I            #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\SOURCE\ -I                          #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\ZMAIN\TI2530DB\ -I            #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\ -I       #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\ #
#                           -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã– #
#                          Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Sam #
#                          pleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530EB\ -I F:\key_pro\AAAAAgraduation_project #
#                          \Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack #
#                          \Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONE #
#                          NTS\OSAL\MCU\CCSOC\ -I F:\key_pro\AAAAAgraduation_ #
#                          project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\OSAL\INCLUDE\ -I                        #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\    #
#                          -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú #
#                          \ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Samp #
#                          leApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK #
#                          \ -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã #
#                          –Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Sa #
#                          mpleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S #
#                          EC\ -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥ #
#                          ≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK #
#                          \SAPI\ -I F:\key_pro\AAAAAgraduation_project\Ωªª•œ #
#                          µÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Sampl #
#                          es\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ST #
#                          ACK\SYS\ -I F:\key_pro\AAAAAgraduation_project\Ωªª #
#                          •œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ #
#                          STACK\ZDO\ -I F:\key_pro\AAAAAgraduation_project\Ω #
#                          ªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENT #
#                          S\ZMAC\F8W\ -I F:\key_pro\AAAAAgraduation_project\ #
#                          Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\ #
#                          Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\ZMAC\ -I F:\key_pro\AAAAAgraduation_project\Ωªª #
#                          •œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ #
#                          SERVICES\SADDR\ -I F:\key_pro\AAAAAgraduation_proj #
#                          ect\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\SERVICES\SDATA\ -I                          #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\ #
#                           -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã– #
#                          Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Sam #
#                          pleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\ -I F:\key_pro\AAAAAgraduation_project\Ωªª• #
#                          œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samp #
#                          les\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\M #
#                          AC\LOW_LEVEL\srf04\ -I F:\key_pro\AAAAAgraduation_ #
#                          project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -I     #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\..\..\..\ -Ohz          #
#    List file          =  F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB-Pro\List\inv_mpu.lst       #
#    Object file        =  F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB-Pro\Obj\inv_mpu.r51        #
#                                                                             #
#                                                                             #
###############################################################################

F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleApp\Source\MPU6050_DMP\inv_mpu.c
      1          /*
      2           $License:
      3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
      4              See included License.txt for License information.
      5           $
      6           */
      7          /**
      8           *  @addtogroup  DRIVERS Sensor Driver Layer
      9           *  @brief       Hardware drivers to communicate with sensors via I2C.
     10           *
     11           *  @{
     12           *      @file       inv_mpu.c
     13           *      @brief      An I2C-based driver for Invensense gyroscopes.
     14           *      @details    This driver currently works for the following devices:
     15           *                  MPU6050
     16           *                  MPU6500
     17           *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
     18           *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
     19           *
     20           */
     21          
     22          
     23          //”≥…‰’‚Àƒ∏ˆ∫Ø ˝
     24          //#define i2c_write   I2C_Write
     25          //#define i2c_read    I2C_Read
     26          //#define delay_ms    delay_ms
     27          //#define get_ms      get_ms
     28          
     29          #include <stdio.h>
     30          #include <stdint.h>
     31          #include <stdlib.h>
     32          #include <string.h>
     33          #include <math.h>
     34          
     35          #include "inv_mpu.h"
     36          #include "iic.h"
     37          #include "mpu6050.h"
     38          #include "delay.h"
     39          
     40          
     41          int dmp_set_gyro_bias(long *bias) ;
     42          int dmp_set_accel_bias(long *bias);
     43          
     44          /* The following functions must be defined for this platform:
     45           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
     46           *      unsigned char length, unsigned char const *data)
     47           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
     48           *      unsigned char length, unsigned char *data)
     49           * delay_ms(unsigned long num_ms)
     50           * get_ms(unsigned long *count)
     51           * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
     52           * labs(long x)
     53           * fabsf(float x)
     54           * min(int a, int b)
     55           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     56          void run_self_test(void)
   \                     run_self_test:
     57          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
     58              int result;
     59          //    char test_packet[4] = {0};
     60              long gyro[3], accel[3];
     61          
     62              result = mpu_run_self_test(gyro, accel);
     63              if (result == 0x7) {
   \   00000A                ; Setup parameters for call to function mpu_run_self_test
   \   00000A   7406         MOV     A,#0x6
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   7412         MOV     A,#0x12
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??mpu_run_self_test?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   7407         MOV     A,#0x7
   \   000023   65..         XRL     A,?V0 + 0
   \   000025   7001         JNZ     ??run_self_test_0
   \   000027   EB           MOV     A,R3
   \                     ??run_self_test_0:
   \   000028   6003         JZ      $+5
   \   00002A   02....       LJMP    ??run_self_test_1 & 0xFFFF
     64                  /* Test passed. We can trust the gyro data here, so let's push it down
     65                   * to the DMP.
     66                   */
     67                  float sens;
     68                  unsigned short accel_sens;
     69                  mpu_get_gyro_sens(&sens);
   \   00002D                ; Setup parameters for call to function mpu_get_gyro_sens
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   AA82         MOV     R2,DPL
   \   000034   AB83         MOV     R3,DPH
   \   000036   12....       LCALL   ??mpu_get_gyro_sens?relay
     70                  gyro[0] = (long)(gyro[0] * sens);
   \   000039   7412         MOV     A,#0x12
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?L_MOV_X
   \   000043   78..         MOV     R0,#?V0 + 0
   \   000045   12....       LCALL   ?L_TO_FLT
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   78..         MOV     R0,#?V0 + 4
   \   00004F   12....       LCALL   ?L_MOV_X
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   79..         MOV     R1,#?V0 + 4
   \   000056   12....       LCALL   ?FLT_MUL
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?FLT_TO_L
   \   00005E   7412         MOV     A,#0x12
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_MOV_TO_X
     71                  gyro[1] = (long)(gyro[1] * sens);
   \   000068   7416         MOV     A,#0x16
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 0
   \   000074   12....       LCALL   ?L_TO_FLT
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   78..         MOV     R0,#?V0 + 4
   \   00007E   12....       LCALL   ?L_MOV_X
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   79..         MOV     R1,#?V0 + 4
   \   000085   12....       LCALL   ?FLT_MUL
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?FLT_TO_L
   \   00008D   7416         MOV     A,#0x16
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?L_MOV_TO_X
     72                  gyro[2] = (long)(gyro[2] * sens);
   \   000097   741A         MOV     A,#0x1a
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?L_MOV_X
   \   0000A1   78..         MOV     R0,#?V0 + 0
   \   0000A3   12....       LCALL   ?L_TO_FLT
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?L_MOV_X
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   79..         MOV     R1,#?V0 + 4
   \   0000B4   12....       LCALL   ?FLT_MUL
   \   0000B7   78..         MOV     R0,#?V0 + 0
   \   0000B9   12....       LCALL   ?FLT_TO_L
   \   0000BC   741A         MOV     A,#0x1a
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   78..         MOV     R0,#?V0 + 0
   \   0000C3   12....       LCALL   ?L_MOV_TO_X
     73                  dmp_set_gyro_bias(gyro);
   \   0000C6                ; Setup parameters for call to function dmp_set_gyro_bias
   \   0000C6   7412         MOV     A,#0x12
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   AA82         MOV     R2,DPL
   \   0000CD   AB83         MOV     R3,DPH
   \   0000CF   12....       LCALL   ??dmp_set_gyro_bias?relay
     74                  mpu_get_accel_sens(&accel_sens);
   \   0000D2                ; Setup parameters for call to function mpu_get_accel_sens
   \   0000D2   85..82       MOV     DPL,?XSP + 0
   \   0000D5   85..83       MOV     DPH,?XSP + 1
   \   0000D8   AA82         MOV     R2,DPL
   \   0000DA   AB83         MOV     R3,DPH
   \   0000DC   12....       LCALL   ??mpu_get_accel_sens?relay
     75                  accel[0] *= accel_sens;
   \   0000DF   85..82       MOV     DPL,?XSP + 0
   \   0000E2   85..83       MOV     DPH,?XSP + 1
   \   0000E5   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0000E8   E4           CLR     A
   \   0000E9   F5..         MOV     ?V0 + 2,A
   \   0000EB   F5..         MOV     ?V0 + 3,A
   \   0000ED   7406         MOV     A,#0x6
   \   0000EF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F2   78..         MOV     R0,#?V0 + 4
   \   0000F4   12....       LCALL   ?L_MOV_X
   \   0000F7   78..         MOV     R0,#?V0 + 4
   \   0000F9   79..         MOV     R1,#?V0 + 0
   \   0000FB   12....       LCALL   ?L_MUL
   \   0000FE   7406         MOV     A,#0x6
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   78..         MOV     R0,#?V0 + 4
   \   000105   12....       LCALL   ?L_MOV_TO_X
     76                  accel[1] *= accel_sens;
   \   000108   740A         MOV     A,#0xa
   \   00010A   12....       LCALL   ?XSTACK_DISP0_8
   \   00010D   78..         MOV     R0,#?V0 + 4
   \   00010F   12....       LCALL   ?L_MOV_X
   \   000112   78..         MOV     R0,#?V0 + 4
   \   000114   79..         MOV     R1,#?V0 + 0
   \   000116   12....       LCALL   ?L_MUL
   \   000119   740A         MOV     A,#0xa
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   78..         MOV     R0,#?V0 + 4
   \   000120   12....       LCALL   ?L_MOV_TO_X
     77                  accel[2] *= accel_sens;
   \   000123   740E         MOV     A,#0xe
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   78..         MOV     R0,#?V0 + 4
   \   00012A   12....       LCALL   ?L_MOV_X
   \   00012D   78..         MOV     R0,#?V0 + 4
   \   00012F   79..         MOV     R1,#?V0 + 0
   \   000131   12....       LCALL   ?L_MUL
   \   000134   740E         MOV     A,#0xe
   \   000136   12....       LCALL   ?XSTACK_DISP0_8
   \   000139   78..         MOV     R0,#?V0 + 4
   \   00013B   12....       LCALL   ?L_MOV_TO_X
     78                  dmp_set_accel_bias(accel);
   \   00013E                ; Setup parameters for call to function dmp_set_accel_bias
   \   00013E   7406         MOV     A,#0x6
   \   000140   12....       LCALL   ?XSTACK_DISP0_8
   \   000143   AA82         MOV     R2,DPL
   \   000145   AB83         MOV     R3,DPH
   \   000147   12....       LCALL   ??dmp_set_accel_bias?relay
     79              }
     80          }
   \                     ??run_self_test_1:
   \   00014A   741E         MOV     A,#0x1e
   \   00014C   80..         SJMP    ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   22           RET
     81          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     82           unsigned short inv_orientation_matrix_to_scalar(
   \                     inv_orientation_matrix_to_scalar:
     83              const signed char *mtx)
     84          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
     85              unsigned short scalar;
     86          
     87              /*
     88                 XYZ  010_001_000 Identity Matrix
     89                 XZY  001_010_000
     90                 YXZ  010_000_001
     91                 YZX  000_010_001
     92                 ZXY  001_000_010
     93                 ZYX  000_001_010
     94               */
     95          
     96              scalar  = inv_row_2_scale(mtx);
   \   000009                ; Setup parameters for call to function inv_row_2_scale
   \   000009   12....       LCALL   ??inv_row_2_scale?relay
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
     97              scalar |= inv_row_2_scale(mtx + 3) << 3;
   \   000010                ; Setup parameters for call to function inv_row_2_scale
   \   000010   EE           MOV     A,R6
   \   000011   2403         ADD     A,#0x3
   \   000013   12....       LCALL   ?Subroutine55 & 0xFFFF
     98              scalar |= inv_row_2_scale(mtx + 6) << 6;
     99          
    100          
    101              return scalar;
   \                     ??CrossCallReturnLabel_85:
   \   000016   7403         MOV     A,#0x3
   \   000018   78..         MOV     R0,#?V0 + 2
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   E5..         MOV     A,?V0 + 0
   \   00001F   45..         ORL     A,?V0 + 2
   \   000021   F5..         MOV     ?V0 + 0,A
   \   000023   E5..         MOV     A,?V0 + 1
   \   000025   45..         ORL     A,?V0 + 3
   \   000027   F5..         MOV     ?V0 + 1,A
   \   000029                ; Setup parameters for call to function inv_row_2_scale
   \   000029   EE           MOV     A,R6
   \   00002A   2406         ADD     A,#0x6
   \   00002C   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   00002F   7406         MOV     A,#0x6
   \   000031   78..         MOV     R0,#?V0 + 2
   \   000033   12....       LCALL   ?S_SHL
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   45..         ORL     A,?V0 + 2
   \   00003A   FA           MOV     R2,A
   \   00003B   E5..         MOV     A,?V0 + 1
   \   00003D   45..         ORL     A,?V0 + 3
   \   00003F   FB           MOV     R3,A
   \   000040   7F06         MOV     R7,#0x6
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
    102          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   FA           MOV     R2,A
   \   000001   EF           MOV     A,R7
   \   000002   3400         ADDC    A,#0x0
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??inv_row_2_scale?relay
   \   000008   8A..         MOV     ?V0 + 2,R2
   \   00000A   8B..         MOV     ?V0 + 3,R3
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    103           unsigned short inv_row_2_scale(const signed char *row)
   \                     inv_row_2_scale:
    104          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    105              unsigned short b;
    106          
    107              if (row[0] > 0)
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   00000B   4004         JC      ??inv_row_2_scale_0
    108                  b = 0;
   \   00000D   7A00         MOV     R2,#0x0
   \   00000F   8034         SJMP    ??inv_row_2_scale_1
    109              else if (row[0] < 0)
   \                     ??inv_row_2_scale_0:
   \   000011   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000014   5004         JNC     ??inv_row_2_scale_2
    110                  b = 4;
   \   000016   7A04         MOV     R2,#0x4
   \   000018   802B         SJMP    ??inv_row_2_scale_1
    111              else if (row[1] > 0)
   \                     ??inv_row_2_scale_2:
   \   00001A   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   00001D   4004         JC      ??inv_row_2_scale_3
    112                  b = 1;
   \   00001F   7A01         MOV     R2,#0x1
   \   000021   8022         SJMP    ??inv_row_2_scale_1
    113              else if (row[1] < 0)
   \                     ??inv_row_2_scale_3:
   \   000023   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000026   5004         JNC     ??inv_row_2_scale_4
    114                  b = 5;
   \   000028   7A05         MOV     R2,#0x5
   \   00002A   8019         SJMP    ??inv_row_2_scale_1
    115              else if (row[2] > 0)
   \                     ??inv_row_2_scale_4:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   A3           INC     DPTR
   \   000031   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000034   4004         JC      ??inv_row_2_scale_5
    116                  b = 2;
   \   000036   7A02         MOV     R2,#0x2
   \   000038   800B         SJMP    ??inv_row_2_scale_1
    117              else if (row[2] < 0)
   \                     ??inv_row_2_scale_5:
   \   00003A   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00003D   5004         JNC     ??inv_row_2_scale_6
    118                  b = 6;
   \   00003F   7A06         MOV     R2,#0x6
   \   000041   8002         SJMP    ??inv_row_2_scale_1
    119              else
    120                  b = 7;      // error
   \                     ??inv_row_2_scale_6:
   \   000043   7A07         MOV     R2,#0x7
   \                     ??inv_row_2_scale_1:
   \   000045   02....       LJMP    ??Subroutine113_0 & 0xFFFF
    121              return b;
    122          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   E8           MOV     A,R0
   \   000001   C3           CLR     C
   \   000002   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine106_0
   \   000001                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   C3           CLR     C
   \   000003   9401         SUBB    A,#0x1
   \   000005   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000007   65D0         XRL     A,PSW
   \   000009   33           RLC     A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   7B00         MOV     R3,#0x0
   \   000002                REQUIRE ??Subroutine114_0
   \   000002                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   9400         SUBB    A,#0x0
   \   000002   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000004   65D0         XRL     A,PSW
   \   000006   33           RLC     A
   \   000007   22           RET
    123          
    124          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    125          void get_ms(unsigned long *time)
   \                     get_ms:
    126          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    127          
    128          }
   \   000000   02....       LJMP    ?BRET
    129          
    130          #define MPU6050
    131          #define MOTION_DRIVER_TARGET_MSP430
    132          
    133          #if defined MOTION_DRIVER_TARGET_MSP430
    134          /*#include "msp430.h"
    135          #include "msp430_i2c.h"
    136          #include "msp430_clock.h"
    137          #include "msp430_interrupt.h" */
    138          
    139          #define i2c_write   I2C_Write
    140          #define i2c_read    I2C_Read
    141          #define delay_ms    delay_ms
    142          #define get_ms      get_ms
    143          
    144          //static int reg_int_cb(struct int_param_s *int_param)
    145          //{
    146          //    /*return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
    147          //        int_param->active_low);*/
    148          //		return 0;
    149          //}	  
    150          //#define log_i(...)     do {} while (0)
    151          //#define log_e(...)     do {} while (0)
    152          //#define log_e    PrintChar
    153          //#define log_i    PrintChar
    154          /* labs is already defined by TI's toolchain. */
    155          /* fabs is for doubles. fabsf is for floats. */
    156          #define fabs        fabsf
    157          #define min(a,b) ((a<b)?a:b)
    158          
    159          #elif defined EMPL_TARGET_MSP430
    160          //#include "msp430.h"
    161          //#include "msp430_i2c.h"
    162          //#include "msp430_clock.h"
    163          //#include "msp430_interrupt.h"
    164          #include "log.h"
    165          #define i2c_write   msp430_i2c_write
    166          #define i2c_read    msp430_i2c_read
    167          #define delay_ms    msp430_delay_ms
    168          #define get_ms      msp430_get_clock_ms
    169          static inline int reg_int_cb(struct int_param_s *int_param)
    170          {
    171              return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
    172                  int_param->active_low);
    173          }
    174          #define log_i       MPL_LOGI
    175          #define log_e       MPL_LOGE
    176          /* labs is already defined by TI's toolchain. */
    177          /* fabs is for doubles. fabsf is for floats. */
    178          #define fabs        fabsf
    179          #define min(a,b) ((a<b)?a:b)
    180          #elif defined EMPL_TARGET_UC3L0
    181          /* Instead of using the standard TWI driver from the ASF library, we're using
    182           * a TWI driver that follows the slave address + register address convention.
    183           */
    184          #include "twi.h"
    185          #include "delay.h"
    186          #include "sysclk.h"
    187          #include "log.h"
    188          #include "sensors_xplained.h"
    189          #include "uc3l0_clock.h"
    190          #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
    191          #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
    192          /* delay_ms is a function already defined in ASF. */
    193          #define get_ms  uc3l0_get_clock_ms
    194          
    195          static inline int reg_int_cb(struct int_param_s *int_param)
    196          {
    197              sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
    198              return 0;
    199          }
    200          #define log_i       MPL_LOGI
    201          #define log_e       MPL_LOGE
    202          /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
    203          #define labs        abs
    204          #define fabs(x)     (((x)>0)?(x):-(x))
    205          #else
    206          //#error  Gyro driver is missing the system layer implementations.
    207          #endif
    208          
    209          #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
    210          //#error  Which gyro are you using? Define MPUxxxx in your compiler options.
    211          #endif
    212          
    213          /* Time for some messy macro work. =]
    214           * #define MPU9150
    215           * is equivalent to..
    216           * #define MPU6050
    217           * #define AK8975_SECONDARY
    218           *
    219           * #define MPU9250
    220           * is equivalent to..
    221           * #define MPU6500
    222           * #define AK8963_SECONDARY
    223           */
    224          #if defined MPU9150
    225          #ifndef MPU6050
    226          #define MPU6050
    227          #endif                          /* #ifndef MPU6050 */
    228          #if defined AK8963_SECONDARY
    229          #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
    230          #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
    231          #define AK8975_SECONDARY
    232          #endif                          /* #if defined AK8963_SECONDARY */
    233          #elif defined MPU9250           /* #if defined MPU9150 */
    234          #ifndef MPU6500
    235          #define MPU6500
    236          #endif                          /* #ifndef MPU6500 */
    237          #if defined AK8975_SECONDARY
    238          #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
    239          #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
    240          #define AK8963_SECONDARY
    241          #endif                          /* #if defined AK8975_SECONDARY */
    242          #endif                          /* #if defined MPU9150 */
    243          
    244          #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
    245          #define AK89xx_SECONDARY
    246          #else
    247          /* #warning "No compass = less profit for Invensense. Lame." */
    248          #endif
    249          
    250          static int set_int_enable(unsigned char enable);
    251          
    252          /* Hardware registers needed by driver. */
    253          struct gyro_reg_s {
    254              unsigned char who_am_i;
    255              unsigned char rate_div;
    256              unsigned char lpf;
    257              unsigned char prod_id;
    258              unsigned char user_ctrl;
    259              unsigned char fifo_en;
    260              unsigned char gyro_cfg;
    261              unsigned char accel_cfg;
    262          
    263              //unsigned char accel_cfg2;
    264          
    265              //unsigned char lp_accel_odr;
    266          
    267              unsigned char motion_thr;
    268              unsigned char motion_dur;
    269              unsigned char fifo_count_h;
    270              unsigned char fifo_r_w;
    271              unsigned char raw_gyro;
    272              unsigned char raw_accel;
    273              unsigned char temp;
    274              unsigned char int_enable;
    275              unsigned char dmp_int_status;
    276              unsigned char int_status;
    277          
    278              //unsigned char accel_intel;
    279          
    280              unsigned char pwr_mgmt_1;
    281              unsigned char pwr_mgmt_2;
    282              unsigned char int_pin_cfg;
    283              unsigned char mem_r_w;
    284              unsigned char accel_offs;
    285              unsigned char i2c_mst;
    286              unsigned char bank_sel;
    287              unsigned char mem_start_addr;
    288              unsigned char prgm_start_h;
    289          #if defined AK89xx_SECONDARY
    290              unsigned char s0_addr;
    291              unsigned char s0_reg;
    292              unsigned char s0_ctrl;
    293              unsigned char s1_addr;
    294              unsigned char s1_reg;
    295              unsigned char s1_ctrl;
    296              unsigned char s4_ctrl;
    297              unsigned char s0_do;
    298              unsigned char s1_do;
    299              unsigned char i2c_delay_ctrl;
    300              unsigned char raw_compass;
    301              /* The I2C_MST_VDDIO bit is in this register. */
    302              unsigned char yg_offs_tc;
    303          #endif
    304          };
    305          
    306          /* Information specific to a particular device. */
    307          struct hw_s {
    308              unsigned char addr;
    309              unsigned short max_fifo;
    310              unsigned char num_reg;
    311              unsigned short temp_sens;
    312              short temp_offset;
    313              unsigned short bank_size;
    314          #if defined AK89xx_SECONDARY
    315              unsigned short compass_fsr;
    316          #endif
    317          };
    318          
    319          /* When entering motion interrupt mode, the driver keeps track of the
    320           * previous state so that it can be restored at a later time.
    321           * TODO: This is tacky. Fix it.
    322           */
    323          struct motion_int_cache_s {
    324              unsigned short gyro_fsr;
    325              unsigned char accel_fsr;
    326              unsigned short lpf;
    327              unsigned short sample_rate;
    328              unsigned char sensors_on;
    329              unsigned char fifo_sensors;
    330              unsigned char dmp_on;
    331          };
    332          
    333          /* Cached chip configuration data.
    334           * TODO: A lot of these can be handled with a bitmask.
    335           */
    336          struct chip_cfg_s {
    337              /* Matches gyro_cfg >> 3 & 0x03 */
    338              unsigned char gyro_fsr;
    339              /* Matches accel_cfg >> 3 & 0x03 */
    340              unsigned char accel_fsr;
    341              /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
    342              unsigned char sensors;
    343              /* Matches config register. */
    344              unsigned char lpf;
    345              unsigned char clk_src;
    346              /* Sample rate, NOT rate divider. */
    347              unsigned short sample_rate;
    348              /* Matches fifo_en register. */
    349              unsigned char fifo_enable;
    350              /* Matches int enable register. */
    351              unsigned char int_enable;
    352              /* 1 if devices on auxiliary I2C bus appear on the primary. */
    353              unsigned char bypass_mode;
    354              /* 1 if half-sensitivity.
    355               * NOTE: This doesn't belong here, but everything else in hw_s is const,
    356               * and this allows us to save some precious RAM.
    357               */
    358              unsigned char accel_half;
    359              /* 1 if device in low-power accel-only mode. */
    360              unsigned char lp_accel_mode;
    361              /* 1 if interrupts are only triggered on motion events. */
    362              unsigned char int_motion_only;
    363              struct motion_int_cache_s cache;
    364              /* 1 for active low interrupts. */
    365              unsigned char active_low_int;
    366              /* 1 for latched interrupts. */
    367              unsigned char latched_int;
    368              /* 1 if DMP is enabled. */
    369              unsigned char dmp_on;
    370              /* Ensures that DMP will only be loaded once. */
    371              unsigned char dmp_loaded;
    372              /* Sampling rate used when DMP is enabled. */
    373              unsigned short dmp_sample_rate;
    374          #ifdef AK89xx_SECONDARY
    375              /* Compass sample rate. */
    376              unsigned short compass_sample_rate;
    377              unsigned char compass_addr;
    378              short mag_sens_adj[3];
    379          #endif
    380          };
    381          
    382          /* Information for self-test. */
    383          struct test_s {
    384              unsigned long gyro_sens;
    385              unsigned long accel_sens;
    386              unsigned char reg_rate_div;
    387              unsigned char reg_lpf;
    388              unsigned char reg_gyro_fsr;
    389              unsigned char reg_accel_fsr;
    390              unsigned short wait_ms;
    391              unsigned char packet_thresh;
    392              float min_dps;
    393              float max_dps;
    394              float max_gyro_var;
    395              float min_g;
    396              float max_g;
    397              float max_accel_var;
    398          };
    399          
    400          /* Gyro driver state variables. */
    401          struct gyro_state_s {
    402              const struct gyro_reg_s *reg;
    403              const struct hw_s *hw;
    404              struct chip_cfg_s chip_cfg;
    405              const struct test_s *test;
    406          };
    407          
    408          /* Filter configurations. */
    409          enum lpf_e {
    410              INV_FILTER_256HZ_NOLPF2 = 0,
    411              INV_FILTER_188HZ,
    412              INV_FILTER_98HZ,
    413              INV_FILTER_42HZ,
    414              INV_FILTER_20HZ,
    415              INV_FILTER_10HZ,
    416              INV_FILTER_5HZ,
    417              INV_FILTER_2100HZ_NOLPF,
    418              NUM_FILTER
    419          };
    420          
    421          /* Full scale ranges. */
    422          enum gyro_fsr_e {
    423              INV_FSR_250DPS = 0,
    424              INV_FSR_500DPS,
    425              INV_FSR_1000DPS,
    426              INV_FSR_2000DPS,
    427              NUM_GYRO_FSR
    428          };
    429          
    430          /* Full scale ranges. */
    431          enum accel_fsr_e {
    432              INV_FSR_2G = 0,
    433              INV_FSR_4G,
    434              INV_FSR_8G,
    435              INV_FSR_16G,
    436              NUM_ACCEL_FSR
    437          };
    438          
    439          /* Clock sources. */
    440          enum clock_sel_e {
    441              INV_CLK_INTERNAL = 0,
    442              INV_CLK_PLL,
    443              NUM_CLK
    444          };
    445          
    446          /* Low-power accel wakeup rates. */
    447          enum lp_accel_rate_e {
    448          #if defined MPU6050
    449              INV_LPA_1_25HZ,
    450              INV_LPA_5HZ,
    451              INV_LPA_20HZ,
    452              INV_LPA_40HZ
    453          #elif defined MPU6500
    454              INV_LPA_0_3125HZ,
    455              INV_LPA_0_625HZ,
    456              INV_LPA_1_25HZ,
    457              INV_LPA_2_5HZ,
    458              INV_LPA_5HZ,
    459              INV_LPA_10HZ,
    460              INV_LPA_20HZ,
    461              INV_LPA_40HZ,
    462              INV_LPA_80HZ,
    463              INV_LPA_160HZ,
    464              INV_LPA_320HZ,
    465              INV_LPA_640HZ
    466          #endif
    467          };
    468          
    469          #define BIT_I2C_MST_VDDIO   (0x80)
    470          #define BIT_FIFO_EN         (0x40)
    471          #define BIT_DMP_EN          (0x80)
    472          #define BIT_FIFO_RST        (0x04)
    473          #define BIT_DMP_RST         (0x08)
    474          #define BIT_FIFO_OVERFLOW   (0x10)
    475          #define BIT_DATA_RDY_EN     (0x01)
    476          #define BIT_DMP_INT_EN      (0x02)
    477          #define BIT_MOT_INT_EN      (0x40)
    478          #define BITS_FSR            (0x18)
    479          #define BITS_LPF            (0x07)
    480          #define BITS_HPF            (0x07)
    481          #define BITS_CLK            (0x07)
    482          #define BIT_FIFO_SIZE_1024  (0x40)
    483          #define BIT_FIFO_SIZE_2048  (0x80)
    484          #define BIT_FIFO_SIZE_4096  (0xC0)
    485          #define BIT_RESET           (0x80)
    486          #define BIT_SLEEP           (0x40)
    487          #define BIT_S0_DELAY_EN     (0x01)
    488          #define BIT_S2_DELAY_EN     (0x04)
    489          #define BITS_SLAVE_LENGTH   (0x0F)
    490          #define BIT_SLAVE_BYTE_SW   (0x40)
    491          #define BIT_SLAVE_GROUP     (0x10)
    492          #define BIT_SLAVE_EN        (0x80)
    493          #define BIT_I2C_READ        (0x80)
    494          #define BITS_I2C_MASTER_DLY (0x1F)
    495          #define BIT_AUX_IF_EN       (0x20)
    496          #define BIT_ACTL            (0x80)
    497          #define BIT_LATCH_EN        (0x20)
    498          #define BIT_ANY_RD_CLR      (0x10)
    499          #define BIT_BYPASS_EN       (0x02)
    500          #define BITS_WOM_EN         (0xC0)
    501          #define BIT_LPA_CYCLE       (0x20)
    502          #define BIT_STBY_XA         (0x20)
    503          #define BIT_STBY_YA         (0x10)
    504          #define BIT_STBY_ZA         (0x08)
    505          #define BIT_STBY_XG         (0x04)
    506          #define BIT_STBY_YG         (0x02)
    507          #define BIT_STBY_ZG         (0x01)
    508          #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
    509          #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
    510          
    511          #if defined AK8975_SECONDARY
    512          #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
    513          #define AK89xx_FSR                  (9830)
    514          #elif defined AK8963_SECONDARY
    515          #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
    516          #define AK89xx_FSR                  (4915)
    517          #endif
    518          
    519          #ifdef AK89xx_SECONDARY
    520          #define AKM_REG_WHOAMI      (0x00)
    521          
    522          #define AKM_REG_ST1         (0x02)
    523          #define AKM_REG_HXL         (0x03)
    524          #define AKM_REG_ST2         (0x09)
    525          
    526          #define AKM_REG_CNTL        (0x0A)
    527          #define AKM_REG_ASTC        (0x0C)
    528          #define AKM_REG_ASAX        (0x10)
    529          #define AKM_REG_ASAY        (0x11)
    530          #define AKM_REG_ASAZ        (0x12)
    531          
    532          #define AKM_DATA_READY      (0x01)
    533          #define AKM_DATA_OVERRUN    (0x02)
    534          #define AKM_OVERFLOW        (0x80)
    535          #define AKM_DATA_ERROR      (0x40)
    536          
    537          #define AKM_BIT_SELF_TEST   (0x40)
    538          
    539          #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
    540          #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
    541          #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
    542          #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
    543          
    544          #define AKM_WHOAMI      (0x48)
    545          #endif
    546          
    547          #if defined MPU6050
    548          /*
    549          const struct gyro_reg_s reg = {
    550             .who_am_i       = 0x75,
    551              .rate_div       = 0x19,
    552              .lpf            = 0x1A,
    553              .prod_id        = 0x0C,
    554              .user_ctrl      = 0x6A,
    555              .fifo_en        = 0x23,
    556              .gyro_cfg       = 0x1B,
    557              .accel_cfg      = 0x1C,
    558              .motion_thr     = 0x1F,
    559              .motion_dur     = 0x20,
    560              .fifo_count_h   = 0x72,
    561              .fifo_r_w       = 0x74,
    562              .raw_gyro       = 0x43,
    563              .raw_accel      = 0x3B,
    564              .temp           = 0x41,
    565              .int_enable     = 0x38,
    566              .dmp_int_status = 0x39,
    567              .int_status     = 0x3A,
    568              .pwr_mgmt_1     = 0x6B,
    569              .pwr_mgmt_2     = 0x6C,
    570              .int_pin_cfg    = 0x37,
    571              .mem_r_w        = 0x6F,
    572              .accel_offs     = 0x06,
    573              .i2c_mst        = 0x24,
    574              .bank_sel       = 0x6D,
    575              .mem_start_addr = 0x6E,
    576              .prgm_start_h   = 0x70
    577          #ifdef AK89xx_SECONDARY
    578              ,.raw_compass   = 0x49,
    579              .yg_offs_tc     = 0x01,
    580              .s0_addr        = 0x25,
    581              .s0_reg         = 0x26,
    582              .s0_ctrl        = 0x27,
    583              .s1_addr        = 0x28,
    584              .s1_reg         = 0x29,
    585              .s1_ctrl        = 0x2A,
    586              .s4_ctrl        = 0x34,
    587              .s0_do          = 0x63,
    588              .s1_do          = 0x64,
    589              .i2c_delay_ctrl = 0x67
    590          #endif
    591          };
    592          const struct hw_s hw = {
    593              .addr           = 0x68,
    594              .max_fifo       = 1024,
    595              .num_reg        = 118,
    596              .temp_sens      = 340,
    597              .temp_offset    = -521,
    598              .bank_size      = 256
    599          #if defined AK89xx_SECONDARY
    600              ,.compass_fsr    = AK89xx_FSR
    601          #endif
    602          };
    603          */

   \                                 In  segment XDATA_ROM_C, align 1
    604          const struct hw_s hw={
   \                     hw:
   \   000000   68           DB 104
   \   000001   0004         DW 1024
   \   000003   76           DB 118
   \   000004   5401         DW 340
   \   000006   F7FD         DW -521
   \   000008   0001         DW 256
    605            0x68,	 //addr
    606            1024,	 //max_fifo
    607            118,	 //num_reg
    608            340,	 //temp_sens
    609            -521,	 //temp_offset
    610            256	 //bank_size
    611          };

   \                                 In  segment XDATA_ROM_C, align 1
    612          const struct gyro_reg_s reg = {
   \                     reg:
   \   000000   75           DB 117
   \   000001   19           DB 25
   \   000002   1A           DB 26
   \   000003   0C           DB 12
   \   000004   6A           DB 106
   \   000005   23           DB 35
   \   000006   1B           DB 27
   \   000007   1C           DB 28
   \   000008   1F           DB 31
   \   000009   20           DB 32
   \   00000A   72           DB 114
   \   00000B   74           DB 116
   \   00000C   43           DB 67
   \   00000D   3B           DB 59
   \   00000E   41           DB 65
   \   00000F   38           DB 56
   \   000010   39           DB 57
   \   000011   3A           DB 58
   \   000012   6B           DB 107
   \   000013   6C           DB 108
   \   000014   37           DB 55
   \   000015   6F           DB 111
   \   000016   06           DB 6
   \   000017   24           DB 36
   \   000018   6D           DB 109
   \   000019   6E           DB 110
   \   00001A   70           DB 112
    613          0x75,  //who_am_i
    614          0x19,  //rate_div
    615          0x1A,  //lpf
    616          0x0C,  //prod_id
    617          0x6A,  //user_ctrl
    618          0x23,  //fifo_en
    619          0x1B,  //gyro_cfg
    620          0x1C,  //accel_cfg
    621          0x1F,  // motion_thr
    622          0x20,  // motion_dur
    623          0x72,  // fifo_count_h
    624          0x74,  // fifo_r_w
    625          0x43,  // raw_gyro
    626          0x3B,  // raw_accel
    627          0x41,  // temp
    628          0x38,  // int_enable
    629          0x39,  //  dmp_int_status
    630          0x3A,  //  int_status
    631          0x6B,  // pwr_mgmt_1
    632          0x6C,  // pwr_mgmt_2
    633          0x37,  // int_pin_cfg
    634          0x6F,  // mem_r_w
    635          0x06,  // accel_offs
    636          0x24,  // i2c_mst
    637          0x6D,  // bank_sel
    638          0x6E,  // mem_start_addr
    639          0x70   // prgm_start_h
    640          };
    641          
    642          //const struct test_s test = {
    643          //    .gyro_sens      = 32768/250,
    644          //    .accel_sens     = 32768/16,	  
    645          //    .reg_rate_div   = 0,    /* 1kHz. */
    646          //    .reg_lpf        = 1,    /* 188Hz. */
    647          //    .reg_gyro_fsr   = 0,    /* 250dps. */
    648          //    .reg_accel_fsr  = 0x18, /* 16g. */
    649          //    .wait_ms        = 50,
    650          //    .packet_thresh  = 5,    /* 5% */
    651          //    .min_dps        = 10.f,
    652          //    .max_dps        = 105.f,
    653          //    .max_gyro_var   = 0.14f,
    654          //    .min_g          = 0.3f,
    655          //    .max_g          = 0.95f,
    656          //    .max_accel_var  = 0.14f
    657          //};

   \                                 In  segment XDATA_ROM_C, align 1
    658          const struct test_s test={
   \                     test:
   \   000000   83000000     DD 131
   \   000004   00080000     DD 2048
   \   000008   00           DB 0
   \   000009   01           DB 1
   \   00000A   00           DB 0
   \   00000B   18           DB 24
   \   00000C   3200         DW 50
   \   00000E   05           DB 5
   \   00000F   00002041     DD 41200000H
   \   000013   0000D242     DD 42D20000H
   \   000017   295C0F3E     DD 3E0F5C29H
   \   00001B   9A99993E     DD 3E99999AH
   \   00001F   3333733F     DD 3F733333H
   \   000023   295C0F3E     DD 3E0F5C29H
    659          32768/250,		 //gyro_sens
    660          32768/16,		 //	accel_sens
    661          0,				 //	reg_rate_div
    662          1,				//	reg_lpf
    663          0,				 //	reg_gyro_fsr
    664          0x18,			//	reg_accel_fsr
    665          50,				//	wait_ms
    666          5,				//	packet_thresh
    667          10.0f,			 //	min_dps
    668          105.0f,			 //	max_dps
    669          0.14f,			//	max_gyro_var
    670          0.3f,		   //	min_g
    671          0.95f,		   //	max_g
    672          0.14f		   //	max_accel_var
    673          };
    674          /*
    675          static struct gyro_state_s st = {
    676              .reg = &reg,
    677              .hw = &hw,
    678              .test = &test
    679          };	*/

   \                                 In  segment XDATA_I, align 1, keep-with-next
    680          static struct gyro_state_s st={
   \                     st:
   \   000000                DS 35
   \   000023                REQUIRE `?<Initializer for st>`
   \   000023                REQUIRE __INIT_XDATA_I
    681            &reg,
    682            &hw,
    683            {0},
    684            &test
    685          };
    686          //st.chip_cfg.dmp_on = 1;
    687          //st.dhip_cfg.fifo_enabel = 1;
    688          /*
    689          #elif defined MPU6500
    690          const struct gyro_reg_s reg = {
    691              .who_am_i       = 0x75,
    692              .rate_div       = 0x19,
    693              .lpf            = 0x1A,
    694              .prod_id        = 0x0C,
    695              .user_ctrl      = 0x6A,
    696              .fifo_en        = 0x23,
    697              .gyro_cfg       = 0x1B,
    698              .accel_cfg      = 0x1C,
    699              .accel_cfg2     = 0x1D,
    700              .lp_accel_odr   = 0x1E,
    701              .motion_thr     = 0x1F,
    702              .motion_dur     = 0x20,
    703              .fifo_count_h   = 0x72,
    704              .fifo_r_w       = 0x74,
    705              .raw_gyro       = 0x43,
    706              .raw_accel      = 0x3B,
    707              .temp           = 0x41,
    708              .int_enable     = 0x38,
    709              .dmp_int_status = 0x39,
    710              .int_status     = 0x3A,
    711              .accel_intel    = 0x69,
    712              .pwr_mgmt_1     = 0x6B,
    713              .pwr_mgmt_2     = 0x6C,
    714              .int_pin_cfg    = 0x37,
    715              .mem_r_w        = 0x6F,
    716              .accel_offs     = 0x77,
    717              .i2c_mst        = 0x24,
    718              .bank_sel       = 0x6D,
    719              .mem_start_addr = 0x6E,
    720              .prgm_start_h   = 0x70
    721          #ifdef AK89xx_SECONDARY
    722              ,.raw_compass   = 0x49,
    723              .s0_addr        = 0x25,
    724              .s0_reg         = 0x26,
    725              .s0_ctrl        = 0x27,
    726              .s1_addr        = 0x28,
    727              .s1_reg         = 0x29,
    728              .s1_ctrl        = 0x2A,
    729              .s4_ctrl        = 0x34,
    730              .s0_do          = 0x63,
    731              .s1_do          = 0x64,
    732              .i2c_delay_ctrl = 0x67
    733          #endif
    734          };
    735          const struct hw_s hw = {
    736              .addr           = 0x68,
    737              .max_fifo       = 1024,
    738              .num_reg        = 128,
    739              .temp_sens      = 321,
    740              .temp_offset    = 0,
    741              .bank_size      = 256
    742          #if defined AK89xx_SECONDARY
    743              ,.compass_fsr    = AK89xx_FSR
    744          #endif
    745          };
    746          */
    747          //const struct test_s test = {
    748          //    .gyro_sens      = 32768/250,
    749          //    .accel_sens     = 32768/16,
    750          //    .reg_rate_div   = 0,    /* 1kHz. */
    751          //    .reg_lpf        = 1,    /* 188Hz. */
    752          //    .reg_gyro_fsr   = 0,    /* 250dps. */
    753          //    .reg_accel_fsr  = 0x18, /* 16g. */
    754          //    .wait_ms        = 50,
    755          //    .packet_thresh  = 5,    /* 5% */
    756          //    .min_dps        = 10.f,
    757          //    .max_dps        = 105.f,
    758          //    .max_gyro_var   = 0.14f,
    759          //    .min_g          = 0.3f,
    760          //    .max_g          = 0.95f,
    761          //    .max_accel_var  = 0.14f
    762          //};
    763          //
    764          //static struct gyro_state_s st = {
    765          //    .reg = &reg,
    766          //    .hw = &hw,
    767          //    .test = &test
    768          //};
    769          #endif
    770          
    771          #define MAX_PACKET_LENGTH (12)
    772          
    773          #ifdef AK89xx_SECONDARY
    774          static int setup_compass(void);
    775          #define MAX_COMPASS_SAMPLE_RATE (100)
    776          #endif
    777          
    778          /**
    779           *  @brief      Enable/disable data ready interrupt.
    780           *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
    781           *  interrupt is used.
    782           *  @param[in]  enable      1 to enable interrupt.
    783           *  @return     0 if successful.
    784           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    785          static int set_int_enable(unsigned char enable)
   \                     set_int_enable:
    786          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    787              unsigned char tmp;
    788          
    789              if (st.chip_cfg.dmp_on) {
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   601D         JZ      ??set_int_enable_0
    790                  if (enable)
   \   000012   EE           MOV     A,R6
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   6004         JZ      ??set_int_enable_1
    791                      tmp = BIT_DMP_INT_EN;
   \   00001B   7402         MOV     A,#0x2
   \   00001D   8001         SJMP    ??set_int_enable_2
    792                  else
    793                      tmp = 0x00;
   \                     ??set_int_enable_1:
   \   00001F   E4           CLR     A
   \                     ??set_int_enable_2:
   \   000020   12....       LCALL   ??Subroutine133_0 & 0xFFFF
    794                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
   \                     ??CrossCallReturnLabel_257:
   \   000023   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000026   6035         JZ      ??set_int_enable_3
    795                      return -1;
   \                     ??set_int_enable_4:
   \   000028   7AFF         MOV     R2,#-0x1
   \   00002A   7BFF         MOV     R3,#-0x1
   \                     ??set_int_enable_5:
   \   00002C   02....       LJMP    ?Subroutine3 & 0xFFFF
    796                  st.chip_cfg.int_enable = tmp;
    797              } else {
    798                  if (!st.chip_cfg.sensors)
   \                     ??set_int_enable_0:
   \   00002F   90....       MOV     DPTR,#st + 6
   \   000032   E0           MOVX    A,@DPTR
   \   000033   60F3         JZ      ??set_int_enable_4
    799                      return -1;
    800                  if (enable && st.chip_cfg.int_enable)
   \   000035   EE           MOV     A,R6
   \   000036   6016         JZ      ??set_int_enable_6
   \   000038   90....       MOV     DPTR,#st + 12
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6006         JZ      ??set_int_enable_7
    801                      return 0;
   \                     ??set_int_enable_8:
   \   00003E   7A00         MOV     R2,#0x0
   \   000040   7B00         MOV     R3,#0x0
   \   000042   80E8         SJMP    ??set_int_enable_5
    802                  if (enable)
    803                      tmp = BIT_DATA_RDY_EN;
   \                     ??set_int_enable_7:
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   7401         MOV     A,#0x1
   \   00004C   8007         SJMP    ??set_int_enable_9
    804                  else
    805                      tmp = 0x00;
   \                     ??set_int_enable_6:
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   E4           CLR     A
    806                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
    807                      return -1;
    808                  st.chip_cfg.int_enable = tmp;
    809              }
   \                     ??set_int_enable_9:
   \   000055   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000058   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   00005B   70CB         JNZ     ??set_int_enable_4
   \                     ??set_int_enable_3:
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   90....       MOV     DPTR,#st + 12
   \   000067   F0           MOVX    @DPTR,A
   \   000068   80D4         SJMP    ??set_int_enable_8
    810              return 0;
    811          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7401         MOV     A,#0x1
   \   000002                REQUIRE ??Subroutine115_0
   \   000002                ; // Fall through to label ??Subroutine115_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F02         MOV     R7,#0x2
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001   AC82         MOV     R4,DPL
   \   000003   AD83         MOV     R5,DPH
   \   000005   7B01         MOV     R3,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   240F         ADD     A,#0xf
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   90....       MOV     DPTR,#st
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F9           MOV     R1,A
   \   000006   8882         MOV     DPL,R0
   \   000008   8983         MOV     DPH,R1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002                REQUIRE ??Subroutine134_0
   \   000002                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   000003   12....       LCALL   ??I2C_Write?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000003                REQUIRE ??Subroutine139_0
   \   000003                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   000003   8B..         MOV     ?V0 + 1,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 1
   \   000008   22           RET
    812          
    813          /**
    814           *  @brief      Register dump for testing.
    815           *  @return     0 if successful.
    816           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    817          int mpu_reg_dump(void)
   \                     mpu_reg_dump:
    818          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    819              unsigned char ii;
    820              unsigned char data;
    821          
    822              for (ii = 0; ii < st.hw->num_reg; ii++) {
   \   00000A   7E00         MOV     R6,#0x0
   \   00000C   8001         SJMP    ??mpu_reg_dump_0
   \                     ??mpu_reg_dump_1:
   \   00000E   0E           INC     R6
   \                     ??mpu_reg_dump_0:
   \   00000F   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000012   5035         JNC     ??mpu_reg_dump_2
    823                  if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
   \   000014   90....       MOV     DPTR,#st
   \   000017   E0           MOVX    A,@DPTR
   \   000018   240B         ADD     A,#0xb
   \   00001A   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00001D   60EF         JZ      ??mpu_reg_dump_1
   \   00001F   90....       MOV     DPTR,#st
   \   000022   E0           MOVX    A,@DPTR
   \   000023   2415         ADD     A,#0x15
   \   000025   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000028   60E4         JZ      ??mpu_reg_dump_1
    824                      continue;
    825                  if (i2c_read(st.hw->addr, ii, 1, &data))
   \   00002A                ; Setup parameters for call to function I2C_Read
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   AC82         MOV     R4,DPL
   \   000032   AD83         MOV     R5,DPH
   \   000034   7B01         MOV     R3,#0x1
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   8882         MOV     DPL,R0
   \   00003A   8983         MOV     DPH,R1
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000041   60CB         JZ      ??mpu_reg_dump_1
    826                      return -1;
   \   000043   7AFF         MOV     R2,#-0x1
   \   000045   7BFF         MOV     R3,#-0x1
   \   000047   8004         SJMP    ??mpu_reg_dump_3
    827                  //log_i("%#5x: %#5x\r\n", ii, data);
    828              }
    829              return 0;
   \                     ??mpu_reg_dump_2:
   \   000049   7A00         MOV     R2,#0x0
   \   00004B   7B00         MOV     R3,#0x0
   \                     ??mpu_reg_dump_3:
   \   00004D   02....       LJMP    ?Subroutine3 & 0xFFFF
    830          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   FB           MOV     R3,A
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   6E           XRL     A,R6
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   EE           MOV     A,R6
   \   000006   C3           CLR     C
   \   000007   9A           SUBB    A,R2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ??I2C_Read?relay
   \   000003   8B..         MOV     ?V0 + 1,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   8882         MOV     DPL,R0
   \   00000A   8983         MOV     DPH,R1
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET
    831          
    832          /**
    833           *  @brief      Read from a single register.
    834           *  NOTE: The memory and FIFO read/write registers cannot be accessed.
    835           *  @param[in]  reg     Register address.
    836           *  @param[out] data    Register data.
    837           *  @return     0 if successful.
    838           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    839          int mpu_read_reg(unsigned char reg, unsigned char *data)
   \                     mpu_read_reg:
    840          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
    841              if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
   \   00000B   90....       MOV     DPTR,#st
   \   00000E   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000011   6E           XRL     A,R6
   \   000012   600D         JZ      ??mpu_read_reg_0
   \   000014   90....       MOV     DPTR,#st
   \   000017   E0           MOVX    A,@DPTR
   \   000018   2415         ADD     A,#0x15
   \   00001A   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6E           XRL     A,R6
   \   00001F   7006         JNZ     ??mpu_read_reg_1
    842                  return -1;
   \                     ??mpu_read_reg_0:
   \   000021   7AFF         MOV     R2,#-0x1
   \   000023   7BFF         MOV     R3,#-0x1
   \   000025   8012         SJMP    ??mpu_read_reg_2
    843              if (reg >= st.hw->num_reg)
   \                     ??mpu_read_reg_1:
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00002A   50F5         JNC     ??mpu_read_reg_0
    844                  return -1;
    845              return i2c_read(st.hw->addr, reg, 1, data);
   \   00002C                ; Setup parameters for call to function I2C_Read
   \   00002C   7B01         MOV     R3,#0x1
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   8882         MOV     DPL,R0
   \   000032   8983         MOV     DPH,R1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F9           MOV     R1,A
   \   000036   12....       LCALL   ??I2C_Read?relay
   \                     ??mpu_read_reg_2:
   \   000039                REQUIRE ?Subroutine4
   \   000039                ; // Fall through to label ?Subroutine4
    846          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   240B         ADD     A,#0xb
   \   000003   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000003   22           RET
    847          
    848          /**
    849           *  @brief      Initialize hardware.
    850           *  Initial configuration:\n
    851           *  Gyro FSR: +/- 2000DPS\n
    852           *  Accel FSR +/- 2G\n
    853           *  DLPF: 42Hz\n
    854           *  FIFO rate: 50Hz\n
    855           *  Clock source: Gyro PLL\n
    856           *  FIFO: Disabled.\n
    857           *  Data ready interrupt: Disabled, active low, unlatched.
    858           *  @param[in]  int_param   Platform-specific parameters to interrupt API.
    859           *  @return     0 if successful.
    860           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    861          int mpu_init(void)
   \                     mpu_init:
    862          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    863              unsigned char data[6], rev;
    864          
    865              /* Reset device. */
    866              data[0] = 0x80;//BIT_RESET;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7480         MOV     A,#-0x80
   \   000012   12....       LCALL   ?Subroutine64 & 0xFFFF
    867              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0])))
   \                     ??CrossCallReturnLabel_100:
   \   000015   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000018   6007         JZ      ??mpu_init_0
    868                  return -1;
   \                     ??mpu_init_1:
   \   00001A   7AFF         MOV     R2,#-0x1
   \   00001C   7BFF         MOV     R3,#-0x1
   \   00001E   02....       LJMP    ??mpu_init_2 & 0xFFFF
    869              delay_ms(100);
   \                     ??mpu_init_0:
   \   000021                ; Setup parameters for call to function delay_ms
   \   000021   7A64         MOV     R2,#0x64
   \   000023   12....       LCALL   ?Subroutine67 & 0xFFFF
    870          
    871              /* Wake up chip. */
    872              data[0] = 0x00;
   \                     ??CrossCallReturnLabel_103:
   \   000026   E4           CLR     A
   \   000027   12....       LCALL   ?Subroutine64 & 0xFFFF
    873              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0])))
   \                     ??CrossCallReturnLabel_101:
   \   00002A   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   00002D   70EB         JNZ     ??mpu_init_1
    874                  return -1;
    875           
    876          #if defined MPU6050
    877              /* Check product revision. */
    878              if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
   \   00002F                ; Setup parameters for call to function I2C_Read
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   AC82         MOV     R4,DPL
   \   000037   AD83         MOV     R5,DPH
   \   000039   7B06         MOV     R3,#0x6
   \   00003B   90....       MOV     DPTR,#st
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   2416         ADD     A,#0x16
   \   000041   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000044   70D4         JNZ     ??mpu_init_1
    879                  return -1;
    880              rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
    881                  (data[1] & 0x01);
   \   000046   7401         MOV     A,#0x1
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   E4           CLR     A
   \   00004F   33           RLC     A
   \   000050   F9           MOV     R1,A
   \   000051   7403         MOV     A,#0x3
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   E0           MOVX    A,@DPTR
   \   000057   A2E0         MOV     C,0xE0 /* A   */.0
   \   000059   E4           CLR     A
   \   00005A   33           RLC     A
   \   00005B   33           RLC     A
   \   00005C   F8           MOV     R0,A
   \   00005D   7405         MOV     A,#0x5
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   E0           MOVX    A,@DPTR
   \   000063   A2E0         MOV     C,0xE0 /* A   */.0
   \   000065   E4           CLR     A
   \   000066   33           RLC     A
   \   000067   33           RLC     A
   \   000068   33           RLC     A
   \   000069   48           ORL     A,R0
   \   00006A   49           ORL     A,R1
   \   00006B   F8           MOV     R0,A
    882          		
    883              if (rev) {
   \   00006C   606A         JZ      ??mpu_init_3
    884                  /* Congrats, these parts are better. */
    885                  if (rev == 1)
   \   00006E   7401         MOV     A,#0x1
   \   000070   68           XRL     A,R0
   \   000071   7057         JNZ     ??mpu_init_4
    886                      st.chip_cfg.accel_half = 1;
   \                     ??mpu_init_5:
   \   000073   90....       MOV     DPTR,#st + 14
   \   000076   7401         MOV     A,#0x1
   \                     ??mpu_init_6:
   \   000078   F0           MOVX    @DPTR,A
    887                  else if (rev == 2)
    888                      st.chip_cfg.accel_half = 0;
    889                  else {
    890                      //log_e("Unsupported software product rev %d.\n");
    891                      return -1;
    892                  }
    893              } else {
    894                  if (i2c_read(st.hw->addr, st.reg->prod_id, 1, &(data[0])))
    895                      return -1;
    896                  rev = data[0] & 0x0F;
    897                  if (!rev) {
    898                     // log_e("Product ID read as 0 indicates device is either "
    899                          //"incompatible or an MPU3050.\n");
    900                      return -1;
    901                  } else if (rev == 4) {
    902                      //log_i("Half sensitivity part found.\n");
    903                      st.chip_cfg.accel_half = 1;
    904                  } else
    905                      st.chip_cfg.accel_half = 0;
    906              }
    907          ////////////////////////////Œ¥÷¥––//////////////////////////////
    908          #elif defined MPU6500
    909          #define MPU6500_MEM_REV_ADDR    (0x17)
    910              if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
    911                  return -1;
    912              if (rev == 0x1)
    913                  st.chip_cfg.accel_half = 0;
    914              else {
    915                  //log_e("Unsupported software product rev %d.\n", rev);
    916                  return -1;
    917              }
    918          
    919              /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
    920               * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
    921               */
    922              data[0] = BIT_FIFO_SIZE_1024 | 0x8;
    923              if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
    924                  return -1;
    925          #endif
    926          /////////////////////////////////////////////////////////
    927              /* Set to invalid values to ensure no I2C writes are skipped. */
    928              st.chip_cfg.sensors = 0xFF;
   \   000079   90....       MOV     DPTR,#st + 6
   \   00007C   74FF         MOV     A,#-0x1
   \   00007E   F0           MOVX    @DPTR,A
    929              st.chip_cfg.gyro_fsr = 0xFF;
   \   00007F   90....       MOV     DPTR,#st + 4
   \   000082   12....       LCALL   ?Subroutine93 & 0xFFFF
    930              st.chip_cfg.accel_fsr = 0xFF;
    931              st.chip_cfg.lpf = 0xFF;
    932              st.chip_cfg.sample_rate = 0xFFFF;
    933              st.chip_cfg.fifo_enable = 0xFF;
   \                     ??CrossCallReturnLabel_145:
   \   000085   A3           INC     DPTR
   \   000086   F0           MOVX    @DPTR,A
    934              st.chip_cfg.bypass_mode = 0xFF;
   \   000087   90....       MOV     DPTR,#st + 13
   \   00008A   F0           MOVX    @DPTR,A
    935          //////////////////////////////////Œ¥÷¥––//////////////////////////////
    936          #ifdef AK89xx_SECONDARY
    937              st.chip_cfg.compass_sample_rate = 0xFFFF;
    938          #endif
    939          //////////////////////////////////////////////////////////////////////
    940              /* mpu_set_sensors always preserves this setting. */
    941              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   00008B   90....       MOV     DPTR,#st + 8
   \   00008E   7401         MOV     A,#0x1
   \   000090   F0           MOVX    @DPTR,A
    942              /* Handled in next call to mpu_set_bypass. */
    943              st.chip_cfg.active_low_int = 1;
   \   000091   90....       MOV     DPTR,#st + 27
   \   000094   F0           MOVX    @DPTR,A
    944              st.chip_cfg.latched_int = 0;
   \   000095   A3           INC     DPTR
   \   000096   E4           CLR     A
   \   000097   F0           MOVX    @DPTR,A
    945              st.chip_cfg.int_motion_only = 0;
   \   000098   90....       MOV     DPTR,#st + 16
   \   00009B   F0           MOVX    @DPTR,A
    946              st.chip_cfg.lp_accel_mode = 0;
   \   00009C   90....       MOV     DPTR,#st + 15
   \   00009F   F0           MOVX    @DPTR,A
    947              memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
   \   0000A0                ; Setup parameters for call to function memset
   \   0000A0   75..0A       MOV     ?V0 + 0,#0xa
   \   0000A3   F5..         MOV     ?V0 + 1,A
   \   0000A5   78..         MOV     R0,#?V0 + 0
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AA   7C00         MOV     R4,#0x0
   \   0000AC   7D00         MOV     R5,#0x0
   \   0000AE   7A..         MOV     R2,#(st + 17) & 0xff
   \   0000B0   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   0000B2   12....       LCALL   ??memset?relay
   \   0000B5   7402         MOV     A,#0x2
   \   0000B7   12....       LCALL   ?DEALLOC_XSTACK8
    948              st.chip_cfg.dmp_on = 0;
   \   0000BA   90....       MOV     DPTR,#st + 29
   \   0000BD   E4           CLR     A
   \   0000BE   F0           MOVX    @DPTR,A
    949              st.chip_cfg.dmp_loaded = 0;
   \   0000BF   A3           INC     DPTR
   \   0000C0   F0           MOVX    @DPTR,A
    950              st.chip_cfg.dmp_sample_rate = 0;
   \   0000C1   A3           INC     DPTR
   \   0000C2   F0           MOVX    @DPTR,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   F0           MOVX    @DPTR,A
    951             /* if (mpu_set_gyro_fsr(2000))
    952                  return -1;
    953              if (mpu_set_accel_fsr(2))
    954                  return -1;
    955              if (mpu_set_lpf(42))
    956                  return -1;
    957              if (mpu_set_sample_rate(50))
    958                  return -1;
    959              if (mpu_configure_fifo(0))
    960                  return -1;*/
    961          
    962              /*if (int_param)
    963                  reg_int_cb(int_param);*/
    964          ////////////////////////////////Œ¥÷¥––///////////////////////////////
    965          #ifdef AK89xx_SECONDARY
    966              setup_compass();
    967              if (mpu_set_compass_sample_rate(10))
    968                  return -1;
    969          ///////////////////////////////////////////////////////////////////////
    970          #else
    971          ////////////////////////////////ø…»•≥˝///////////////////////////////////
    972          				//printf("lalala");
    973              /* Already disabled by setup_compass. */
    974              //if (mpu_set_bypass(0))
    975                 // return -1;
    976          /////////////////////////////////////////////////////////////////////////
    977          #endif
    978          
    979              //mpu_set_sensors(0);
    980              return 0;
   \   0000C5   FA           MOV     R2,A
   \   0000C6   FB           MOV     R3,A
   \                     ??mpu_init_2:
   \   0000C7   02....       LJMP    ?Subroutine8 & 0xFFFF
   \                     ??mpu_init_4:
   \   0000CA   7402         MOV     A,#0x2
   \   0000CC   68           XRL     A,R0
   \   0000CD   6003         JZ      $+5
   \   0000CF   02....       LJMP    ??mpu_init_1 & 0xFFFF
   \                     ??mpu_init_7:
   \   0000D2   90....       MOV     DPTR,#st + 14
   \   0000D5   E4           CLR     A
   \   0000D6   80A0         SJMP    ??mpu_init_6
   \                     ??mpu_init_3:
   \   0000D8                ; Setup parameters for call to function I2C_Read
   \   0000D8   85..82       MOV     DPL,?XSP + 0
   \   0000DB   85..83       MOV     DPH,?XSP + 1
   \   0000DE   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   0000E1   A3           INC     DPTR
   \   0000E2   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   0000E5   6003         JZ      $+5
   \   0000E7   02....       LJMP    ??mpu_init_1 & 0xFFFF
   \   0000EA   85..82       MOV     DPL,?XSP + 0
   \   0000ED   85..83       MOV     DPH,?XSP + 1
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   540F         ANL     A,#0xf
   \   0000F3   F8           MOV     R0,A
   \   0000F4   7003         JNZ     $+5
   \   0000F6   02....       LJMP    ??mpu_init_1 & 0xFFFF
   \   0000F9   7404         MOV     A,#0x4
   \   0000FB   68           XRL     A,R0
   \   0000FC   70D4         JNZ     ??mpu_init_7
   \   0000FE   02....       LJMP    ??mpu_init_5 & 0xFFFF
    981          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7406         MOV     A,#0x6
   \   000002   02....       LJMP    ??Subroutine115_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??delay_ms?relay
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000003   12....       LCALL   ??I2C_Read?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   90....       MOV     DPTR,#st
   \   000003                REQUIRE ??Subroutine126_0
   \   000003                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000003                REQUIRE ??Subroutine127_0
   \   000003                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002                REQUIRE ??Subroutine128_0
   \   000002                ; // Fall through to label ??Subroutine128_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000003   8B..         MOV     ?V0 + 1,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   90....       MOV     DPTR,#st + 7
   \   000006   F0           MOVX    @DPTR,A
   \   000007   90....       MOV     DPTR,#st + 9
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   90....       MOV     DPTR,#st
   \   000003   E0           MOVX    A,@DPTR
   \   000004   2412         ADD     A,#0x12
   \   000006                REQUIRE ??Subroutine138_0
   \   000006                ; // Fall through to label ??Subroutine138_0
    982          
    983          /**
    984           *  @brief      Enter low-power accel-only mode.
    985           *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
    986           *  the accelerometer at one of the following frequencies:
    987           *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
    988           *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
    989           *  \n If the requested rate is not one listed above, the device will be set to
    990           *  the next highest rate. Requesting a rate above the maximum supported
    991           *  frequency will result in an error.
    992           *  \n To select a fractional wake-up frequency, round down the value passed to
    993           *  @e rate.
    994           *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
    995           *                          accel mode.
    996           *  @return     0 if successful.
    997           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    998          int mpu_lp_accel_mode(unsigned char rate)
   \                     mpu_lp_accel_mode:
    999          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1000              unsigned char tmp[2];
   1001          
   1002              if (rate > 40)
   \   00000C   C3           CLR     C
   \   00000D   9429         SUBB    A,#0x29
   \   00000F   4007         JC      ??mpu_lp_accel_mode_0
   1003                  return -1;
   \                     ??mpu_lp_accel_mode_1:
   \   000011   7AFF         MOV     R2,#-0x1
   \   000013   7BFF         MOV     R3,#-0x1
   \   000015   02....       LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
   1004          
   1005              if (!rate) {
   \                     ??mpu_lp_accel_mode_0:
   \   000018   EE           MOV     A,R6
   \   000019   701B         JNZ     ??mpu_lp_accel_mode_3
   1006                  mpu_set_int_latched(0);
   \   00001B                ; Setup parameters for call to function mpu_set_int_latched
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   12....       LCALL   ?Subroutine69 & 0xFFFF
   1007                  tmp[0] = 0;
   \                     ??CrossCallReturnLabel_109:
   \   000020   E4           CLR     A
   \   000021   F0           MOVX    @DPTR,A
   1008                  tmp[1] = BIT_STBY_XYZG;
   \   000022   04           INC     A
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   7407         MOV     A,#0x7
   \   000028   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   1009                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \                     ??CrossCallReturnLabel_277:
   \   00002B   70E4         JNZ     ??mpu_lp_accel_mode_1
   1010                      return -1;
   1011                  st.chip_cfg.lp_accel_mode = 0;
   \   00002D   90....       MOV     DPTR,#st + 15
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
   1012                  return 0;
   \   000032   FA           MOV     R2,A
   \   000033   FB           MOV     R3,A
   \   000034   806D         SJMP    ??mpu_lp_accel_mode_2
   1013              }
   1014              /* For LP accel, we automatically configure the hardware to produce latched
   1015               * interrupts. In LP accel mode, the hardware cycles into sleep mode before
   1016               * it gets a chance to deassert the interrupt pin; therefore, we shift this
   1017               * responsibility over to the MCU.
   1018               *
   1019               * Any register read will clear the interrupt.
   1020               */
   1021              mpu_set_int_latched(1);
   \                     ??mpu_lp_accel_mode_3:
   \   000036                ; Setup parameters for call to function mpu_set_int_latched
   \   000036   7901         MOV     R1,#0x1
   \   000038   12....       LCALL   ?Subroutine69 & 0xFFFF
   1022          #if defined MPU6050
   1023              tmp[0] = BIT_LPA_CYCLE;
   \                     ??CrossCallReturnLabel_110:
   \   00003B   7420         MOV     A,#0x20
   \   00003D   F0           MOVX    @DPTR,A
   1024              if (rate == 1) {
   \   00003E   7401         MOV     A,#0x1
   \   000040   6E           XRL     A,R6
   \   000041   700C         JNZ     ??mpu_lp_accel_mode_4
   1025                  tmp[1] = INV_LPA_1_25HZ;
   \   000043   7401         MOV     A,#0x1
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   1026                  mpu_set_lpf(5);
   \   00004A                ; Setup parameters for call to function mpu_set_lpf
   \   00004A   7A05         MOV     R2,#0x5
   \   00004C   FB           MOV     R3,A
   \   00004D   802E         SJMP    ??mpu_lp_accel_mode_5
   1027              } else if (rate <= 5) {
   \                     ??mpu_lp_accel_mode_4:
   \   00004F   EE           MOV     A,R6
   \   000050   C3           CLR     C
   \   000051   9406         SUBB    A,#0x6
   \   000053   500C         JNC     ??mpu_lp_accel_mode_6
   1028                  tmp[1] = INV_LPA_5HZ;
   \   000055   7401         MOV     A,#0x1
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   7401         MOV     A,#0x1
   \   00005C   F0           MOVX    @DPTR,A
   1029                  mpu_set_lpf(5);
   \   00005D                ; Setup parameters for call to function mpu_set_lpf
   \   00005D   7A05         MOV     R2,#0x5
   \   00005F   801A         SJMP    ??mpu_lp_accel_mode_7
   1030              } else if (rate <= 20) {
   \                     ??mpu_lp_accel_mode_6:
   \   000061   EE           MOV     A,R6
   \   000062   C3           CLR     C
   \   000063   9415         SUBB    A,#0x15
   \   000065   7401         MOV     A,#0x1
   \   000067   500A         JNC     ??mpu_lp_accel_mode_8
   1031                  tmp[1] = INV_LPA_20HZ;
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   7402         MOV     A,#0x2
   \   00006E   F0           MOVX    @DPTR,A
   1032                  mpu_set_lpf(10);
   \   00006F                ; Setup parameters for call to function mpu_set_lpf
   \   00006F   7A0A         MOV     R2,#0xa
   \   000071   8008         SJMP    ??mpu_lp_accel_mode_7
   1033              } else {
   1034                  tmp[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_accel_mode_8:
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   7403         MOV     A,#0x3
   \   000078   F0           MOVX    @DPTR,A
   1035                  mpu_set_lpf(20);
   \   000079                ; Setup parameters for call to function mpu_set_lpf
   \   000079   7A14         MOV     R2,#0x14
   \                     ??mpu_lp_accel_mode_7:
   \   00007B   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_5:
   \   00007D   12....       LCALL   ??mpu_set_lpf?relay
   1036              }
   1037              tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
   \   000080   7401         MOV     A,#0x1
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   12....       LCALL   ?Subroutine10 & 0xFFFF
   1038              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \                     ??CrossCallReturnLabel_275:
   \   000088   7087         JNZ     ??mpu_lp_accel_mode_1
   1039                  return -1;
   1040          #elif defined MPU6500
   1041              /* Set wake frequency. */
   1042              if (rate == 1)
   1043                  tmp[0] = INV_LPA_1_25HZ;
   1044              else if (rate == 2)
   1045                  tmp[0] = INV_LPA_2_5HZ;
   1046              else if (rate <= 5)
   1047                  tmp[0] = INV_LPA_5HZ;
   1048              else if (rate <= 10)
   1049                  tmp[0] = INV_LPA_10HZ;
   1050              else if (rate <= 20)
   1051                  tmp[0] = INV_LPA_20HZ;
   1052              else if (rate <= 40)
   1053                  tmp[0] = INV_LPA_40HZ;
   1054              else if (rate <= 80)
   1055                  tmp[0] = INV_LPA_80HZ;
   1056              else if (rate <= 160)
   1057                  tmp[0] = INV_LPA_160HZ;
   1058              else if (rate <= 320)
   1059                  tmp[0] = INV_LPA_320HZ;
   1060              else
   1061                  tmp[0] = INV_LPA_640HZ;
   1062              if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
   1063                  return -1;
   1064              tmp[0] = BIT_LPA_CYCLE;
   1065              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
   1066                  return -1;
   1067          #endif
   1068              st.chip_cfg.sensors = INV_XYZ_ACCEL;
   \   00008A   90....       MOV     DPTR,#st + 6
   \   00008D   7408         MOV     A,#0x8
   \   00008F   F0           MOVX    @DPTR,A
   1069              st.chip_cfg.clk_src = 0;
   \   000090   90....       MOV     DPTR,#st + 8
   \   000093   E4           CLR     A
   \   000094   F0           MOVX    @DPTR,A
   1070              st.chip_cfg.lp_accel_mode = 1;
   \   000095   90....       MOV     DPTR,#st + 15
   \   000098   04           INC     A
   \   000099   F0           MOVX    @DPTR,A
   1071              mpu_configure_fifo(0);
   \   00009A                ; Setup parameters for call to function mpu_configure_fifo
   \   00009A   7900         MOV     R1,#0x0
   \   00009C   12....       LCALL   ??mpu_configure_fifo?relay
   1072          
   1073              return 0;
   \   00009F   7A00         MOV     R2,#0x0
   \   0000A1   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_2:
   \   0000A3                REQUIRE ?Subroutine9
   \   0000A3                ; // Fall through to label ?Subroutine9
   1074          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7402         MOV     A,#0x2
   \   000002   02....       LJMP    ??Subroutine115_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   12....       LCALL   ??mpu_set_int_latched?relay
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Read
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C4           SWAP    A
   \   000002   33           RLC     A
   \   000003   33           RLC     A
   \   000004   54C0         ANL     A,#0xc0
   \   000006   4407         ORL     A,#0x7
   \   000008                REQUIRE ??Subroutine135_0
   \   000008                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000003                REQUIRE ??Subroutine136_0
   \   000003                ; // Fall through to label ??Subroutine136_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B02         MOV     R3,#0x2
   \   000006                REQUIRE ??Subroutine137_0
   \   000006                ; // Fall through to label ??Subroutine137_0
   1075          
   1076          /**
   1077           *  @brief      Read raw gyro data directly from the registers.
   1078           *  @param[out] data        Raw data in hardware units.
   1079           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1080           *  @return     0 if successful.
   1081           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1082          int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_gyro_reg:
   1083          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1084              unsigned char tmp[6];
   1085          
   1086              if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   5470         ANL     A,#0x70
   \   000014   7006         JNZ     ??mpu_get_gyro_reg_0
   1087                  return -1;
   \                     ??mpu_get_gyro_reg_1:
   \   000016   7AFF         MOV     R2,#-0x1
   \   000018   7BFF         MOV     R3,#-0x1
   \   00001A   803A         SJMP    ??CrossCallReturnLabel_29
   1088          
   1089              if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
   \                     ??mpu_get_gyro_reg_0:
   \   00001C                ; Setup parameters for call to function I2C_Read
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   7B06         MOV     R3,#0x6
   \   000028   90....       MOV     DPTR,#st
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   240C         ADD     A,#0xc
   \   00002E   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000031   70E3         JNZ     ??mpu_get_gyro_reg_1
   1090                  return -1;
   1091              data[0] = (tmp[0] << 8) | tmp[1];
   \   000033   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine46 & 0xFFFF
   1092              data[1] = (tmp[2] << 8) | tmp[3];
   \                     ??CrossCallReturnLabel_61:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine39 & 0xFFFF
   1093              data[2] = (tmp[4] << 8) | tmp[5];
   \                     ??CrossCallReturnLabel_45:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine28 & 0xFFFF
   1094          //    if (timestamp)
   1095          //        get_ms(timestamp);
   1096              return 0;
   \                     ??CrossCallReturnLabel_29:
   \   000056   80..         SJMP    ?Subroutine8
   1097          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E9           MOV     A,R1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   7402         MOV     A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E9           MOV     A,R1
   \   000008   F0           MOVX    @DPTR,A
   \   000009   7404         MOV     A,#0x4
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   E9           MOV     A,R1
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   7A00         MOV     R2,#0x0
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   7401         MOV     A,#0x1
   \   00000A   22           RET
   1098          
   1099          /**
   1100           *  @brief      Read raw accel data directly from the registers.
   1101           *  @param[out] data        Raw data in hardware units.
   1102           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1103           *  @return     0 if successful.
   1104           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1105          int mpu_get_accel_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_accel_reg:
   1106          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1107              unsigned char tmp[6];
   1108          
   1109              if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   A2E3         MOV     C,0xE0 /* A   */.3
   \   000014   4006         JC      ??mpu_get_accel_reg_0
   1110                  return -1;
   \                     ??mpu_get_accel_reg_1:
   \   000016   7AFF         MOV     R2,#-0x1
   \   000018   7BFF         MOV     R3,#-0x1
   \   00001A   803A         SJMP    ??CrossCallReturnLabel_30
   1111          
   1112              if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
   \                     ??mpu_get_accel_reg_0:
   \   00001C                ; Setup parameters for call to function I2C_Read
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   7B06         MOV     R3,#0x6
   \   000028   90....       MOV     DPTR,#st
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   240D         ADD     A,#0xd
   \   00002E   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000031   70E3         JNZ     ??mpu_get_accel_reg_1
   1113                  return -1;
   1114              data[0] = (tmp[0] << 8) | tmp[1];
   \   000033   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine46 & 0xFFFF
   1115              data[1] = (tmp[2] << 8) | tmp[3];
   \                     ??CrossCallReturnLabel_62:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine39 & 0xFFFF
   1116              data[2] = (tmp[4] << 8) | tmp[5];
   \                     ??CrossCallReturnLabel_46:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine28 & 0xFFFF
   1117              if (timestamp)
   1118                  get_ms(timestamp);
   1119              return 0;
   \                     ??CrossCallReturnLabel_30:
   \   000056                REQUIRE ?Subroutine8
   \   000056                ; // Fall through to label ?Subroutine8
   1120          }
   1121          
   1122          /**
   1123           *  @brief      Read temperature data directly from the registers.
   1124           *  @param[out] data        Data in q16 format.
   1125           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1126           *  @return     0 if successful.
   1127           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine105_0
   \   000002                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1128          int mpu_get_temperature(long *data, unsigned long *timestamp)
   \                     mpu_get_temperature:
   1129          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1130              unsigned char tmp[2];
   1131              short raw;
   1132          
   1133              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_get_temperature_0
   1134                  return -1;
   \                     ??mpu_get_temperature_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_get_temperature_2 & 0xFFFF
   1135          
   1136              if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
   \                     ??mpu_get_temperature_0:
   \   00001B                ; Setup parameters for call to function I2C_Read
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   AC82         MOV     R4,DPL
   \   000023   AD83         MOV     R5,DPH
   \   000025   7B02         MOV     R3,#0x2
   \   000027   90....       MOV     DPTR,#st
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   240E         ADD     A,#0xe
   \   00002D   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000030   70E2         JNZ     ??mpu_get_temperature_1
   1137                  return -1;
   1138              raw = (tmp[0] << 8) | tmp[1];
   1139              if (timestamp)
   1140                  get_ms(timestamp);
   1141          
   1142              data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
   \   000032   90....       MOV     DPTR,#st + 2
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F8           MOV     R0,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   E8           MOV     A,R0
   \   00003B   FA           MOV     R2,A
   \   00003C   E9           MOV     A,R1
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F5..         MOV     ?V0 + 0,A
   \   000047   E9           MOV     A,R1
   \   000048   F5..         MOV     ?V0 + 1,A
   \   00004A   33           RLC     A
   \   00004B   95E0         SUBB    A,0xE0 /* A   */
   \   00004D   F5..         MOV     ?V0 + 2,A
   \   00004F   F5..         MOV     ?V0 + 3,A
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?L_TO_FLT
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000063   78..         MOV     R0,#?V0 + 4
   \   000065   12....       LCALL   ?L_TO_FLT
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   79..         MOV     R1,#?V0 + 4
   \   00006C   12....       LCALL   ?FLT_SUB
   \   00006F   8A82         MOV     DPL,R2
   \   000071   8B83         MOV     DPH,R3
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   00007A   E4           CLR     A
   \   00007B   F5..         MOV     ?V0 + 6,A
   \   00007D   F5..         MOV     ?V0 + 7,A
   \   00007F   78..         MOV     R0,#?V0 + 4
   \   000081   12....       LCALL   ?UL_TO_FLT
   \   000084   78..         MOV     R0,#?V0 + 0
   \   000086   79..         MOV     R1,#?V0 + 4
   \   000088   12....       LCALL   ?FLT_DIV
   \   00008B   90....       MOV     DPTR,#__Constant_420c0000
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   12....       LCALL   ?L_MOV_X
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   79..         MOV     R1,#?V0 + 4
   \   000097   12....       LCALL   ?FLT_ADD
   \   00009A   90....       MOV     DPTR,#__Constant_47800000
   \   00009D   78..         MOV     R0,#?V0 + 4
   \   00009F   12....       LCALL   ?L_MOV_X
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   79..         MOV     R1,#?V0 + 4
   \   0000A6   12....       LCALL   ?FLT_MUL
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?FLT_TO_L
   \   0000AE   8E82         MOV     DPL,R6
   \   0000B0   8F83         MOV     DPH,R7
   \   0000B2   78..         MOV     R0,#?V0 + 0
   \   0000B4   12....       LCALL   ?L_MOV_TO_X
   1143              return 0;
   \   0000B7   7A00         MOV     R2,#0x0
   \   0000B9   7B00         MOV     R3,#0x0
   \                     ??mpu_get_temperature_2:
   \   0000BB   02....       LJMP    ?Subroutine0 & 0xFFFF
   1144          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000003   33           RLC     A
   \   000004   95E0         SUBB    A,0xE0 /* A   */
   \   000006   F5..         MOV     ?V0 + 6,A
   \   000008   F5..         MOV     ?V0 + 7,A
   \   00000A   22           RET
   1145          
   1146          /**
   1147           *  @brief      Push biases to the accel bias registers.
   1148           *  This function expects biases relative to the current sensor output, and
   1149           *  these biases will be added to the factory-supplied values.
   1150           *  @param[in]  accel_bias  New biases.
   1151           *  @return     0 if successful.
   1152           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1153          int mpu_set_accel_bias(const long *accel_bias)
   \                     mpu_set_accel_bias:
   1154          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1155              unsigned char data[6];
   1156              short accel_hw[3];
   1157              short got_accel[3];
   1158              short fg[3];
   1159          
   1160              if (!accel_bias)
   \   00000E   EE           MOV     A,R6
   \   00000F   4F           ORL     A,R7
   \   000010   700E         JNZ     ??mpu_set_accel_bias_0
   1161                  return -1;
   \                     ??mpu_set_accel_bias_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \                     ??mpu_set_accel_bias_2:
   \   000016   7418         MOV     A,#0x18
   \   000018   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001B   7F0C         MOV     R7,#0xc
   \   00001D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1162              if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
   \                     ??mpu_set_accel_bias_0:
   \   000020   EE           MOV     A,R6
   \   000021   2408         ADD     A,#0x8
   \   000023   F5..         MOV     ?V0 + 2,A
   \   000025   EF           MOV     A,R7
   \   000026   3400         ADDC    A,#0x0
   \   000028   F5..         MOV     ?V0 + 3,A
   \   00002A   EE           MOV     A,R6
   \   00002B   2404         ADD     A,#0x4
   \   00002D   F5..         MOV     ?V0 + 0,A
   \   00002F   EF           MOV     A,R7
   \   000030   3400         ADDC    A,#0x0
   \   000032   F5..         MOV     ?V0 + 1,A
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   78..         MOV     R0,#?V0 + 4
   \   00003A   12....       LCALL   ?L_MOV_X
   \   00003D   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000040   7026         JNZ     ??mpu_set_accel_bias_3
   \   000042   85..82       MOV     DPL,?V0 + 0
   \   000045   85..83       MOV     DPH,?V0 + 1
   \   000048   78..         MOV     R0,#?V0 + 4
   \   00004A   12....       LCALL   ?L_MOV_X
   \   00004D   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000050   7016         JNZ     ??mpu_set_accel_bias_3
   \   000052   85..82       MOV     DPL,?V0 + 2
   \   000055   85..83       MOV     DPH,?V0 + 3
   \   000058   78..         MOV     R0,#?V0 + 4
   \   00005A   12....       LCALL   ?L_MOV_X
   \   00005D   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000060   7006         JNZ     ??mpu_set_accel_bias_3
   1163                  return 0;
   \                     ??mpu_set_accel_bias_4:
   \   000062   7A00         MOV     R2,#0x0
   \   000064   7B00         MOV     R3,#0x0
   \   000066   80AE         SJMP    ??mpu_set_accel_bias_2
   1164          
   1165              if (i2c_read(st.hw->addr, 3, 3, data))
   \                     ??mpu_set_accel_bias_3:
   \   000068                ; Setup parameters for call to function I2C_Read
   \   000068   85..82       MOV     DPL,?XSP + 0
   \   00006B   85..83       MOV     DPH,?XSP + 1
   \   00006E   AC82         MOV     R4,DPL
   \   000070   AD83         MOV     R5,DPH
   \   000072   7B03         MOV     R3,#0x3
   \   000074   7A03         MOV     R2,#0x3
   \   000076   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000079   8B..         MOV     ?V0 + 5,R3
   \   00007B   EA           MOV     A,R2
   \   00007C   45..         ORL     A,?V0 + 5
   \   00007E   7092         JNZ     ??mpu_set_accel_bias_1
   1166                  return -1;
   1167              fg[0] = ((data[0] >> 4) + 8) & 0xf;
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000089   F8           MOV     R0,A
   \   00008A   740C         MOV     A,#0xc
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   E8           MOV     A,R0
   \   000090   F0           MOVX    @DPTR,A
   \   000091   A3           INC     DPTR
   \   000092   E4           CLR     A
   \   000093   F0           MOVX    @DPTR,A
   1168              fg[1] = ((data[1] >> 4) + 8) & 0xf;
   \   000094   04           INC     A
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   00009B   FA           MOV     R2,A
   \   00009C   740E         MOV     A,#0xe
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   EA           MOV     A,R2
   \   0000A2   F0           MOVX    @DPTR,A
   \   0000A3   A3           INC     DPTR
   \   0000A4   E4           CLR     A
   \   0000A5   F0           MOVX    @DPTR,A
   1169              fg[2] = ((data[2] >> 4) + 8) & 0xf;
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0000AE   FC           MOV     R4,A
   \   0000AF   7410         MOV     A,#0x10
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   EC           MOV     A,R4
   \   0000B5   F0           MOVX    @DPTR,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E4           CLR     A
   \   0000B8   F0           MOVX    @DPTR,A
   1170          
   1171              accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
   \   0000B9   8E82         MOV     DPL,R6
   \   0000BB   8F83         MOV     DPH,R7
   \   0000BD   78..         MOV     R0,#?V0 + 8
   \   0000BF   12....       LCALL   ?L_MOV_X
   \   0000C2   7401         MOV     A,#0x1
   \   0000C4   78..         MOV     R0,#?V0 + 8
   \   0000C6   12....       LCALL   ?L_SHL
   \   0000C9   740C         MOV     A,#0xc
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   2440         ADD     A,#0x40
   \   0000D1   F5..         MOV     ?V0 + 4,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   3400         ADDC    A,#0x0
   \   0000D7   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   0000DA   78..         MOV     R0,#?V0 + 8
   \   0000DC   79..         MOV     R1,#?V0 + 4
   \   0000DE   12....       LCALL   ?L_DIV_MOD
   \   0000E1   7406         MOV     A,#0x6
   \   0000E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E6   E5..         MOV     A,?V0 + 8
   \   0000E8   F0           MOVX    @DPTR,A
   \   0000E9   A3           INC     DPTR
   \   0000EA   E5..         MOV     A,?V0 + 9
   \   0000EC   F0           MOVX    @DPTR,A
   1172              accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
   \   0000ED   85..82       MOV     DPL,?V0 + 0
   \   0000F0   85..83       MOV     DPH,?V0 + 1
   \   0000F3   78..         MOV     R0,#?V0 + 4
   \   0000F5   12....       LCALL   ?L_MOV_X
   \   0000F8   7401         MOV     A,#0x1
   \   0000FA   78..         MOV     R0,#?V0 + 4
   \   0000FC   12....       LCALL   ?L_SHL
   \   0000FF   EA           MOV     A,R2
   \   000100   2440         ADD     A,#0x40
   \   000102   F5..         MOV     ?V0 + 8,A
   \   000104   E4           CLR     A
   \   000105   F5..         MOV     ?V0 + 9,A
   \   000107   F5..         MOV     ?V0 + 10,A
   \   000109   F5..         MOV     ?V0 + 11,A
   \   00010B   78..         MOV     R0,#?V0 + 4
   \   00010D   79..         MOV     R1,#?V0 + 8
   \   00010F   12....       LCALL   ?L_DIV_MOD
   \   000112   7408         MOV     A,#0x8
   \   000114   12....       LCALL   ?XSTACK_DISP0_8
   \   000117   E5..         MOV     A,?V0 + 4
   \   000119   F0           MOVX    @DPTR,A
   \   00011A   A3           INC     DPTR
   \   00011B   E5..         MOV     A,?V0 + 5
   \   00011D   F0           MOVX    @DPTR,A
   1173              accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
   \   00011E   85..82       MOV     DPL,?V0 + 2
   \   000121   85..83       MOV     DPH,?V0 + 3
   \   000124   78..         MOV     R0,#?V0 + 0
   \   000126   12....       LCALL   ?L_MOV_X
   \   000129   7401         MOV     A,#0x1
   \   00012B   78..         MOV     R0,#?V0 + 0
   \   00012D   12....       LCALL   ?L_SHL
   \   000130   EC           MOV     A,R4
   \   000131   2440         ADD     A,#0x40
   \   000133   F5..         MOV     ?V0 + 4,A
   \   000135   E4           CLR     A
   \   000136   F5..         MOV     ?V0 + 5,A
   \   000138   F5..         MOV     ?V0 + 6,A
   \   00013A   F5..         MOV     ?V0 + 7,A
   \   00013C   78..         MOV     R0,#?V0 + 0
   \   00013E   79..         MOV     R1,#?V0 + 4
   \   000140   12....       LCALL   ?L_DIV_MOD
   \   000143   740A         MOV     A,#0xa
   \   000145   12....       LCALL   ?XSTACK_DISP0_8
   \   000148   E5..         MOV     A,?V0 + 0
   \   00014A   F0           MOVX    @DPTR,A
   \   00014B   A3           INC     DPTR
   \   00014C   E5..         MOV     A,?V0 + 1
   \   00014E   12....       LCALL   ?Subroutine62 & 0xFFFF
   1174          
   1175              if (i2c_read(st.hw->addr, 0x06, 6, data))
   \                     ??CrossCallReturnLabel_96:
   \   000151   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000154   6003         JZ      $+5
   \   000156   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   1176                  return -1;
   1177          
   1178              got_accel[0] = ((short)data[0] << 8) | data[1];
   \   000159   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00015C   12....       LCALL   ?XSTACK_DISP0_8
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   F8           MOV     R0,A
   \   000161   7412         MOV     A,#0x12
   \   000163   12....       LCALL   ?XSTACK_DISP0_8
   \   000166   12....       LCALL   ?Subroutine66 & 0xFFFF
   1179              got_accel[1] = ((short)data[2] << 8) | data[3];
   \                     ??CrossCallReturnLabel_159:
   \   000169   7402         MOV     A,#0x2
   \   00016B   12....       LCALL   ?XSTACK_DISP0_8
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   F9           MOV     R1,A
   \   000170   7403         MOV     A,#0x3
   \   000172   12....       LCALL   ?XSTACK_DISP0_8
   \   000175   E0           MOVX    A,@DPTR
   \   000176   FA           MOV     R2,A
   \   000177   E9           MOV     A,R1
   \   000178   FB           MOV     R3,A
   \   000179   7414         MOV     A,#0x14
   \   00017B   12....       LCALL   ?XSTACK_DISP0_8
   \   00017E   EA           MOV     A,R2
   \   00017F   F0           MOVX    @DPTR,A
   \   000180   A3           INC     DPTR
   \   000181   EB           MOV     A,R3
   \   000182   F0           MOVX    @DPTR,A
   1180              got_accel[2] = ((short)data[4] << 8) | data[5];
   \   000183   7404         MOV     A,#0x4
   \   000185   12....       LCALL   ?XSTACK_DISP0_8
   \   000188   E0           MOVX    A,@DPTR
   \   000189   F9           MOV     R1,A
   \   00018A   7405         MOV     A,#0x5
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   E0           MOVX    A,@DPTR
   \   000190   F8           MOV     R0,A
   \   000191   7416         MOV     A,#0x16
   \   000193   12....       LCALL   ?XSTACK_DISP0_8
   \   000196   12....       LCALL   ?Subroutine66 & 0xFFFF
   1181          
   1182              accel_hw[0] += got_accel[0];
   \                     ??CrossCallReturnLabel_160:
   \   000199   7412         MOV     A,#0x12
   \   00019B   12....       LCALL   ?XSTACK_DISP0_8
   \   00019E   E0           MOVX    A,@DPTR
   \   00019F   FC           MOV     R4,A
   \   0001A0   A3           INC     DPTR
   \   0001A1   E0           MOVX    A,@DPTR
   \   0001A2   FD           MOV     R5,A
   \   0001A3   7406         MOV     A,#0x6
   \   0001A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A8   E0           MOVX    A,@DPTR
   \   0001A9   2C           ADD     A,R4
   \   0001AA   F0           MOVX    @DPTR,A
   \   0001AB   A3           INC     DPTR
   \   0001AC   E0           MOVX    A,@DPTR
   \   0001AD   3D           ADDC    A,R5
   \   0001AE   F0           MOVX    @DPTR,A
   1183              accel_hw[1] += got_accel[1];
   \   0001AF   7408         MOV     A,#0x8
   \   0001B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   2A           ADD     A,R2
   \   0001B6   F0           MOVX    @DPTR,A
   \   0001B7   A3           INC     DPTR
   \   0001B8   E0           MOVX    A,@DPTR
   \   0001B9   3B           ADDC    A,R3
   \   0001BA   F0           MOVX    @DPTR,A
   1184              accel_hw[2] += got_accel[2];
   \   0001BB   740A         MOV     A,#0xa
   \   0001BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C0   E0           MOVX    A,@DPTR
   \   0001C1   28           ADD     A,R0
   \   0001C2   F0           MOVX    @DPTR,A
   \   0001C3   A3           INC     DPTR
   \   0001C4   E0           MOVX    A,@DPTR
   \   0001C5   39           ADDC    A,R1
   \   0001C6   F0           MOVX    @DPTR,A
   1185          
   1186              data[0] = (accel_hw[0] >> 8) & 0xff;
   \   0001C7   7406         MOV     A,#0x6
   \   0001C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CC   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0001CF   7408         MOV     A,#0x8
   \   0001D1   78..         MOV     R0,#?V0 + 0
   \   0001D3   12....       LCALL   ?SS_SHR
   \   0001D6   85..82       MOV     DPL,?XSP + 0
   \   0001D9   85..83       MOV     DPH,?XSP + 1
   \   0001DC   E5..         MOV     A,?V0 + 0
   \   0001DE   F0           MOVX    @DPTR,A
   1187              data[1] = (accel_hw[0]) & 0xff;
   \   0001DF   7406         MOV     A,#0x6
   \   0001E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E4   E0           MOVX    A,@DPTR
   \   0001E5   C0E0         PUSH    A
   \   0001E7   7401         MOV     A,#0x1
   \   0001E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EC   D0E0         POP     A
   \   0001EE   F0           MOVX    @DPTR,A
   1188              data[2] = (accel_hw[1] >> 8) & 0xff;
   \   0001EF   7408         MOV     A,#0x8
   \   0001F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F4   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0001F7   12....       LCALL   ?SS_SHR
   \   0001FA   7402         MOV     A,#0x2
   \   0001FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FF   E5..         MOV     A,?V0 + 0
   \   000201   F0           MOVX    @DPTR,A
   1189              data[3] = (accel_hw[1]) & 0xff;
   \   000202   7403         MOV     A,#0x3
   \   000204   12....       LCALL   ?XSTACK_DISP0_8
   \   000207   EA           MOV     A,R2
   \   000208   F0           MOVX    @DPTR,A
   1190              data[4] = (accel_hw[2] >> 8) & 0xff;
   \   000209   740A         MOV     A,#0xa
   \   00020B   12....       LCALL   ?XSTACK_DISP0_8
   \   00020E   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000211   12....       LCALL   ?SS_SHR
   \   000214   7404         MOV     A,#0x4
   \   000216   12....       LCALL   ?XSTACK_DISP0_8
   \   000219   E5..         MOV     A,?V0 + 0
   \   00021B   F0           MOVX    @DPTR,A
   1191              data[5] = (accel_hw[2]) & 0xff;
   \   00021C   7405         MOV     A,#0x5
   \   00021E   12....       LCALL   ?XSTACK_DISP0_8
   \   000221   EA           MOV     A,R2
   \   000222   12....       LCALL   ?Subroutine62 & 0xFFFF
   1192          
   1193              if (i2c_write(st.hw->addr, 0x06, 6, data))
   \                     ??CrossCallReturnLabel_97:
   \   000225   90....       MOV     DPTR,#st + 2
   \   000228   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   00022B   E0           MOVX    A,@DPTR
   \   00022C   F9           MOV     R1,A
   \   00022D   12....       LCALL   ??I2C_Write?relay
   \   000230   8B..         MOV     ?V0 + 1,R3
   \   000232   EA           MOV     A,R2
   \   000233   45..         ORL     A,?V0 + 1
   \   000235   6003         JZ      $+5
   \   000237   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   \   00023A   02....       LJMP    ??mpu_set_accel_bias_4 & 0xFFFF
   1194                  return -1;
   1195              return 0;
   1196          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E5..         MOV     A,?V0 + 4
   \   000002   45..         ORL     A,?V0 + 5
   \   000004   45..         ORL     A,?V0 + 6
   \   000006   45..         ORL     A,?V0 + 7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine107_0
   \   000001                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000003   7B06         MOV     R3,#0x6
   \   000005   7A06         MOV     R2,#0x6
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   7408         MOV     A,#0x8
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C4           SWAP    A
   \   000002   540F         ANL     A,#0xf
   \   000004   2408         ADD     A,#0x8
   \   000006   540F         ANL     A,#0xf
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   F5..         MOV     ?V0 + 5,A
   \   000002   33           RLC     A
   \   000003   95E0         SUBB    A,0xE0 /* A   */
   \   000005   F5..         MOV     ?V0 + 6,A
   \   000007   F5..         MOV     ?V0 + 7,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000003   AC82         MOV     R4,DPL
   \   000005   AD83         MOV     R5,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
   1197          
   1198          /**
   1199           *  @brief  Reset FIFO read/write pointers.
   1200           *  @return 0 if successful.
   1201           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1202          int mpu_reset_fifo(void)
   \                     mpu_reset_fifo:
   1203          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1204              unsigned char data;
   1205          
   1206              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7007         JNZ     ??mpu_reset_fifo_0
   1207                  return -1;
   \                     ??mpu_reset_fifo_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   02....       LJMP    ??mpu_reset_fifo_2 & 0xFFFF
   1208          
   1209              data = 0;
   \                     ??mpu_reset_fifo_0:
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   12....       LCALL   ?Subroutine58 & 0xFFFF
   1210              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_255:
   \   000020   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000023   70EB         JNZ     ??mpu_reset_fifo_1
   1211                  return -1;
   1212              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   \   000025                ; Setup parameters for call to function I2C_Write
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   00002E   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000031   70DD         JNZ     ??mpu_reset_fifo_1
   1213                  return -1;
   1214              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   000033                ; Setup parameters for call to function I2C_Write
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   00003C   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   00003F   70CF         JNZ     ??mpu_reset_fifo_1
   1215                  return -1;
   1216          
   1217              if (st.chip_cfg.dmp_on) {
   \   000041   90....       MOV     DPTR,#st + 29
   \   000044   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000047   6054         JZ      ??mpu_reset_fifo_3
   1218                  data = BIT_FIFO_RST | BIT_DMP_RST;
   \   000049   12....       LCALL   ?Subroutine34 & 0xFFFF
   1219                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_165:
   \   00004C   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   00004F   70BF         JNZ     ??mpu_reset_fifo_1
   1220                      return -1;
   1221                  delay_ms(50);
   \   000051                ; Setup parameters for call to function delay_ms
   \   000051   7A32         MOV     R2,#0x32
   \   000053   12....       LCALL   ?Subroutine67 & 0xFFFF
   1222                  data = BIT_DMP_EN | BIT_FIFO_EN;
   \                     ??CrossCallReturnLabel_104:
   \   000056   74C0         MOV     A,#-0x40
   \   000058   F0           MOVX    @DPTR,A
   1223                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   000059   90....       MOV     DPTR,#st + 6
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005F   5009         JNC     ??mpu_reset_fifo_4
   1224                      data |= BIT_AUX_IF_EN;
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   74E0         MOV     A,#-0x20
   \   000069   F0           MOVX    @DPTR,A
   1225                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??mpu_reset_fifo_4:
   \   00006A                ; Setup parameters for call to function I2C_Write
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000073   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000076   7098         JNZ     ??mpu_reset_fifo_1
   1226                      return -1;
   1227                  if (st.chip_cfg.int_enable)
   \   000078   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   00007B   6004         JZ      ??mpu_reset_fifo_5
   1228                      data = BIT_DMP_INT_EN;
   \   00007D   7402         MOV     A,#0x2
   \   00007F   8001         SJMP    ??mpu_reset_fifo_6
   1229                  else
   1230                      data = 0;
   \                     ??mpu_reset_fifo_5:
   \   000081   E4           CLR     A
   \                     ??mpu_reset_fifo_6:
   \   000082   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   1231                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_259:
   \   000085   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000088   7086         JNZ     ??mpu_reset_fifo_1
   1232                      return -1;
   1233                  data = 0;
   \   00008A   85..82       MOV     DPL,?XSP + 0
   \   00008D   85..83       MOV     DPH,?XSP + 1
   \   000090   12....       LCALL   ?Subroutine33 & 0xFFFF
   1234                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   1235                      return -1;
   1236              } else {
   \                     ??CrossCallReturnLabel_206:
   \   000093   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000096   6003         JZ      $+5
   \   000098   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   \   00009B   8063         SJMP    ??mpu_reset_fifo_7
   1237                  data = BIT_FIFO_RST;
   \                     ??mpu_reset_fifo_3:
   \   00009D   7404         MOV     A,#0x4
   \   00009F   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   1238                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_167:
   \   0000A2   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   0000A5   6003         JZ      $+5
   \   0000A7   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1239                      return -1;
   1240                  if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   \   0000AA   90....       MOV     DPTR,#st + 13
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   7008         JNZ     ??mpu_reset_fifo_8
   \   0000B0   90....       MOV     DPTR,#st + 6
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B6   400A         JC      ??mpu_reset_fifo_9
   1241                      data = BIT_FIFO_EN;
   \                     ??mpu_reset_fifo_8:
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   7440         MOV     A,#0x40
   \   0000C0   8008         SJMP    ??mpu_reset_fifo_10
   1242                  else
   1243                      data = BIT_FIFO_EN | BIT_AUX_IF_EN;
   \                     ??mpu_reset_fifo_9:
   \   0000C2   85..82       MOV     DPL,?XSP + 0
   \   0000C5   85..83       MOV     DPH,?XSP + 1
   \   0000C8   7460         MOV     A,#0x60
   \                     ??mpu_reset_fifo_10:
   \   0000CA   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   1244                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_168:
   \   0000CD   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   0000D0   6003         JZ      $+5
   \   0000D2   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1245                      return -1;
   1246                  delay_ms(50);
   \   0000D5                ; Setup parameters for call to function delay_ms
   \   0000D5   7A32         MOV     R2,#0x32
   \   0000D7   7B00         MOV     R3,#0x0
   \   0000D9   12....       LCALL   ??delay_ms?relay
   1247                  if (st.chip_cfg.int_enable)
   \   0000DC   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   0000DF   6004         JZ      ??mpu_reset_fifo_11
   1248                      data = BIT_DATA_RDY_EN;
   \   0000E1   7401         MOV     A,#0x1
   \   0000E3   8001         SJMP    ??mpu_reset_fifo_12
   1249                  else
   1250                      data = 0;
   \                     ??mpu_reset_fifo_11:
   \   0000E5   E4           CLR     A
   \                     ??mpu_reset_fifo_12:
   \   0000E6   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   1251                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_260:
   \   0000E9   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   0000EC   6003         JZ      $+5
   \   0000EE   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1252                      return -1;
   1253                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
   \   0000F1                ; Setup parameters for call to function I2C_Write
   \   0000F1   7C..         MOV     R4,#(st + 11) & 0xff
   \   0000F3   7D..         MOV     R5,#((st + 11) >> 8) & 0xff
   \   0000F5   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   1254                      return -1;
   1255              }
   \                     ??CrossCallReturnLabel_209:
   \   0000F8   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   0000FB   6003         JZ      $+5
   \   0000FD   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1256              return 0;
   \                     ??mpu_reset_fifo_7:
   \   000100   7A00         MOV     R2,#0x0
   \   000102   7B00         MOV     R3,#0x0
   \                     ??mpu_reset_fifo_2:
   \   000104   02....       LJMP    ?Subroutine3 & 0xFFFF
   1257          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   740C         MOV     A,#0xc
   \   000002                REQUIRE ??Subroutine108_0
   \   000002                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                REQUIRE ??Subroutine109_0
   \   000001                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006                REQUIRE ??Subroutine110_0
   \   000006                ; // Fall through to label ??Subroutine110_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   90....       MOV     DPTR,#st + 12
   \   000003                REQUIRE ??Subroutine117_0
   \   000003                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   E4           CLR     A
   \   000001                REQUIRE ??Subroutine121_0
   \   000001                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                REQUIRE ??Subroutine122_0
   \   000001                ; // Fall through to label ??Subroutine122_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004                REQUIRE ??Subroutine123_0
   \   000004                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   7B01         MOV     R3,#0x1
   \   000002   90....       MOV     DPTR,#st
   \   000005   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E4           CLR     A
   \   000001                REQUIRE ??Subroutine133_0
   \   000001                ; // Fall through to label ??Subroutine133_0
   1258          
   1259          /**
   1260           *  @brief      Get the gyro full-scale range.
   1261           *  @param[out] fsr Current full-scale range.
   1262           *  @return     0 if successful.
   1263           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1264          int mpu_get_gyro_fsr(unsigned short *fsr)
   \                     mpu_get_gyro_fsr:
   1265          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1266              switch (st.chip_cfg.gyro_fsr) {
   \   000004   90....       MOV     DPTR,#st + 4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_gyro_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6013         JZ      ??mpu_get_gyro_fsr_1
   \   00000D   14           DEC     A
   \   00000E   601C         JZ      ??mpu_get_gyro_fsr_2
   \   000010   14           DEC     A
   \   000011   6025         JZ      ??mpu_get_gyro_fsr_3
   \   000013   802F         SJMP    ??mpu_get_gyro_fsr_4
   1267              case INV_FSR_250DPS:
   1268                  fsr[0] = 250;
   \                     ??mpu_get_gyro_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   74FA         MOV     A,#-0x6
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   E4           CLR     A
   \   00001E   802B         SJMP    ??mpu_get_gyro_fsr_5
   1269                  break;
   1270              case INV_FSR_500DPS:
   1271                  fsr[0] = 500;
   \                     ??mpu_get_gyro_fsr_1:
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   74F4         MOV     A,#-0xc
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   7401         MOV     A,#0x1
   \   00002A   801F         SJMP    ??mpu_get_gyro_fsr_5
   1272                  break;
   1273              case INV_FSR_1000DPS:
   1274                  fsr[0] = 1000;
   \                     ??mpu_get_gyro_fsr_2:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   74E8         MOV     A,#-0x18
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7403         MOV     A,#0x3
   \   000036   8013         SJMP    ??mpu_get_gyro_fsr_5
   1275                  break;
   1276              case INV_FSR_2000DPS:
   1277                  fsr[0] = 2000;
   \                     ??mpu_get_gyro_fsr_3:
   \   000038   8A82         MOV     DPL,R2
   \   00003A   8B83         MOV     DPH,R3
   \   00003C   74D0         MOV     A,#-0x30
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   7407         MOV     A,#0x7
   \   000042   8007         SJMP    ??mpu_get_gyro_fsr_5
   1278                  break;
   1279              default:
   1280                  fsr[0] = 0;
   \                     ??mpu_get_gyro_fsr_4:
   \   000044   8A82         MOV     DPL,R2
   \   000046   8B83         MOV     DPH,R3
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   1281                  break;
   1282              }
   \                     ??mpu_get_gyro_fsr_5:
   \   00004B   02....       LJMP    ??Subroutine112_0 & 0xFFFF
   1283              return 0;
   1284          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7A00         MOV     R2,#0x0
   \   000003                REQUIRE ??Subroutine113_0
   \   000003                ; // Fall through to label ??Subroutine113_0
   1285          
   1286          /**
   1287           *  @brief      Set the gyro full-scale range.
   1288           *  @param[in]  fsr Desired full-scale range.
   1289           *  @return     0 if successful.
   1290           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1291          int mpu_set_gyro_fsr(unsigned short fsr)
   \                     mpu_set_gyro_fsr:
   1292          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1293              unsigned char data;
   1294          
   1295              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7006         JNZ     ??mpu_set_gyro_fsr_0
   1296                  return -1;
   \                     ??mpu_set_gyro_fsr_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   8060         SJMP    ??mpu_set_gyro_fsr_2
   1297          
   1298              switch (fsr) {
   \                     ??mpu_set_gyro_fsr_0:
   \   000016   8A..         MOV     ?V0 + 0,R2
   \   000018   8B..         MOV     ?V0 + 1,R3
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for mpu_set_gyro_fsr>_0`:
   \   00001F   0000         DW        0
   \   000021   0400         DW        4
   \   000023   FA00         DW        250
   \   000025   ....         DW        ??mpu_set_gyro_fsr_3
   \   000027   F401         DW        500
   \   000029   ....         DW        ??mpu_set_gyro_fsr_4
   \   00002B   E803         DW        1000
   \   00002D   ....         DW        ??mpu_set_gyro_fsr_5
   \   00002F   D007         DW        2000
   \   000031   ....         DW        ??mpu_set_gyro_fsr_6
   \   000033   ....         DW        ??mpu_set_gyro_fsr_1
   1299              case 250:
   1300                  data = INV_FSR_250DPS << 3;
   \                     ??mpu_set_gyro_fsr_3:
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   E4           CLR     A
   \   00003C   801C         SJMP    ??mpu_set_gyro_fsr_7
   1301                  break;
   1302              case 500:
   1303                  data = INV_FSR_500DPS << 3;
   \                     ??mpu_set_gyro_fsr_4:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   7408         MOV     A,#0x8
   \   000046   8012         SJMP    ??mpu_set_gyro_fsr_7
   1304                  break;
   1305              case 1000:
   1306                  data = INV_FSR_1000DPS << 3;
   \                     ??mpu_set_gyro_fsr_5:
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   7410         MOV     A,#0x10
   \   000050   8008         SJMP    ??mpu_set_gyro_fsr_7
   1307                  break;
   1308              case 2000:
   1309                  data = INV_FSR_2000DPS << 3;
   \                     ??mpu_set_gyro_fsr_6:
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   7418         MOV     A,#0x18
   \                     ??mpu_set_gyro_fsr_7:
   \   00005A   F0           MOVX    @DPTR,A
   1310                  break;
   1311              default:
   1312                  return -1;
   1313              }
   1314          
   1315              if (st.chip_cfg.gyro_fsr == (data >> 3))
   \   00005B   90....       MOV     DPTR,#st + 4
   \   00005E   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000061   600F         JZ      ??mpu_set_gyro_fsr_8
   1316                  return 0;
   1317              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
   \   000063                ; Setup parameters for call to function I2C_Write
   \   000063   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000066   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000069   70A5         JNZ     ??mpu_set_gyro_fsr_1
   1318                  return -1;
   1319              st.chip_cfg.gyro_fsr = data >> 3;
   \   00006B   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00006E   90....       MOV     DPTR,#st + 4
   \   000071   F0           MOVX    @DPTR,A
   1320              return 0;
   \                     ??mpu_set_gyro_fsr_8:
   \   000072   7A00         MOV     R2,#0x0
   \   000074   7B00         MOV     R3,#0x0
   \                     ??mpu_set_gyro_fsr_2:
   \   000076   02....       LJMP    ?Subroutine3 & 0xFFFF
   1321          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine111_0
   \   000006                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000003   A2E7         MOV     C,0xE0 /* A   */.7
   \   000005   13           RRC     A
   \   000006   A2E7         MOV     C,0xE0 /* A   */.7
   \   000008   13           RRC     A
   \   000009   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000B   13           RRC     A
   \   00000C   68           XRL     A,R0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1322          
   1323          /**
   1324           *  @brief      Get the accel full-scale range.
   1325           *  @param[out] fsr Current full-scale range.
   1326           *  @return     0 if successful.
   1327           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1328          int mpu_get_accel_fsr(unsigned char *fsr)
   \                     mpu_get_accel_fsr:
   1329          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1330              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6024         JZ      ??mpu_get_accel_fsr_1
   \   00000D   14           DEC     A
   \   00000E   6029         JZ      ??mpu_get_accel_fsr_2
   \   000010   14           DEC     A
   \   000011   602E         JZ      ??mpu_get_accel_fsr_3
   \   000013   8034         SJMP    ??mpu_get_accel_fsr_4
   1331              case INV_FSR_2G:
   1332                  fsr[0] = 2;
   \                     ??mpu_get_accel_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   7402         MOV     A,#0x2
   \                     ??mpu_get_accel_fsr_5:
   \   00001B   F0           MOVX    @DPTR,A
   1333                  break;
   1334              case INV_FSR_4G:
   1335                  fsr[0] = 4;
   1336                  break;
   1337              case INV_FSR_8G:
   1338                  fsr[0] = 8;
   1339                  break;
   1340              case INV_FSR_16G:
   1341                  fsr[0] = 16;
   1342                  break;
   1343              default:
   1344                  return -1;
   1345              }
   1346              if (st.chip_cfg.accel_half)
   \   00001C   90....       MOV     DPTR,#st + 14
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6008         JZ      ??mpu_get_accel_fsr_6
   1347                  fsr[0] <<= 1;
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   E0           MOVX    A,@DPTR
   \   000027   C3           CLR     C
   \   000028   33           RLC     A
   \   000029   F0           MOVX    @DPTR,A
   1348              return 0;
   \                     ??mpu_get_accel_fsr_6:
   \   00002A   7A00         MOV     R2,#0x0
   \   00002C   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_fsr_7:
   \   00002E   02....       LJMP    ??Subroutine114_0 & 0xFFFF
   \                     ??mpu_get_accel_fsr_1:
   \   000031   8A82         MOV     DPL,R2
   \   000033   8B83         MOV     DPH,R3
   \   000035   7404         MOV     A,#0x4
   \   000037   80E2         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_2:
   \   000039   8A82         MOV     DPL,R2
   \   00003B   8B83         MOV     DPH,R3
   \   00003D   7408         MOV     A,#0x8
   \   00003F   80DA         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_3:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   7410         MOV     A,#0x10
   \   000047   80D2         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_4:
   \   000049   7AFF         MOV     R2,#-0x1
   \   00004B   7BFF         MOV     R3,#-0x1
   \   00004D   80DF         SJMP    ??mpu_get_accel_fsr_7
   1349          }
   1350          
   1351          /**
   1352           *  @brief      Set the accel full-scale range.
   1353           *  @param[in]  fsr Desired full-scale range.
   1354           *  @return     0 if successful.
   1355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1356          int mpu_set_accel_fsr(unsigned char fsr)
   \                     mpu_set_accel_fsr:
   1357          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1358              unsigned char data;
   1359          
   1360              if (!(st.chip_cfg.sensors))
   \   00000C   90....       MOV     DPTR,#st + 6
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   7006         JNZ     ??mpu_set_accel_fsr_0
   1361                  return -1;
   \                     ??mpu_set_accel_fsr_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \   000016   8054         SJMP    ??mpu_set_accel_fsr_2
   1362          
   1363              switch (fsr) {
   \                     ??mpu_set_accel_fsr_0:
   \   000018   EE           MOV     A,R6
   \   000019   24FE         ADD     A,#-0x2
   \   00001B   600E         JZ      ??mpu_set_accel_fsr_3
   \   00001D   24FE         ADD     A,#-0x2
   \   00001F   6013         JZ      ??mpu_set_accel_fsr_4
   \   000021   24FC         ADD     A,#-0x4
   \   000023   6019         JZ      ??mpu_set_accel_fsr_5
   \   000025   24F8         ADD     A,#-0x8
   \   000027   601F         JZ      ??mpu_set_accel_fsr_6
   \   000029   80E7         SJMP    ??mpu_set_accel_fsr_1
   1364              case 2:
   1365                  data = INV_FSR_2G << 3;
   \                     ??mpu_set_accel_fsr_3:
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   E4           CLR     A
   \   000032   801C         SJMP    ??mpu_set_accel_fsr_7
   1366                  break;
   1367              case 4:
   1368                  data = INV_FSR_4G << 3;
   \                     ??mpu_set_accel_fsr_4:
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   7408         MOV     A,#0x8
   \   00003C   8012         SJMP    ??mpu_set_accel_fsr_7
   1369                  break;
   1370              case 8:
   1371                  data = INV_FSR_8G << 3;
   \                     ??mpu_set_accel_fsr_5:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   7410         MOV     A,#0x10
   \   000046   8008         SJMP    ??mpu_set_accel_fsr_7
   1372                  break;
   1373              case 16:
   1374                  data = INV_FSR_16G << 3;
   \                     ??mpu_set_accel_fsr_6:
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   7418         MOV     A,#0x18
   \                     ??mpu_set_accel_fsr_7:
   \   000050   F0           MOVX    @DPTR,A
   1375                  break;
   1376              default:
   1377                  return -1;
   1378              }
   1379          
   1380              if (st.chip_cfg.accel_fsr == (data >> 3))
   \   000051   90....       MOV     DPTR,#st + 5
   \   000054   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000057   600F         JZ      ??mpu_set_accel_fsr_8
   1381                  return 0;
   1382              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
   \   000059                ; Setup parameters for call to function I2C_Write
   \   000059   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   00005C   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   00005F   70B1         JNZ     ??mpu_set_accel_fsr_1
   1383                  return -1;
   1384              st.chip_cfg.accel_fsr = data >> 3;
   \   000061   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000064   90....       MOV     DPTR,#st + 5
   \   000067   F0           MOVX    @DPTR,A
   1385              return 0;
   \                     ??mpu_set_accel_fsr_8:
   \   000068   7A00         MOV     R2,#0x0
   \   00006A   7B00         MOV     R3,#0x0
   \                     ??mpu_set_accel_fsr_2:
   \   00006C   02....       LJMP    ?Subroutine3 & 0xFFFF
   1386          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   90....       MOV     DPTR,#st
   \   000009   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET
   1387          
   1388          /**
   1389           *  @brief      Get the current DLPF setting.
   1390           *  @param[out] lpf Current LPF setting.
   1391           *  0 if successful.
   1392           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1393          int mpu_get_lpf(unsigned short *lpf)
   \                     mpu_get_lpf:
   1394          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1395              switch (st.chip_cfg.lpf) {
   \   000004   90....       MOV     DPTR,#st + 7
   \   000007   E0           MOVX    A,@DPTR
   \   000008   14           DEC     A
   \   000009   6011         JZ      ??mpu_get_lpf_0
   \   00000B   14           DEC     A
   \   00000C   6019         JZ      ??mpu_get_lpf_1
   \   00000E   14           DEC     A
   \   00000F   601E         JZ      ??mpu_get_lpf_2
   \   000011   14           DEC     A
   \   000012   6023         JZ      ??mpu_get_lpf_3
   \   000014   14           DEC     A
   \   000015   6028         JZ      ??mpu_get_lpf_4
   \   000017   14           DEC     A
   \   000018   602D         JZ      ??mpu_get_lpf_5
   \   00001A   8033         SJMP    ??mpu_get_lpf_6
   1396              case INV_FILTER_188HZ:
   1397                  lpf[0] = 188;
   \                     ??mpu_get_lpf_0:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   74BC         MOV     A,#-0x44
   \                     ??mpu_get_lpf_7:
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E4           CLR     A
   \   000025   802F         SJMP    ??mpu_get_lpf_8
   1398                  break;
   1399              case INV_FILTER_98HZ:
   1400                  lpf[0] = 98;
   \                     ??mpu_get_lpf_1:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   7462         MOV     A,#0x62
   \   00002D   80F3         SJMP    ??mpu_get_lpf_7
   1401                  break;
   1402              case INV_FILTER_42HZ:
   1403                  lpf[0] = 42;
   \                     ??mpu_get_lpf_2:
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   742A         MOV     A,#0x2a
   \   000035   80EB         SJMP    ??mpu_get_lpf_7
   1404                  break;
   1405              case INV_FILTER_20HZ:
   1406                  lpf[0] = 20;
   \                     ??mpu_get_lpf_3:
   \   000037   8A82         MOV     DPL,R2
   \   000039   8B83         MOV     DPH,R3
   \   00003B   7414         MOV     A,#0x14
   \   00003D   80E3         SJMP    ??mpu_get_lpf_7
   1407                  break;
   1408              case INV_FILTER_10HZ:
   1409                  lpf[0] = 10;
   \                     ??mpu_get_lpf_4:
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   740A         MOV     A,#0xa
   \   000045   80DB         SJMP    ??mpu_get_lpf_7
   1410                  break;
   1411              case INV_FILTER_5HZ:
   1412                  lpf[0] = 5;
   \                     ??mpu_get_lpf_5:
   \   000047   8A82         MOV     DPL,R2
   \   000049   8B83         MOV     DPH,R3
   \   00004B   7405         MOV     A,#0x5
   \   00004D   80D3         SJMP    ??mpu_get_lpf_7
   1413                  break;
   1414              case INV_FILTER_256HZ_NOLPF2:
   1415              case INV_FILTER_2100HZ_NOLPF:
   1416              default:
   1417                  lpf[0] = 0;
   \                     ??mpu_get_lpf_6:
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   1418                  break;
   1419              }
   \                     ??mpu_get_lpf_8:
   \   000056   02....       LJMP    ??Subroutine112_0 & 0xFFFF
   1420              return 0;
   1421          }
   1422          
   1423          /**
   1424           *  @brief      Set digital low pass filter.
   1425           *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
   1426           *  @param[in]  lpf Desired LPF setting.
   1427           *  @return     0 if successful.
   1428           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1429          int mpu_set_lpf(unsigned short lpf)
   \                     mpu_set_lpf:
   1430          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1431              unsigned char data;
   1432          
   1433              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7007         JNZ     ??mpu_set_lpf_0
   1434                  return -1;
   \                     ??mpu_set_lpf_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   02....       LJMP    ??mpu_set_lpf_2 & 0xFFFF
   1435          
   1436              if (lpf >= 188)
   \                     ??mpu_set_lpf_0:
   \   000017   C3           CLR     C
   \   000018   EA           MOV     A,R2
   \   000019   94BC         SUBB    A,#-0x44
   \   00001B   EB           MOV     A,R3
   \   00001C   9400         SUBB    A,#0x0
   \   00001E   400A         JC      ??mpu_set_lpf_3
   1437                  data = INV_FILTER_188HZ;
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   7401         MOV     A,#0x1
   \   000028   804E         SJMP    ??mpu_set_lpf_4
   1438              else if (lpf >= 98)
   \                     ??mpu_set_lpf_3:
   \   00002A   C3           CLR     C
   \   00002B   EA           MOV     A,R2
   \   00002C   9462         SUBB    A,#0x62
   \   00002E   EB           MOV     A,R3
   \   00002F   9400         SUBB    A,#0x0
   \   000031   400A         JC      ??mpu_set_lpf_5
   1439                  data = INV_FILTER_98HZ;
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   7402         MOV     A,#0x2
   \   00003B   803B         SJMP    ??mpu_set_lpf_4
   1440              else if (lpf >= 42)
   \                     ??mpu_set_lpf_5:
   \   00003D   C3           CLR     C
   \   00003E   EA           MOV     A,R2
   \   00003F   942A         SUBB    A,#0x2a
   \   000041   EB           MOV     A,R3
   \   000042   9400         SUBB    A,#0x0
   \   000044   400A         JC      ??mpu_set_lpf_6
   1441                  data = INV_FILTER_42HZ;
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   7403         MOV     A,#0x3
   \   00004E   8028         SJMP    ??mpu_set_lpf_4
   1442              else if (lpf >= 20)
   \                     ??mpu_set_lpf_6:
   \   000050   C3           CLR     C
   \   000051   EA           MOV     A,R2
   \   000052   9414         SUBB    A,#0x14
   \   000054   EB           MOV     A,R3
   \   000055   9400         SUBB    A,#0x0
   \   000057   400A         JC      ??mpu_set_lpf_7
   1443                  data = INV_FILTER_20HZ;
   \   000059   85..82       MOV     DPL,?XSP + 0
   \   00005C   85..83       MOV     DPH,?XSP + 1
   \   00005F   7404         MOV     A,#0x4
   \   000061   8015         SJMP    ??mpu_set_lpf_4
   1444              else if (lpf >= 10)
   \                     ??mpu_set_lpf_7:
   \   000063   C3           CLR     C
   \   000064   EA           MOV     A,R2
   \   000065   940A         SUBB    A,#0xa
   \   000067   EB           MOV     A,R3
   \   000068   9400         SUBB    A,#0x0
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   4004         JC      ??mpu_set_lpf_8
   1445                  data = INV_FILTER_10HZ;
   \   000072   7405         MOV     A,#0x5
   \   000074   8002         SJMP    ??mpu_set_lpf_4
   1446              else
   1447                  data = INV_FILTER_5HZ;
   \                     ??mpu_set_lpf_8:
   \   000076   7406         MOV     A,#0x6
   \                     ??mpu_set_lpf_4:
   \   000078   F0           MOVX    @DPTR,A
   1448          
   1449              if (st.chip_cfg.lpf == data)
   \   000079   90....       MOV     DPTR,#st + 7
   \   00007C   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   00007F   68           XRL     A,R0
   \   000080   6013         JZ      ??mpu_set_lpf_9
   1450                  return 0;
   1451              if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
   \   000082                ; Setup parameters for call to function I2C_Write
   \   000082   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000085   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   000088   7086         JNZ     ??mpu_set_lpf_1
   1452                  return -1;
   1453              st.chip_cfg.lpf = data;
   \   00008A   85..82       MOV     DPL,?XSP + 0
   \   00008D   85..83       MOV     DPH,?XSP + 1
   \   000090   E0           MOVX    A,@DPTR
   \   000091   90....       MOV     DPTR,#st + 7
   \   000094   F0           MOVX    @DPTR,A
   1454              return 0;
   \                     ??mpu_set_lpf_9:
   \   000095   7A00         MOV     R2,#0x0
   \   000097   7B00         MOV     R3,#0x0
   \                     ??mpu_set_lpf_2:
   \   000099   02....       LJMP    ?Subroutine3 & 0xFFFF
   1455          }
   1456          
   1457          /**
   1458           *  @brief      Get sampling rate.
   1459           *  @param[out] rate    Current sampling rate (Hz).
   1460           *  @return     0 if successful.
   1461           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1462          int mpu_get_sample_rate(unsigned short *rate)
   \                     mpu_get_sample_rate:
   1463          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1464              if (st.chip_cfg.dmp_on)
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6006         JZ      ??mpu_get_sample_rate_0
   1465                  return -1;
   \   00000A   7AFF         MOV     R2,#-0x1
   \   00000C   7BFF         MOV     R3,#-0x1
   \   00000E   8010         SJMP    ??CrossCallReturnLabel_250
   1466              else
   1467                  rate[0] = st.chip_cfg.sample_rate;
   \                     ??mpu_get_sample_rate_0:
   \   000010   90....       MOV     DPTR,#st + 9
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   E8           MOV     A,R0
   \   00001D   12....       LCALL   ?Subroutine65 & 0xFFFF
   1468              return 0;
   \                     ??CrossCallReturnLabel_250:
   \   000020   02....       LJMP    ??Subroutine114_0 & 0xFFFF
   1469          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003                REQUIRE ??Subroutine132_0
   \   000003                ; // Fall through to label ??Subroutine132_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7A00         MOV     R2,#0x0
   \   000003   7B00         MOV     R3,#0x0
   \   000005   22           RET
   1470          
   1471          /**
   1472           *  @brief      Set sampling rate.
   1473           *  Sampling rate must be between 4Hz and 1kHz.
   1474           *  @param[in]  rate    Desired sampling rate (Hz).
   1475           *  @return     0 if successful.
   1476           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1477          int mpu_set_sample_rate(unsigned short rate)
   \                     mpu_set_sample_rate:
   1478          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1479              unsigned char data;
   1480          
   1481              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_set_sample_rate_0
   1482                  return -1;
   \                     ??mpu_set_sample_rate_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_set_sample_rate_2 & 0xFFFF
   1483          
   1484              if (st.chip_cfg.dmp_on)
   \                     ??mpu_set_sample_rate_0:
   \   00001B   90....       MOV     DPTR,#st + 29
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   70F3         JNZ     ??mpu_set_sample_rate_1
   1485                  return -1;
   1486              else {
   1487                  if (st.chip_cfg.lp_accel_mode) {
   \   000021   90....       MOV     DPTR,#st + 15
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6019         JZ      ??mpu_set_sample_rate_3
   1488                      if (rate && (rate <= 40)) {
   \   000027   EE           MOV     A,R6
   \   000028   4F           ORL     A,R7
   \   000029   6010         JZ      ??mpu_set_sample_rate_4
   \   00002B   C3           CLR     C
   \   00002C   EE           MOV     A,R6
   \   00002D   9429         SUBB    A,#0x29
   \   00002F   EF           MOV     A,R7
   \   000030   9400         SUBB    A,#0x0
   \   000032   5007         JNC     ??mpu_set_sample_rate_4
   1489                          /* Just stay in low-power accel mode. */
   1490                          mpu_lp_accel_mode(rate);
   \   000034                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000034   EE           MOV     A,R6
   \   000035   F9           MOV     R1,A
   \   000036   12....       LCALL   ??mpu_lp_accel_mode?relay
   1491                          return 0;
   \   000039   8062         SJMP    ??mpu_set_sample_rate_5
   1492                      }
   1493                      /* Requested rate exceeds the allowed frequencies in LP accel mode,
   1494                       * switch back to full-power mode.
   1495                       */
   1496                      mpu_lp_accel_mode(0);
   \                     ??mpu_set_sample_rate_4:
   \   00003B                ; Setup parameters for call to function mpu_lp_accel_mode
   \   00003B   7900         MOV     R1,#0x0
   \   00003D   12....       LCALL   ??mpu_lp_accel_mode?relay
   1497                  }
   1498                  if (rate < 4)
   \                     ??mpu_set_sample_rate_3:
   \   000040   C3           CLR     C
   \   000041   EE           MOV     A,R6
   \   000042   9404         SUBB    A,#0x4
   \   000044   EF           MOV     A,R7
   \   000045   9400         SUBB    A,#0x0
   \   000047   5006         JNC     ??mpu_set_sample_rate_6
   1499                      rate = 4;
   \   000049   7E04         MOV     R6,#0x4
   \   00004B   7F00         MOV     R7,#0x0
   \   00004D   800D         SJMP    ??mpu_set_sample_rate_7
   1500                  else if (rate > 1000)
   \                     ??mpu_set_sample_rate_6:
   \   00004F   C3           CLR     C
   \   000050   EE           MOV     A,R6
   \   000051   94E9         SUBB    A,#-0x17
   \   000053   EF           MOV     A,R7
   \   000054   9403         SUBB    A,#0x3
   \   000056   4004         JC      ??mpu_set_sample_rate_7
   1501                      rate = 1000;
   \   000058   7EE8         MOV     R6,#-0x18
   \   00005A   7F03         MOV     R7,#0x3
   1502          
   1503                  data = 1000 / rate - 1;
   \                     ??mpu_set_sample_rate_7:
   \   00005C   78E8         MOV     R0,#-0x18
   \   00005E   7903         MOV     R1,#0x3
   \   000060   EE           MOV     A,R6
   \   000061   FA           MOV     R2,A
   \   000062   EF           MOV     A,R7
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   ?US_DIV_MOD
   \   000067   E8           MOV     A,R0
   \   000068   14           DEC     A
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   12....       LCALL   ?Subroutine37 & 0xFFFF
   1504                  if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
   \                     ??CrossCallReturnLabel_193:
   \   000072   A3           INC     DPTR
   \   000073   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000076   709C         JNZ     ??mpu_set_sample_rate_1
   1505                      return -1;
   1506          
   1507                  st.chip_cfg.sample_rate = 1000 / (1 + data);
   \   000078   78E8         MOV     R0,#-0x18
   \   00007A   7903         MOV     R1,#0x3
   \   00007C   85..82       MOV     DPL,?XSP + 0
   \   00007F   85..83       MOV     DPH,?XSP + 1
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2401         ADD     A,#0x1
   \   000085   FA           MOV     R2,A
   \   000086   E4           CLR     A
   \   000087   3400         ADDC    A,#0x0
   \   000089   FB           MOV     R3,A
   \   00008A   12....       LCALL   ?S_DIV_MOD
   \   00008D   90....       MOV     DPTR,#st + 9
   \   000090   12....       LCALL   ?Subroutine66 & 0xFFFF
   1508          
   1509          #ifdef AK89xx_SECONDARY
   1510                  mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
   1511          #endif
   1512          
   1513                  /* Automatically set LPF to 1/2 sampling rate. */
   1514                  mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
   \                     ??CrossCallReturnLabel_161:
   \   000093                ; Setup parameters for call to function mpu_set_lpf
   \   000093   90....       MOV     DPTR,#st + 9
   \   000096   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000099   FA           MOV     R2,A
   \   00009A   12....       LCALL   ??mpu_set_lpf?relay
   1515                  return 0;
   \                     ??mpu_set_sample_rate_5:
   \   00009D   7A00         MOV     R2,#0x0
   \   00009F   7B00         MOV     R3,#0x0
   1516              }
   \                     ??mpu_set_sample_rate_2:
   \   0000A1   02....       LJMP    ?Subroutine3 & 0xFFFF
   1517          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C3           CLR     C
   \   000005   13           RRC     A
   \   000006   FB           MOV     R3,A
   \   000007   EA           MOV     A,R2
   \   000008   13           RRC     A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000003                REQUIRE ??Subroutine119_0
   \   000003                ; // Fall through to label ??Subroutine119_0
   1518          
   1519          /**
   1520           *  @brief      Get compass sampling rate.
   1521           *  @param[out] rate    Current compass sampling rate (Hz).
   1522           *  @return     0 if successful.
   1523           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1524          int mpu_get_compass_sample_rate(unsigned short *rate)
   \                     mpu_get_compass_sample_rate:
   1525          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1526          #ifdef AK89xx_SECONDARY
   1527              rate[0] = st.chip_cfg.compass_sample_rate;
   1528              return 0;
   1529          #else
   1530              rate[0] = 0;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   F0           MOVX    @DPTR,A
   1531              return -1;
   \   00000C   7AFF         MOV     R2,#-0x1
   \   00000E   7BFF         MOV     R3,#-0x1
   \   000010   02....       LJMP    ??Subroutine114_0 & 0xFFFF
   1532          #endif
   1533          }
   1534          
   1535          /**
   1536           *  @brief      Set compass sampling rate.
   1537           *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
   1538           *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
   1539           *  sampling rate.
   1540           *
   1541           *  \n WARNING: The new rate may be different than what was requested. Call
   1542           *  mpu_get_compass_sample_rate to check the actual setting.
   1543           *  @param[in]  rate    Desired compass sampling rate (Hz).
   1544           *  @return     0 if successful.
   1545           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1546          int mpu_set_compass_sample_rate(unsigned short rate)
   \                     mpu_set_compass_sample_rate:
   1547          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1548          #ifdef AK89xx_SECONDARY
   1549              unsigned char div;
   1550              if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
   1551                  return -1;
   1552          
   1553              div = st.chip_cfg.sample_rate / rate - 1;
   1554              if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
   1555                  return -1;
   1556              st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
   1557              return 0;
   1558          #else
   1559              return -1;
   \   000000                REQUIRE ?Subroutine2
   \   000000                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7AFF         MOV     R2,#-0x1
   \   000002   7BFF         MOV     R3,#-0x1
   \   000004   02....       LJMP    ?BRET
   1560          #endif
   1561          }
   1562          
   1563          /**
   1564           *  @brief      Get gyro sensitivity scale factor.
   1565           *  @param[out] sens    Conversion from hardware units to dps.
   1566           *  @return     0 if successful.
   1567           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1568          int mpu_get_gyro_sens(float *sens)
   \                     mpu_get_gyro_sens:
   1569          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   1570              switch (st.chip_cfg.gyro_fsr) {
   \   000009   90....       MOV     DPTR,#st + 4
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   600B         JZ      ??mpu_get_gyro_sens_0
   \   00000F   14           DEC     A
   \   000010   601C         JZ      ??mpu_get_gyro_sens_1
   \   000012   14           DEC     A
   \   000013   601E         JZ      ??mpu_get_gyro_sens_2
   \   000015   14           DEC     A
   \   000016   6020         JZ      ??mpu_get_gyro_sens_3
   \   000018   8023         SJMP    ??mpu_get_gyro_sens_4
   1571              case INV_FSR_250DPS:
   1572                  sens[0] = 131.f;
   \                     ??mpu_get_gyro_sens_0:
   \   00001A   90....       MOV     DPTR,#__Constant_43030000
   \                     ??mpu_get_gyro_sens_5:
   \   00001D   12....       LCALL   ?XLOAD_R2345
   \   000020   8882         MOV     DPL,R0
   \   000022   8983         MOV     DPH,R1
   \   000024   12....       LCALL   ?XSTORE_R2345
   1573                  break;
   1574              case INV_FSR_500DPS:
   1575                  sens[0] = 65.5f;
   1576                  break;
   1577              case INV_FSR_1000DPS:
   1578                  sens[0] = 32.8f;
   1579                  break;
   1580              case INV_FSR_2000DPS:
   1581                  sens[0] = 16.4f;
   1582                  break;
   1583              default:
   1584                  return -1;
   1585              }
   1586              return 0;
   \   000027   7A00         MOV     R2,#0x0
   \   000029   7B00         MOV     R3,#0x0
   \                     ??mpu_get_gyro_sens_6:
   \   00002B   02....       LJMP    ?Subroutine4 & 0xFFFF
   \                     ??mpu_get_gyro_sens_1:
   \   00002E   90....       MOV     DPTR,#__Constant_42830000
   \   000031   80EA         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_2:
   \   000033   90....       MOV     DPTR,#__Constant_42033333
   \   000036   80E5         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_3:
   \   000038   90....       MOV     DPTR,#__Constant_41833333
   \   00003B   80E0         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_4:
   \   00003D   7AFF         MOV     R2,#-0x1
   \   00003F   7BFF         MOV     R3,#-0x1
   \   000041   80E8         SJMP    ??mpu_get_gyro_sens_6
   1587          }
   1588          
   1589          /**
   1590           *  @brief      Get accel sensitivity scale factor.
   1591           *  @param[out] sens    Conversion from hardware units to g's.
   1592           *  @return     0 if successful.
   1593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1594          int mpu_get_accel_sens(unsigned short *sens)
   \                     mpu_get_accel_sens:
   1595          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1596              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_sens_0
   \   00000A   14           DEC     A
   \   00000B   6033         JZ      ??mpu_get_accel_sens_1
   \   00000D   14           DEC     A
   \   00000E   603C         JZ      ??mpu_get_accel_sens_2
   \   000010   14           DEC     A
   \   000011   6044         JZ      ??mpu_get_accel_sens_3
   \   000013   804D         SJMP    ??mpu_get_accel_sens_4
   1597              case INV_FSR_2G:
   1598                  sens[0] = 16384;
   \                     ??mpu_get_accel_sens_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7440         MOV     A,#0x40
   \                     ??mpu_get_accel_sens_5:
   \   00001E   F0           MOVX    @DPTR,A
   1599                  break;
   1600              case INV_FSR_4G:
   1601                  sens[0] = 8092;
   1602                  break;
   1603              case INV_FSR_8G:
   1604                  sens[0] = 4096;
   1605                  break;
   1606              case INV_FSR_16G:
   1607                  sens[0] = 2048;
   1608                  break;
   1609              default:
   1610                  return -1;
   1611              }
   1612              if (st.chip_cfg.accel_half)
   \   00001F   90....       MOV     DPTR,#st + 14
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6014         JZ      ??CrossCallReturnLabel_156
   1613                  sens[0] >>= 1;
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   C3           CLR     C
   \   00002E   13           RRC     A
   \   00002F   F9           MOV     R1,A
   \   000030   E8           MOV     A,R0
   \   000031   13           RRC     A
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   1614              return 0;
   \                     ??CrossCallReturnLabel_156:
   \   000039   7A00         MOV     R2,#0x0
   \   00003B   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_sens_6:
   \   00003D   02....       LJMP    ??Subroutine114_0 & 0xFFFF
   \                     ??mpu_get_accel_sens_1:
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   749C         MOV     A,#-0x64
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   741F         MOV     A,#0x1f
   \   00004A   80D2         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_2:
   \   00004C   8A82         MOV     DPL,R2
   \   00004E   8B83         MOV     DPH,R3
   \   000050   E4           CLR     A
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   7410         MOV     A,#0x10
   \   000055   80C7         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_3:
   \   000057   8A82         MOV     DPL,R2
   \   000059   8B83         MOV     DPH,R3
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   7408         MOV     A,#0x8
   \   000060   80BC         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_4:
   \   000062   7AFF         MOV     R2,#-0x1
   \   000064   7BFF         MOV     R3,#-0x1
   \   000066   80D5         SJMP    ??mpu_get_accel_sens_6
   1615          }
   1616          
   1617          /**
   1618           *  @brief      Get current FIFO configuration.
   1619           *  @e sensors can contain a combination of the following flags:
   1620           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1621           *  \n INV_XYZ_GYRO
   1622           *  \n INV_XYZ_ACCEL
   1623           *  @param[out] sensors Mask of sensors in FIFO.
   1624           *  @return     0 if successful.
   1625           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1626          int mpu_get_fifo_config(unsigned char *sensors)
   \                     mpu_get_fifo_config:
   1627          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1628              sensors[0] = st.chip_cfg.fifo_enable;
   \   000004   90....       MOV     DPTR,#st + 11
   \   000007   02....       LJMP    ?Subroutine1 & 0xFFFF
   1629              return 0;
   1630          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005                REQUIRE ??Subroutine112_0
   \   000005                ; // Fall through to label ??Subroutine112_0
   1631          
   1632          /**
   1633           *  @brief      Select which sensors are pushed to FIFO.
   1634           *  @e sensors can contain a combination of the following flags:
   1635           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1636           *  \n INV_XYZ_GYRO
   1637           *  \n INV_XYZ_ACCEL
   1638           *  @param[in]  sensors Mask of sensors to push to FIFO.
   1639           *  @return     0 if successful.
   1640           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1641          int mpu_configure_fifo(unsigned char sensors)
   \                     mpu_configure_fifo:
   1642          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1643              unsigned char prev;
   1644              int result = 0;
   1645          
   1646              /* Compass data isn't going into the FIFO. Stop trying. */
   1647              sensors &= ~INV_XYZ_COMPASS;
   \   000005   E9           MOV     A,R1
   \   000006   C2E0         CLR     0xE0 /* A   */.0
   \   000008   F5..         MOV     ?V0 + 0,A
   1648          
   1649              if (st.chip_cfg.dmp_on)
   \   00000A   90....       MOV     DPTR,#st + 29
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6006         JZ      ??mpu_configure_fifo_0
   1650                  return 0;
   \   000010   7A00         MOV     R2,#0x0
   \   000012   7B00         MOV     R3,#0x0
   \   000014   803E         SJMP    ??mpu_configure_fifo_1
   1651              else {
   1652                  if (!(st.chip_cfg.sensors))
   \                     ??mpu_configure_fifo_0:
   \   000016   90....       MOV     DPTR,#st + 6
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F8           MOV     R0,A
   \   00001B   7006         JNZ     ??mpu_configure_fifo_2
   1653                      return -1;
   \                     ??mpu_configure_fifo_3:
   \   00001D   7AFF         MOV     R2,#-0x1
   \   00001F   7BFF         MOV     R3,#-0x1
   \   000021   8031         SJMP    ??mpu_configure_fifo_1
   1654                  prev = st.chip_cfg.fifo_enable;
   \                     ??mpu_configure_fifo_2:
   \   000023   90....       MOV     DPTR,#st + 11
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F5..         MOV     ?V0 + 1,A
   1655                  st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
   \   000029   E5..         MOV     A,?V0 + 0
   \   00002B   58           ANL     A,R0
   \   00002C   F8           MOV     R0,A
   \   00002D   F0           MOVX    @DPTR,A
   1656                  if (st.chip_cfg.fifo_enable != sensors)
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   68           XRL     A,R0
   \   000031   6006         JZ      ??mpu_configure_fifo_4
   1657                      /* You're not getting what you asked for. Some sensors are
   1658                       * asleep.
   1659                       */
   1660                      result = -1;
   \   000033   7EFF         MOV     R6,#-0x1
   \   000035   7FFF         MOV     R7,#-0x1
   \   000037   8004         SJMP    ??mpu_configure_fifo_5
   1661                  else
   1662                      result = 0;
   \                     ??mpu_configure_fifo_4:
   \   000039   7E00         MOV     R6,#0x0
   \   00003B   7F00         MOV     R7,#0x0
   1663                  if (sensors || st.chip_cfg.lp_accel_mode)
   \                     ??mpu_configure_fifo_5:
   \   00003D   E5..         MOV     A,?V0 + 0
   \   00003F   7006         JNZ     ??mpu_configure_fifo_6
   \   000041   90....       MOV     DPTR,#st + 15
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6010         JZ      ??mpu_configure_fifo_7
   1664                      set_int_enable(1);
   \                     ??mpu_configure_fifo_6:
   \   000047                ; Setup parameters for call to function set_int_enable
   \   000047   7901         MOV     R1,#0x1
   \   000049   12....       LCALL   ??set_int_enable?relay
   1665                  else
   1666                      set_int_enable(0);
   1667                  if (sensors) {
   \   00004C   E5..         MOV     A,?V0 + 0
   \   00004E   700E         JNZ     ??mpu_configure_fifo_8
   1668                      if (mpu_reset_fifo()) {
   1669                          st.chip_cfg.fifo_enable = prev;
   1670                          return -1;
   1671                      }
   1672                  }
   1673              }
   1674          
   1675              return result;
   \                     ??mpu_configure_fifo_9:
   \   000050   EE           MOV     A,R6
   \   000051   FA           MOV     R2,A
   \   000052   EF           MOV     A,R7
   \   000053   FB           MOV     R3,A
   \                     ??mpu_configure_fifo_1:
   \   000054   02....       LJMP    ??Subroutine131_0 & 0xFFFF
   \                     ??mpu_configure_fifo_7:
   \   000057                ; Setup parameters for call to function set_int_enable
   \   000057   7900         MOV     R1,#0x0
   \   000059   12....       LCALL   ??set_int_enable?relay
   \   00005C   80F2         SJMP    ??mpu_configure_fifo_9
   \                     ??mpu_configure_fifo_8:
   \   00005E                ; Setup parameters for call to function mpu_reset_fifo
   \   00005E   12....       LCALL   ??mpu_reset_fifo?relay
   \   000061   8B..         MOV     ?V0 + 3,R3
   \   000063   EA           MOV     A,R2
   \   000064   45..         ORL     A,?V0 + 3
   \   000066   60E8         JZ      ??mpu_configure_fifo_9
   \   000068   E5..         MOV     A,?V0 + 1
   \   00006A   90....       MOV     DPTR,#st + 11
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   80AD         SJMP    ??mpu_configure_fifo_3
   1676          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1677          
   1678          /**
   1679           *  @brief      Get current power state.
   1680           *  @param[in]  power_on    1 if turned on, 0 if suspended.
   1681           *  @return     0 if successful.
   1682           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1683          int mpu_get_power_state(unsigned char *power_on)
   \                     mpu_get_power_state:
   1684          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1685              if (st.chip_cfg.sensors)
   \   000004   90....       MOV     DPTR,#st + 6
   \   000007   E0           MOVX    A,@DPTR
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   6004         JZ      ??mpu_get_power_state_0
   1686                  power_on[0] = 1;
   \   00000E   7401         MOV     A,#0x1
   \   000010   8001         SJMP    ??mpu_get_power_state_1
   1687              else
   1688                  power_on[0] = 0;
   \                     ??mpu_get_power_state_0:
   \   000012   E4           CLR     A
   \                     ??mpu_get_power_state_1:
   \   000013   80..         SJMP    ??Subroutine112_0
   1689              return 0;
   1690          }
   1691          
   1692          /**
   1693           *  @brief      Turn specific sensors on/off.
   1694           *  @e sensors can contain a combination of the following flags:
   1695           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1696           *  \n INV_XYZ_GYRO
   1697           *  \n INV_XYZ_ACCEL
   1698           *  \n INV_XYZ_COMPASS
   1699           *  @param[in]  sensors    Mask of sensors to wake.
   1700           *  @return     0 if successful.
   1701           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1702          int mpu_set_sensors(unsigned char sensors)
   \                     mpu_set_sensors:
   1703          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1704              unsigned char data;
   1705          #ifdef AK89xx_SECONDARY
   1706              unsigned char user_ctrl;
   1707          #endif
   1708          
   1709              if (sensors & INV_XYZ_GYRO)
   \   00000C   7470         MOV     A,#0x70
   \   00000E   5E           ANL     A,R6
   \   00000F   600A         JZ      ??mpu_set_sensors_0
   1710                  data = INV_CLK_PLL;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7401         MOV     A,#0x1
   \   000019   800E         SJMP    ??mpu_set_sensors_1
   1711              else if (sensors)
   \                     ??mpu_set_sensors_0:
   \   00001B   EE           MOV     A,R6
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   6003         JZ      ??mpu_set_sensors_2
   1712                  data = 0;
   \   000024   E4           CLR     A
   \   000025   8002         SJMP    ??mpu_set_sensors_1
   1713              else
   1714                  data = BIT_SLEEP;
   \                     ??mpu_set_sensors_2:
   \   000027   7440         MOV     A,#0x40
   \                     ??mpu_set_sensors_1:
   \   000029   12....       LCALL   ?Subroutine64 & 0xFFFF
   1715              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
   \                     ??CrossCallReturnLabel_102:
   \   00002C   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   00002F   600B         JZ      ??mpu_set_sensors_3
   1716                  st.chip_cfg.sensors = 0;
   \                     ??mpu_set_sensors_4:
   \   000031   90....       MOV     DPTR,#st + 6
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   1717                  return -1;
   \   000036   7AFF         MOV     R2,#-0x1
   \   000038   7BFF         MOV     R3,#-0x1
   \   00003A   8066         SJMP    ??mpu_set_sensors_5
   1718              }
   1719              st.chip_cfg.clk_src = data & ~BIT_SLEEP;
   \                     ??mpu_set_sensors_3:
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   E0           MOVX    A,@DPTR
   \   000043   54BF         ANL     A,#0xbf
   \   000045   90....       MOV     DPTR,#st + 8
   \   000048   12....       LCALL   ?Subroutine102 & 0xFFFF
   1720          
   1721              data = 0;
   \                     ??CrossCallReturnLabel_267:
   \   00004B   E4           CLR     A
   \   00004C   F0           MOVX    @DPTR,A
   1722              if (!(sensors & INV_X_GYRO))
   \   00004D   EE           MOV     A,R6
   \   00004E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000050   4003         JC      ??mpu_set_sensors_6
   1723                  data |= BIT_STBY_XG;
   \   000052   7404         MOV     A,#0x4
   \   000054   F0           MOVX    @DPTR,A
   1724              if (!(sensors & INV_Y_GYRO))
   \                     ??mpu_set_sensors_6:
   \   000055   EE           MOV     A,R6
   \   000056   A2E5         MOV     C,0xE0 /* A   */.5
   \   000058   4004         JC      ??mpu_set_sensors_7
   1725                  data |= BIT_STBY_YG;
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   D2E1         SETB    0xE0 /* A   */.1
   \   00005D   F0           MOVX    @DPTR,A
   1726              if (!(sensors & INV_Z_GYRO))
   \                     ??mpu_set_sensors_7:
   \   00005E   EE           MOV     A,R6
   \   00005F   A2E4         MOV     C,0xE0 /* A   */.4
   \   000061   4004         JC      ??mpu_set_sensors_8
   1727                  data |= BIT_STBY_ZG;
   \   000063   E0           MOVX    A,@DPTR
   \   000064   D2E0         SETB    0xE0 /* A   */.0
   \   000066   F0           MOVX    @DPTR,A
   1728              if (!(sensors & INV_XYZ_ACCEL))
   \                     ??mpu_set_sensors_8:
   \   000067   EE           MOV     A,R6
   \   000068   A2E3         MOV     C,0xE0 /* A   */.3
   \   00006A   4004         JC      ??mpu_set_sensors_9
   1729                  data |= BIT_STBY_XYZA;
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   4438         ORL     A,#0x38
   \   00006F   F0           MOVX    @DPTR,A
   1730              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
   \                     ??mpu_set_sensors_9:
   \   000070                ; Setup parameters for call to function I2C_Write
   \   000070   AC82         MOV     R4,DPL
   \   000072   AD83         MOV     R5,DPH
   \   000074   7B01         MOV     R3,#0x1
   \   000076   90....       MOV     DPTR,#st
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   2413         ADD     A,#0x13
   \   00007C   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   00007F   70B0         JNZ     ??mpu_set_sensors_4
   1731                  st.chip_cfg.sensors = 0;
   1732                  return -1;
   1733              }
   1734          
   1735              if (sensors && (sensors != INV_XYZ_ACCEL))
   \   000081   EE           MOV     A,R6
   \   000082   600A         JZ      ??mpu_set_sensors_10
   \   000084   7408         MOV     A,#0x8
   \   000086   6E           XRL     A,R6
   \   000087   6005         JZ      ??mpu_set_sensors_10
   1736                  /* Latched interrupts only used in LP accel mode. */
   1737                  mpu_set_int_latched(0);
   \   000089                ; Setup parameters for call to function mpu_set_int_latched
   \   000089   7900         MOV     R1,#0x0
   \   00008B   12....       LCALL   ??mpu_set_int_latched?relay
   1738          
   1739          #ifdef AK89xx_SECONDARY
   1740          #ifdef AK89xx_BYPASS
   1741              if (sensors & INV_XYZ_COMPASS)
   1742                  mpu_set_bypass(1);
   1743              else
   1744                  mpu_set_bypass(0);
   1745          #else
   1746              if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1747                  return -1;
   1748              /* Handle AKM power management. */
   1749              if (sensors & INV_XYZ_COMPASS) {
   1750                  data = AKM_SINGLE_MEASUREMENT;
   1751                  user_ctrl |= BIT_AUX_IF_EN;
   1752              } else {
   1753                  data = AKM_POWER_DOWN;
   1754                  user_ctrl &= ~BIT_AUX_IF_EN;
   1755              }
   1756              if (st.chip_cfg.dmp_on)
   1757                  user_ctrl |= BIT_DMP_EN;
   1758              else
   1759                  user_ctrl &= ~BIT_DMP_EN;
   1760              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
   1761                  return -1;
   1762              /* Enable/disable I2C master mode. */
   1763              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1764                  return -1;
   1765          #endif
   1766          #endif
   1767          
   1768              st.chip_cfg.sensors = sensors;
   \                     ??mpu_set_sensors_10:
   \   00008E   EE           MOV     A,R6
   \   00008F   90....       MOV     DPTR,#st + 6
   \   000092   F0           MOVX    @DPTR,A
   1769              st.chip_cfg.lp_accel_mode = 0;
   \   000093   90....       MOV     DPTR,#st + 15
   \   000096   E4           CLR     A
   \   000097   F0           MOVX    @DPTR,A
   1770              delay_ms(50);
   \   000098                ; Setup parameters for call to function delay_ms
   \   000098   7A32         MOV     R2,#0x32
   \   00009A   FB           MOV     R3,A
   \   00009B   12....       LCALL   ??delay_ms?relay
   1771              return 0;
   \   00009E   7A00         MOV     R2,#0x0
   \   0000A0   7B00         MOV     R3,#0x0
   \                     ??mpu_set_sensors_5:
   \   0000A2                REQUIRE ?Subroutine3
   \   0000A2                ; // Fall through to label ?Subroutine3
   1772          }
   1773          
   1774          /**
   1775           *  @brief      Read the MPU interrupt status registers.
   1776           *  @param[out] status  Mask of interrupt bits.
   1777           *  @return     0 if successful.
   1778           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1779          int mpu_get_int_status(short *status)
   \                     mpu_get_int_status:
   1780          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1781              unsigned char tmp[2];
   1782              if (!st.chip_cfg.sensors)
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7006         JNZ     ??mpu_get_int_status_0
   1783                  return -1;
   \                     ??mpu_get_int_status_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   8023         SJMP    ??CrossCallReturnLabel_251
   1784              if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
   \                     ??mpu_get_int_status_0:
   \   00001A                ; Setup parameters for call to function I2C_Read
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   AC82         MOV     R4,DPL
   \   000022   AD83         MOV     R5,DPH
   \   000024   7B02         MOV     R3,#0x2
   \   000026   90....       MOV     DPTR,#st
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   2410         ADD     A,#0x10
   \   00002C   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   00002F   70E3         JNZ     ??mpu_get_int_status_1
   1785                  return -1;
   1786              status[0] = (tmp[0] << 8) | tmp[1];
   \   000031   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   00003A   12....       LCALL   ?Subroutine65 & 0xFFFF
   1787              return 0;
   \                     ??CrossCallReturnLabel_251:
   \   00003D   02....       LJMP    ?Subroutine9 & 0xFFFF
   1788          }
   1789          
   1790          /**
   1791           *  @brief      Get one packet from the FIFO.
   1792           *  If @e sensors does not contain a particular sensor, disregard the data
   1793           *  returned to that pointer.
   1794           *  \n @e sensors can contain a combination of the following flags:
   1795           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1796           *  \n INV_XYZ_GYRO
   1797           *  \n INV_XYZ_ACCEL
   1798           *  \n If the FIFO has no new data, @e sensors will be zero.
   1799           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
   1800           *  return a non-zero error code.
   1801           *  @param[out] gyro        Gyro data in hardware units.
   1802           *  @param[out] accel       Accel data in hardware units.
   1803           *  @param[out] timestamp   Timestamp in milliseconds.
   1804           *  @param[out] sensors     Mask of sensors read from FIFO.
   1805           *  @param[out] more        Number of remaining packets.
   1806           *  @return     0 if successful.
   1807           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1808          int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
   \                     mpu_read_fifo:
   1809                  unsigned char *sensors, unsigned char *more)
   1810          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 10,R2
   \   00000C   8B..         MOV     ?V0 + 11,R3
   \   00000E   8C..         MOV     ?V0 + 8,R4
   \   000010   8D..         MOV     ?V0 + 9,R5
   \   000012   7426         MOV     A,#0x26
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   00001A   7428         MOV     A,#0x28
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 14,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 15,A
   1811              /* Assumes maximum packet size is gyro (6) + accel (6). */
   1812              unsigned char data[MAX_PACKET_LENGTH];
   1813              unsigned char packet_size = 0;
   \   000026   75..00       MOV     ?V0 + 2,#0x0
   1814              unsigned short fifo_count, index = 0;
   \   000029   7E00         MOV     R6,#0x0
   \   00002B   7F00         MOV     R7,#0x0
   1815          
   1816              if (st.chip_cfg.dmp_on)
   \   00002D   90....       MOV     DPTR,#st + 29
   \   000030   E0           MOVX    A,@DPTR
   \   000031   6009         JZ      ??mpu_read_fifo_0
   1817                  return -1;
   \                     ??mpu_read_fifo_1:
   \   000033   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_2:
   \   000035   7BFF         MOV     R3,#-0x1
   \                     ??mpu_read_fifo_3:
   \   000037   740C         MOV     A,#0xc
   \   000039   02....       LJMP    ?Subroutine6 & 0xFFFF
   1818          
   1819              sensors[0] = 0;
   \                     ??mpu_read_fifo_0:
   \   00003C   85..82       MOV     DPL,?V0 + 4
   \   00003F   85..83       MOV     DPH,?V0 + 5
   \   000042   E4           CLR     A
   \   000043   F0           MOVX    @DPTR,A
   1820              if (!st.chip_cfg.sensors)
   \   000044   90....       MOV     DPTR,#st + 6
   \   000047   E0           MOVX    A,@DPTR
   \   000048   60E9         JZ      ??mpu_read_fifo_1
   1821                  return -1;
   1822              if (!st.chip_cfg.fifo_enable)
   \   00004A   90....       MOV     DPTR,#st + 11
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   60E3         JZ      ??mpu_read_fifo_1
   1823                  return -1;
   1824          
   1825              if (st.chip_cfg.fifo_enable & INV_X_GYRO)
   \   000050   A2E6         MOV     C,0xE0 /* A   */.6
   \   000052   5003         JNC     ??mpu_read_fifo_4
   1826                  packet_size += 2;
   \   000054   75..02       MOV     ?V0 + 2,#0x2
   1827              if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
   \                     ??mpu_read_fifo_4:
   \   000057   A2E5         MOV     C,0xE0 /* A   */.5
   \   000059   5004         JNC     ??mpu_read_fifo_5
   1828                  packet_size += 2;
   \   00005B   05..         INC     ?V0 + 2
   \   00005D   05..         INC     ?V0 + 2
   1829              if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
   \                     ??mpu_read_fifo_5:
   \   00005F   A2E4         MOV     C,0xE0 /* A   */.4
   \   000061   5004         JNC     ??mpu_read_fifo_6
   1830                  packet_size += 2;
   \   000063   05..         INC     ?V0 + 2
   \   000065   05..         INC     ?V0 + 2
   1831              if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
   \                     ??mpu_read_fifo_6:
   \   000067   A2E3         MOV     C,0xE0 /* A   */.3
   \   000069   5006         JNC     ??mpu_read_fifo_7
   1832                  packet_size += 6;
   \   00006B   7406         MOV     A,#0x6
   \   00006D   25..         ADD     A,?V0 + 2
   \   00006F   F5..         MOV     ?V0 + 2,A
   1833          
   1834              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \                     ??mpu_read_fifo_7:
   \   000071                ; Setup parameters for call to function I2C_Read
   \   000071   85..82       MOV     DPL,?XSP + 0
   \   000074   85..83       MOV     DPH,?XSP + 1
   \   000077   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00007A   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   00007D   70B4         JNZ     ??mpu_read_fifo_1
   1835                  return -1;
   1836              fifo_count = (data[0] << 8) | data[1];
   \   00007F   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   E0           MOVX    A,@DPTR
   \   000086   FA           MOV     R2,A
   \   000087   F5..         MOV     ?V0 + 0,A
   \   000089   E9           MOV     A,R1
   \   00008A   F5..         MOV     ?V0 + 1,A
   1837              if (fifo_count < packet_size)
   \   00008C   85..82       MOV     DPL,?V0 + 2
   \   00008F   8582..       MOV     ?V0 + 6,DPL
   \   000092   C3           CLR     C
   \   000093   EA           MOV     A,R2
   \   000094   95..         SUBB    A,?V0 + 6
   \   000096   E9           MOV     A,R1
   \   000097   9400         SUBB    A,#0x0
   \   000099   5006         JNC     ??mpu_read_fifo_8
   1838                  return 0;
   \                     ??mpu_read_fifo_9:
   \   00009B   7A00         MOV     R2,#0x0
   \   00009D   7B00         MOV     R3,#0x0
   \   00009F   8096         SJMP    ??mpu_read_fifo_3
   1839          //    log_i("FIFO count: %hd\n", fifo_count);
   1840              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_8:
   \   0000A1   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000A4   95..         SUBB    A,?V0 + 0
   \   0000A6   EB           MOV     A,R3
   \   0000A7   95..         SUBB    A,?V0 + 1
   \   0000A9   503B         JNC     ??mpu_read_fifo_10
   1841                  /* FIFO is 50% full, better check overflow bit. */
   1842                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
   \   0000AB                ; Setup parameters for call to function I2C_Read
   \   0000AB   85..82       MOV     DPL,?XSP + 0
   \   0000AE   85..83       MOV     DPH,?XSP + 1
   \   0000B1   AC82         MOV     R4,DPL
   \   0000B3   AD83         MOV     R5,DPH
   \   0000B5   7B01         MOV     R3,#0x1
   \   0000B7   90....       MOV     DPTR,#st
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   2411         ADD     A,#0x11
   \   0000BD   F5..         MOV     ?V0 + 12,A
   \   0000BF   A3           INC     DPTR
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   3400         ADDC    A,#0x0
   \   0000C3   85..82       MOV     DPL,?V0 + 12
   \   0000C6   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000C9   8B..         MOV     ?V0 + 13,R3
   \   0000CB   EA           MOV     A,R2
   \   0000CC   45..         ORL     A,?V0 + 13
   \   0000CE   6003         JZ      $+5
   \   0000D0   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1843                      return -1;
   1844                  if (data[0] & BIT_FIFO_OVERFLOW) {
   \   0000D3   85..82       MOV     DPL,?XSP + 0
   \   0000D6   85..83       MOV     DPH,?XSP + 1
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000DC   5008         JNC     ??mpu_read_fifo_10
   1845                      mpu_reset_fifo();
   \   0000DE                ; Setup parameters for call to function mpu_reset_fifo
   \   0000DE   12....       LCALL   ??mpu_reset_fifo?relay
   1846                      return -2;
   \   0000E1   7AFE         MOV     R2,#-0x2
   \   0000E3   02....       LJMP    ??mpu_read_fifo_2 & 0xFFFF
   1847                  }
   1848              }
   1849              get_ms((unsigned long*)timestamp);
   1850          
   1851              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
   \                     ??mpu_read_fifo_10:
   \   0000E6                ; Setup parameters for call to function I2C_Read
   \   0000E6   85..82       MOV     DPL,?XSP + 0
   \   0000E9   85..83       MOV     DPH,?XSP + 1
   \   0000EC   AC82         MOV     R4,DPL
   \   0000EE   AD83         MOV     R5,DPH
   \   0000F0   AB..         MOV     R3,?V0 + 2
   \   0000F2   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   0000F5   8B..         MOV     ?V0 + 13,R3
   \   0000F7   EA           MOV     A,R2
   \   0000F8   45..         ORL     A,?V0 + 13
   \   0000FA   6003         JZ      $+5
   \   0000FC   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1852                  return -1;
   1853              more[0] = fifo_count / packet_size - 1;
   \   0000FF   A8..         MOV     R0,?V0 + 0
   \   000101   A9..         MOV     R1,?V0 + 1
   \   000103   AA..         MOV     R2,?V0 + 6
   \   000105   7B00         MOV     R3,#0x0
   \   000107   12....       LCALL   ?US_DIV_MOD
   \   00010A   E8           MOV     A,R0
   \   00010B   14           DEC     A
   \   00010C   85..82       MOV     DPL,?V0 + 14
   \   00010F   85..83       MOV     DPH,?V0 + 15
   \   000112   F0           MOVX    @DPTR,A
   1854              sensors[0] = 0;
   \   000113   85..82       MOV     DPL,?V0 + 4
   \   000116   85..83       MOV     DPH,?V0 + 5
   \   000119   E4           CLR     A
   \   00011A   F0           MOVX    @DPTR,A
   1855          
   1856              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
   \   00011B   E5..         MOV     A,?V0 + 2
   \   00011D   7003         JNZ     $+5
   \   00011F   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \   000122   90....       MOV     DPTR,#st + 11
   \   000125   E0           MOVX    A,@DPTR
   \   000126   A2E3         MOV     C,0xE0 /* A   */.3
   \   000128   5041         JNC     ??mpu_read_fifo_11
   1857                  accel[0] = (data[index+0] << 8) | data[index+1];
   \   00012A   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   00012D   12....       LCALL   ?XSTACK_DISP0_8
   \   000130   E0           MOVX    A,@DPTR
   \   000131   85..82       MOV     DPL,?V0 + 8
   \   000134   85..83       MOV     DPH,?V0 + 9
   \   000137   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   1858                  accel[1] = (data[index+2] << 8) | data[index+3];
   \                     ??CrossCallReturnLabel_157:
   \   00013A   7402         MOV     A,#0x2
   \   00013C   12....       LCALL   ?XSTACK_DISP0_8
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   F9           MOV     R1,A
   \   000141   7403         MOV     A,#0x3
   \   000143   12....       LCALL   ?XSTACK_DISP0_8
   \   000146   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000149   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   1859                  accel[2] = (data[index+4] << 8) | data[index+5];
   \                     ??CrossCallReturnLabel_158:
   \   00014C   7404         MOV     A,#0x4
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   E0           MOVX    A,@DPTR
   \   000152   F9           MOV     R1,A
   \   000153   7405         MOV     A,#0x5
   \   000155   12....       LCALL   ?XSTACK_DISP0_8
   \   000158   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   00015B   12....       LCALL   ?Subroutine60 & 0xFFFF
   1860                  sensors[0] |= INV_XYZ_ACCEL;
   \                     ??CrossCallReturnLabel_179:
   \   00015E   D2E3         SETB    0xE0 /* A   */.3
   \   000160   F0           MOVX    @DPTR,A
   1861                  index += 6;
   \   000161   7E06         MOV     R6,#0x6
   1862              }
   1863              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
   \   000163   EE           MOV     A,R6
   \   000164   65..         XRL     A,?V0 + 2
   \   000166   7003         JNZ     $+5
   \   000168   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \                     ??mpu_read_fifo_11:
   \   00016B   90....       MOV     DPTR,#st + 11
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   A2E6         MOV     C,0xE0 /* A   */.6
   \   000171   5021         JNC     ??mpu_read_fifo_12
   1864                  gyro[0] = (data[index+0] << 8) | data[index+1];
   \   000173   85..82       MOV     DPL,?XSP + 0
   \   000176   85..83       MOV     DPH,?XSP + 1
   \   000179   E582         MOV     A,DPL
   \   00017B   2E           ADD     A,R6
   \   00017C   F582         MOV     DPL,A
   \   00017E   E583         MOV     A,DPH
   \   000180   3400         ADDC    A,#0x0
   \   000182   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000185   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   1865                  sensors[0] |= INV_X_GYRO;
   \                     ??CrossCallReturnLabel_181:
   \   000188   D2E6         SETB    0xE0 /* A   */.6
   \   00018A   F0           MOVX    @DPTR,A
   1866                  index += 2;
   \   00018B   EE           MOV     A,R6
   \   00018C   2402         ADD     A,#0x2
   \   00018E   0E           INC     R6
   \   00018F   0E           INC     R6
   \   000190   E4           CLR     A
   \   000191   3400         ADDC    A,#0x0
   \   000193   FF           MOV     R7,A
   1867              }
   1868              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
   \                     ??mpu_read_fifo_12:
   \   000194   EE           MOV     A,R6
   \   000195   65..         XRL     A,?V0 + 2
   \   000197   601A         JZ      ??mpu_read_fifo_13
   \   000199   90....       MOV     DPTR,#st + 11
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   A2E5         MOV     C,0xE0 /* A   */.5
   \   00019F   5012         JNC     ??mpu_read_fifo_13
   1869                  gyro[1] = (data[index+0] << 8) | data[index+1];
   \   0001A1   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0001A4   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   1870                  sensors[0] |= INV_Y_GYRO;
   \                     ??CrossCallReturnLabel_182:
   \   0001A7   D2E5         SETB    0xE0 /* A   */.5
   \   0001A9   F0           MOVX    @DPTR,A
   1871                  index += 2;
   \   0001AA   EE           MOV     A,R6
   \   0001AB   2402         ADD     A,#0x2
   \   0001AD   0E           INC     R6
   \   0001AE   0E           INC     R6
   \   0001AF   EF           MOV     A,R7
   \   0001B0   3400         ADDC    A,#0x0
   \   0001B2   FF           MOV     R7,A
   1872              }
   1873              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
   \                     ??mpu_read_fifo_13:
   \   0001B3   EE           MOV     A,R6
   \   0001B4   65..         XRL     A,?V0 + 2
   \   0001B6   7003         JNZ     $+5
   \   0001B8   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \   0001BB   90....       MOV     DPTR,#st + 11
   \   0001BE   E0           MOVX    A,@DPTR
   \   0001BF   A2E4         MOV     C,0xE0 /* A   */.4
   \   0001C1   4003         JC      $+5
   \   0001C3   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1874                  gyro[2] = (data[index+0] << 8) | data[index+1];
   \   0001C6   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0001C9   12....       LCALL   ?Subroutine60 & 0xFFFF
   1875                  sensors[0] |= INV_Z_GYRO;
   \                     ??CrossCallReturnLabel_180:
   \   0001CC   D2E4         SETB    0xE0 /* A   */.4
   \   0001CE   F0           MOVX    @DPTR,A
   1876                  index += 2;
   \   0001CF   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1877              }
   1878          
   1879              return 0;
   1880          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine116_0
   \   000002                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   85..82       MOV     DPL,?V0 + 4
   \   000007   85..83       MOV     DPH,?V0 + 5
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0 + 8
   \   000004   85..83       MOV     DPH,?V0 + 9
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   2E           ADD     A,R6
   \   000009   F582         MOV     DPL,A
   \   00000B   E583         MOV     A,DPH
   \   00000D   3F           ADDC    A,R7
   \   00000E   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   F583         MOV     DPH,A
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   85..82       MOV     DPL,?V0 + 10
   \   000009   85..83       MOV     DPH,?V0 + 11
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000003   12....       LCALL   ??I2C_Read?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000003   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000006   C3           CLR     C
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   90....       MOV     DPTR,#st
   \   000003   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000006   FA           MOV     R2,A
   \   000007   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B02         MOV     R3,#0x2
   \   000006   90....       MOV     DPTR,#st
   \   000009   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   F583         MOV     DPH,A
   \   000002   E0           MOVX    A,@DPTR
   \   000003   FA           MOV     R2,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F9           MOV     R1,A
   \   00000A   22           RET
   1881          
   1882          /**
   1883           *  @brief      Get one unparsed packet from the FIFO.
   1884           *  This function should be used if the packet is to be parsed elsewhere.
   1885           *  @param[in]  length  Length of one FIFO packet.
   1886           *  @param[in]  data    FIFO packet.
   1887           *  @param[in]  more    Number of remaining packets.
   1888           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1889          int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
   \                     mpu_read_fifo_stream:
   1890              unsigned char *more)
   1891          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 3,A
   1892              unsigned char tmp[2];
   1893              unsigned short fifo_count;
   1894              if (!st.chip_cfg.dmp_on)
   \   00001E   90....       MOV     DPTR,#st + 29
   \   000021   E0           MOVX    A,@DPTR
   \   000022   7007         JNZ     ??mpu_read_fifo_stream_0
   1895                  return -1;
   \                     ??mpu_read_fifo_stream_1:
   \   000024   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_stream_2:
   \   000026   7BFF         MOV     R3,#-0x1
   \   000028   02....       LJMP    ??CrossCallReturnLabel_252 & 0xFFFF
   1896              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_fifo_stream_0:
   \   00002B   90....       MOV     DPTR,#st + 6
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   60F3         JZ      ??mpu_read_fifo_stream_1
   1897                  return -1;
   1898          
   1899              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
   \   000031                ; Setup parameters for call to function I2C_Read
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   AC82         MOV     R4,DPL
   \   000039   AD83         MOV     R5,DPH
   \   00003B   7B02         MOV     R3,#0x2
   \   00003D   90....       MOV     DPTR,#st
   \   000040   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000043   FA           MOV     R2,A
   \   000044   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000047   8B..         MOV     ?V0 + 7,R3
   \   000049   EA           MOV     A,R2
   \   00004A   45..         ORL     A,?V0 + 7
   \   00004C   70D6         JNZ     ??mpu_read_fifo_stream_1
   1900                  return -1;
   1901              fifo_count = (tmp[0] << 8) | tmp[1];
   \   00004E   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FE           MOV     R6,A
   \   000056   E9           MOV     A,R1
   \   000057   FF           MOV     R7,A
   1902              if (fifo_count < length) {
   \   000058   C3           CLR     C
   \   000059   EE           MOV     A,R6
   \   00005A   95..         SUBB    A,?V0 + 0
   \   00005C   EF           MOV     A,R7
   \   00005D   95..         SUBB    A,?V0 + 1
   \   00005F   500A         JNC     ??mpu_read_fifo_stream_3
   1903                  more[0] = 0;
   \   000061   85..82       MOV     DPL,?V0 + 2
   \   000064   85..83       MOV     DPH,?V0 + 3
   \   000067   E4           CLR     A
   \   000068   F0           MOVX    @DPTR,A
   \   000069   80B9         SJMP    ??mpu_read_fifo_stream_1
   1904                  return -1;
   1905              }
   1906              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_stream_3:
   \   00006B   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00006E   9E           SUBB    A,R6
   \   00006F   EB           MOV     A,R3
   \   000070   9F           SUBB    A,R7
   \   000071   5038         JNC     ??mpu_read_fifo_stream_4
   1907                  /* FIFO is 50% full, better check overflow bit. */
   1908                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
   \   000073                ; Setup parameters for call to function I2C_Read
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   AC82         MOV     R4,DPL
   \   00007B   AD83         MOV     R5,DPH
   \   00007D   7B01         MOV     R3,#0x1
   \   00007F   90....       MOV     DPTR,#st
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2411         ADD     A,#0x11
   \   000085   F5..         MOV     ?V0 + 6,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   3400         ADDC    A,#0x0
   \   00008B   85..82       MOV     DPL,?V0 + 6
   \   00008E   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000091   8B..         MOV     ?V0 + 7,R3
   \   000093   EA           MOV     A,R2
   \   000094   45..         ORL     A,?V0 + 7
   \   000096   708C         JNZ     ??mpu_read_fifo_stream_1
   1909                      return -1;
   1910                  if (tmp[0] & BIT_FIFO_OVERFLOW) {
   \   000098   85..82       MOV     DPL,?XSP + 0
   \   00009B   85..83       MOV     DPH,?XSP + 1
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000A1   5008         JNC     ??mpu_read_fifo_stream_4
   1911                      mpu_reset_fifo();
   \   0000A3                ; Setup parameters for call to function mpu_reset_fifo
   \   0000A3   12....       LCALL   ??mpu_reset_fifo?relay
   1912                      return -2;
   \   0000A6   7AFE         MOV     R2,#-0x2
   \   0000A8   02....       LJMP    ??mpu_read_fifo_stream_2 & 0xFFFF
   1913                  }
   1914              }
   1915          
   1916              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
   \                     ??mpu_read_fifo_stream_4:
   \   0000AB                ; Setup parameters for call to function I2C_Read
   \   0000AB   AC..         MOV     R4,?V0 + 4
   \   0000AD   AD..         MOV     R5,?V0 + 5
   \   0000AF   AB..         MOV     R3,?V0 + 0
   \   0000B1   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000B4   8B..         MOV     ?V0 + 5,R3
   \   0000B6   EA           MOV     A,R2
   \   0000B7   45..         ORL     A,?V0 + 5
   \   0000B9   6003         JZ      $+5
   \   0000BB   02....       LJMP    ??mpu_read_fifo_stream_1 & 0xFFFF
   1917                  return -1;
   1918              more[0] = fifo_count / length - 1;
   \   0000BE   EE           MOV     A,R6
   \   0000BF   F8           MOV     R0,A
   \   0000C0   EF           MOV     A,R7
   \   0000C1   F9           MOV     R1,A
   \   0000C2   AA..         MOV     R2,?V0 + 0
   \   0000C4   AB..         MOV     R3,?V0 + 1
   \   0000C6   12....       LCALL   ?US_DIV_MOD
   \   0000C9   E8           MOV     A,R0
   \   0000CA   14           DEC     A
   \   0000CB   85..82       MOV     DPL,?V0 + 2
   \   0000CE   85..83       MOV     DPH,?V0 + 3
   \   0000D1   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   1919              return 0;
   \                     ??CrossCallReturnLabel_252:
   \   0000D4   02....       LJMP    ?Subroutine0 & 0xFFFF
   1920          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET
   1921          
   1922          /**
   1923           *  @brief      Set device to bypass mode.
   1924           *  @param[in]  bypass_on   1 to enable bypass mode.
   1925           *  @return     0 if successful.
   1926           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1927          int mpu_set_bypass(unsigned char bypass_on)
   \                     mpu_set_bypass:
   1928          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1929              unsigned char tmp;
   1930          
   1931              if (st.chip_cfg.bypass_mode == bypass_on)
   \   00000C   90....       MOV     DPTR,#st + 13
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   7003         JNZ     $+5
   \   000013   02....       LJMP    ??mpu_set_bypass_0 & 0xFFFF
   1932                  return 0;
   1933          
   1934              if (bypass_on) {
   \   000016   90....       MOV     DPTR,#st + 2
   \   000019   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F9           MOV     R1,A
   \   00001E   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FA           MOV     R2,A
   \   000023   EE           MOV     A,R6
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   AC82         MOV     R4,DPL
   \   00002C   AD83         MOV     R5,DPH
   \   00002E   7B01         MOV     R3,#0x1
   \   000030   605D         JZ      ??mpu_set_bypass_1
   1935                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   000032                ; Setup parameters for call to function I2C_Read
   \   000032   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000035   6007         JZ      ??mpu_set_bypass_2
   1936                      return -1;
   \                     ??mpu_set_bypass_3:
   \   000037   7AFF         MOV     R2,#-0x1
   \   000039   7BFF         MOV     R3,#-0x1
   \   00003B   02....       LJMP    ??mpu_set_bypass_4 & 0xFFFF
   1937                  tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_2:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E0           MOVX    A,@DPTR
   \   000045   C2E5         CLR     0xE0 /* A   */.5
   \   000047   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   1938                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??CrossCallReturnLabel_169:
   \   00004A   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00004D   70E8         JNZ     ??mpu_set_bypass_3
   1939                      return -1;
   1940                  delay_ms(3);
   \   00004F                ; Setup parameters for call to function delay_ms
   \   00004F   7A03         MOV     R2,#0x3
   \   000051   12....       LCALL   ?Subroutine67 & 0xFFFF
   1941                  tmp = BIT_BYPASS_EN;
   \                     ??CrossCallReturnLabel_105:
   \   000054   7402         MOV     A,#0x2
   \   000056   F0           MOVX    @DPTR,A
   1942                  if (st.chip_cfg.active_low_int)
   \   000057   90....       MOV     DPTR,#st + 27
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6009         JZ      ??mpu_set_bypass_5
   1943                      tmp |= BIT_ACTL;
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   7482         MOV     A,#-0x7e
   \   000065   F0           MOVX    @DPTR,A
   1944                  if (st.chip_cfg.latched_int)
   \                     ??mpu_set_bypass_5:
   \   000066   90....       MOV     DPTR,#st + 28
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   600A         JZ      ??mpu_set_bypass_6
   1945                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00006C   85..82       MOV     DPL,?XSP + 0
   \   00006F   85..83       MOV     DPH,?XSP + 1
   \   000072   E0           MOVX    A,@DPTR
   \   000073   4430         ORL     A,#0x30
   \   000075   F0           MOVX    @DPTR,A
   1946                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_6:
   \   000076                ; Setup parameters for call to function I2C_Write
   \   000076   85..82       MOV     DPL,?XSP + 0
   \   000079   85..83       MOV     DPH,?XSP + 1
   \   00007C   AC82         MOV     R4,DPL
   \   00007E   AD83         MOV     R5,DPH
   \   000080   7B01         MOV     R3,#0x1
   \   000082   90....       MOV     DPTR,#st
   \   000085   E0           MOVX    A,@DPTR
   \   000086   2414         ADD     A,#0x14
   \   000088   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   1947                      return -1;
   1948              } else {
   \                     ??CrossCallReturnLabel_289:
   \   00008B   70AA         JNZ     ??mpu_set_bypass_3
   \   00008D   8061         SJMP    ??mpu_set_bypass_7
   1949                  /* Enable I2C master mode if compass is being used. */
   1950                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??mpu_set_bypass_1:
   \   00008F                ; Setup parameters for call to function I2C_Read
   \   00008F   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000092   70A3         JNZ     ??mpu_set_bypass_3
   1951                      return -1;
   1952                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   000094   90....       MOV     DPTR,#st + 6
   \   000097   E0           MOVX    A,@DPTR
   \   000098   A2E0         MOV     C,0xE0 /* A   */.0
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   5004         JNC     ??mpu_set_bypass_8
   1953                      tmp |= BIT_AUX_IF_EN;
   \   0000A3   D2E5         SETB    0xE0 /* A   */.5
   \   0000A5   8002         SJMP    ??mpu_set_bypass_9
   1954                  else
   1955                      tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_8:
   \   0000A7   C2E5         CLR     0xE0 /* A   */.5
   \                     ??mpu_set_bypass_9:
   \   0000A9   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   1956                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??CrossCallReturnLabel_170:
   \   0000AC   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   0000AF   7086         JNZ     ??mpu_set_bypass_3
   1957                      return -1;
   1958                  delay_ms(3);
   \   0000B1                ; Setup parameters for call to function delay_ms
   \   0000B1   7A03         MOV     R2,#0x3
   \   0000B3   7B00         MOV     R3,#0x0
   \   0000B5   12....       LCALL   ??delay_ms?relay
   1959                  if (st.chip_cfg.active_low_int)
   \   0000B8   90....       MOV     DPTR,#st + 27
   \   0000BB   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   0000BE   6004         JZ      ??mpu_set_bypass_10
   1960                      tmp = BIT_ACTL;
   \   0000C0   7480         MOV     A,#-0x80
   \   0000C2   8001         SJMP    ??mpu_set_bypass_11
   1961                  else
   1962                      tmp = 0;
   \                     ??mpu_set_bypass_10:
   \   0000C4   E4           CLR     A
   \                     ??mpu_set_bypass_11:
   \   0000C5   F0           MOVX    @DPTR,A
   1963                  if (st.chip_cfg.latched_int)
   \   0000C6   90....       MOV     DPTR,#st + 28
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   600A         JZ      ??mpu_set_bypass_12
   1964                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   0000CC   85..82       MOV     DPL,?XSP + 0
   \   0000CF   85..83       MOV     DPH,?XSP + 1
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   4430         ORL     A,#0x30
   \   0000D5   F0           MOVX    @DPTR,A
   1965                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_12:
   \   0000D6                ; Setup parameters for call to function I2C_Write
   \   0000D6   85..82       MOV     DPL,?XSP + 0
   \   0000D9   85..83       MOV     DPH,?XSP + 1
   \   0000DC   AC82         MOV     R4,DPL
   \   0000DE   AD83         MOV     R5,DPH
   \   0000E0   7B01         MOV     R3,#0x1
   \   0000E2   90....       MOV     DPTR,#st
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   2414         ADD     A,#0x14
   \   0000E8   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   1966                      return -1;
   1967              }
   \                     ??CrossCallReturnLabel_290:
   \   0000EB   6003         JZ      $+5
   \   0000ED   02....       LJMP    ??mpu_set_bypass_3 & 0xFFFF
   1968              st.chip_cfg.bypass_mode = bypass_on;
   \                     ??mpu_set_bypass_7:
   \   0000F0   EE           MOV     A,R6
   \   0000F1   90....       MOV     DPTR,#st + 13
   \   0000F4   F0           MOVX    @DPTR,A
   1969              return 0;
   \                     ??mpu_set_bypass_0:
   \   0000F5   7A00         MOV     R2,#0x0
   \   0000F7   7B00         MOV     R3,#0x0
   \                     ??mpu_set_bypass_4:
   \   0000F9   02....       LJMP    ?Subroutine3 & 0xFFFF
   1970          }
   1971          
   1972          /**
   1973           *  @brief      Set interrupt level.
   1974           *  @param[in]  active_low  1 for active low, 0 for active high.
   1975           *  @return     0 if successful.
   1976           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1977          int mpu_set_int_level(unsigned char active_low)
   \                     mpu_set_int_level:
   1978          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1979              st.chip_cfg.active_low_int = active_low;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#st + 27
   \   000008   02....       LJMP    ??Subroutine112_0 & 0xFFFF
   1980              return 0;
   1981          }
   1982          
   1983          /**
   1984           *  @brief      Enable latched interrupts.
   1985           *  Any MPU register will clear the interrupt.
   1986           *  @param[in]  enable  1 to enable, 0 to disable.
   1987           *  @return     0 if successful.
   1988           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1989          int mpu_set_int_latched(unsigned char enable)
   \                     mpu_set_int_latched:
   1990          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1991              unsigned char tmp;
   1992              if (st.chip_cfg.latched_int == enable)
   \   00000C   90....       MOV     DPTR,#st + 28
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   6051         JZ      ??mpu_set_int_latched_0
   1993                  return 0;
   1994          
   1995              if (enable)
   \   000013   EE           MOV     A,R6
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   6004         JZ      ??mpu_set_int_latched_1
   1996                  tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00001C   7430         MOV     A,#0x30
   \   00001E   8001         SJMP    ??mpu_set_int_latched_2
   1997              else
   1998                  tmp = 0;
   \                     ??mpu_set_int_latched_1:
   \   000020   E4           CLR     A
   \                     ??mpu_set_int_latched_2:
   \   000021   F0           MOVX    @DPTR,A
   1999              if (st.chip_cfg.bypass_mode)
   \   000022   90....       MOV     DPTR,#st + 13
   \   000025   E0           MOVX    A,@DPTR
   \   000026   600A         JZ      ??mpu_set_int_latched_3
   2000                  tmp |= BIT_BYPASS_EN;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   D2E1         SETB    0xE0 /* A   */.1
   \   000031   F0           MOVX    @DPTR,A
   2001              if (st.chip_cfg.active_low_int)
   \                     ??mpu_set_int_latched_3:
   \   000032   90....       MOV     DPTR,#st + 27
   \   000035   E0           MOVX    A,@DPTR
   \   000036   600A         JZ      ??mpu_set_int_latched_4
   2002                  tmp |= BIT_ACTL;
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   D2E7         SETB    0xE0 /* A   */.7
   \   000041   F0           MOVX    @DPTR,A
   2003              if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_int_latched_4:
   \   000042                ; Setup parameters for call to function I2C_Write
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   AC82         MOV     R4,DPL
   \   00004A   AD83         MOV     R5,DPH
   \   00004C   7B01         MOV     R3,#0x1
   \   00004E   90....       MOV     DPTR,#st
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2414         ADD     A,#0x14
   \   000054   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000057   6006         JZ      ??mpu_set_int_latched_5
   2004                  return -1;
   \   000059   7AFF         MOV     R2,#-0x1
   \   00005B   7BFF         MOV     R3,#-0x1
   \   00005D   8009         SJMP    ??mpu_set_int_latched_6
   2005              st.chip_cfg.latched_int = enable;
   \                     ??mpu_set_int_latched_5:
   \   00005F   EE           MOV     A,R6
   \   000060   90....       MOV     DPTR,#st + 28
   \   000063   F0           MOVX    @DPTR,A
   2006              return 0;
   \                     ??mpu_set_int_latched_0:
   \   000064   7A00         MOV     R2,#0x0
   \   000066   7B00         MOV     R3,#0x0
   \                     ??mpu_set_int_latched_6:
   \   000068   02....       LJMP    ?Subroutine3 & 0xFFFF
   2007          }
   2008          
   2009          #ifdef MPU6050

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2010          static int get_accel_prod_shift(float *st_shift)
   \                     get_accel_prod_shift:
   2011          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 12,R2
   \   00000C   8B..         MOV     ?V0 + 13,R3
   2012              unsigned char tmp[4], shift_code[3], ii;
   2013          
   2014              if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
   \   00000E                ; Setup parameters for call to function I2C_Read
   \   00000E   7403         MOV     A,#0x3
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   7B04         MOV     R3,#0x4
   \   000019   7A0D         MOV     R2,#0xd
   \   00001B   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   00001E   6005         JZ      ??get_accel_prod_shift_0
   2015                  return 0x07;
   \   000020   7A07         MOV     R2,#0x7
   \   000022   02....       LJMP    ??get_accel_prod_shift_1 & 0xFFFF
   2016          
   2017              shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
   \                     ??get_accel_prod_shift_0:
   \   000025   7406         MOV     A,#0x6
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   C4           SWAP    A
   \   00002D   540F         ANL     A,#0xf
   \   00002F   5403         ANL     A,#0x3
   \   000031   F8           MOV     R0,A
   \   000032   7403         MOV     A,#0x3
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   F0           MOVX    @DPTR,A
   2018              shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
   \   000041   E9           MOV     A,R1
   \   000042   13           RRC     A
   \   000043   13           RRC     A
   \   000044   543F         ANL     A,#0x3f
   \   000046   5403         ANL     A,#0x3
   \   000048   F8           MOV     R0,A
   \   000049   7404         MOV     A,#0x4
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000051   C0E0         PUSH    A
   \   000053   7401         MOV     A,#0x1
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   D0E0         POP     A
   \   00005A   F0           MOVX    @DPTR,A
   2019              shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
   \   00005B   7403         MOV     A,#0x3
   \   00005D   59           ANL     A,R1
   \   00005E   F8           MOV     R0,A
   \   00005F   7405         MOV     A,#0x5
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000067   C0E0         PUSH    A
   \   000069   7402         MOV     A,#0x2
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   D0E0         POP     A
   \   000070   F0           MOVX    @DPTR,A
   2020              for (ii = 0; ii < 3; ii++) {
   \   000071   7E00         MOV     R6,#0x0
   2021                  if (!shift_code[ii]) {
   \                     ??get_accel_prod_shift_2:
   \   000073   8E82         MOV     DPL,R6
   \   000075   AA82         MOV     R2,DPL
   \   000077   8A..         MOV     ?V0 + 0,R2
   \   000079   75..00       MOV     ?V0 + 1,#0x0
   \   00007C   7402         MOV     A,#0x2
   \   00007E   78..         MOV     R0,#?V0 + 0
   \   000080   12....       LCALL   ?S_SHL
   \   000083   E5..         MOV     A,?V0 + 12
   \   000085   25..         ADD     A,?V0 + 0
   \   000087   F5..         MOV     ?V0 + 4,A
   \   000089   E5..         MOV     A,?V0 + 13
   \   00008B   35..         ADDC    A,?V0 + 1
   \   00008D   F5..         MOV     ?V0 + 5,A
   \   00008F   85..82       MOV     DPL,?XSP + 0
   \   000092   85..83       MOV     DPH,?XSP + 1
   \   000095   E582         MOV     A,DPL
   \   000097   2A           ADD     A,R2
   \   000098   F5..         MOV     ?V0 + 6,A
   \   00009A   E583         MOV     A,DPH
   \   00009C   3400         ADDC    A,#0x0
   \   00009E   F5..         MOV     ?V0 + 7,A
   \   0000A0   85..82       MOV     DPL,?V0 + 6
   \   0000A3   F583         MOV     DPH,A
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   7011         JNZ     ??get_accel_prod_shift_3
   2022                      st_shift[ii] = 0.f;
   \   0000A8   90....       MOV     DPTR,#__Constant_0
   \   0000AB   12....       LCALL   ?XLOAD_R2345
   \   0000AE   85..82       MOV     DPL,?V0 + 4
   \   0000B1   85..83       MOV     DPH,?V0 + 5
   \   0000B4   12....       LCALL   ?XSTORE_R2345
   2023                      continue;
   \   0000B7   8041         SJMP    ??get_accel_prod_shift_4
   2024                  }
   2025                  /* Equivalent to..
   2026                   * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
   2027                   */
   2028                  st_shift[ii] = 0.34f;
   \                     ??get_accel_prod_shift_3:
   \   0000B9   90....       MOV     DPTR,#__Constant_3eae147b
   \   0000BC   12....       LCALL   ?XLOAD_R2345
   \   0000BF   85..82       MOV     DPL,?V0 + 4
   \   0000C2   85..83       MOV     DPH,?V0 + 5
   \   0000C5   12....       LCALL   ?XSTORE_R2345
   \   0000C8   8025         SJMP    ??get_accel_prod_shift_5
   2029                  while (--shift_code[ii])
   2030                      st_shift[ii] *= 1.034f;
   \                     ??get_accel_prod_shift_6:
   \   0000CA   85..82       MOV     DPL,?V0 + 4
   \   0000CD   85..83       MOV     DPH,?V0 + 5
   \   0000D0   78..         MOV     R0,#?V0 + 0
   \   0000D2   12....       LCALL   ?L_MOV_X
   \   0000D5   90....       MOV     DPTR,#__Constant_3f845a1d
   \   0000D8   78..         MOV     R0,#?V0 + 8
   \   0000DA   12....       LCALL   ?L_MOV_X
   \   0000DD   78..         MOV     R0,#?V0 + 0
   \   0000DF   79..         MOV     R1,#?V0 + 8
   \   0000E1   12....       LCALL   ?FLT_MUL
   \   0000E4   85..82       MOV     DPL,?V0 + 4
   \   0000E7   85..83       MOV     DPH,?V0 + 5
   \   0000EA   78..         MOV     R0,#?V0 + 0
   \   0000EC   12....       LCALL   ?L_MOV_TO_X
   \                     ??get_accel_prod_shift_5:
   \   0000EF   85..82       MOV     DPL,?V0 + 6
   \   0000F2   85..83       MOV     DPH,?V0 + 7
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   14           DEC     A
   \   0000F7   F0           MOVX    @DPTR,A
   \   0000F8   70D0         JNZ     ??get_accel_prod_shift_6
   2031              }
   \                     ??get_accel_prod_shift_4:
   \   0000FA   0E           INC     R6
   \   0000FB   EE           MOV     A,R6
   \   0000FC   C3           CLR     C
   \   0000FD   9403         SUBB    A,#0x3
   \   0000FF   5003         JNC     $+5
   \   000101   02....       LJMP    ??get_accel_prod_shift_2 & 0xFFFF
   2032              return 0;
   \   000104   7A00         MOV     R2,#0x0
   \                     ??get_accel_prod_shift_1:
   \   000106   7B00         MOV     R3,#0x0
   \   000108   7407         MOV     A,#0x7
   \   00010A                REQUIRE ?Subroutine7
   \   00010A                ; // Fall through to label ?Subroutine7
   2033          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F0E         MOV     R7,#0xe
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000003   541C         ANL     A,#0x1c
   \   000005   48           ORL     A,R0
   \   000006   22           RET
   2034          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2035          static int accel_self_test(long *bias_regular, long *bias_st)
   \                     accel_self_test:
   2036          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   12....       LCALL   ?Subroutine63 & 0xFFFF
   2037              int jj, result = 0;
   2038              float st_shift[3], st_shift_cust, st_shift_var;
   2039          
   2040              get_accel_prod_shift(st_shift);
   \                     ??CrossCallReturnLabel_98:
   \   000013                ; Setup parameters for call to function get_accel_prod_shift
   \   000013   7402         MOV     A,#0x2
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??get_accel_prod_shift?relay
   2041              for(jj = 0; jj < 3; jj++) {
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   2042                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \                     ??accel_self_test_0:
   \   000023   8E..         MOV     ?V0 + 2,R6
   \   000025   8F..         MOV     ?V0 + 3,R7
   \   000027   7402         MOV     A,#0x2
   \   000029   78..         MOV     R0,#?V0 + 2
   \   00002B   12....       LCALL   ?S_SHL
   \   00002E   85....       MOV     ?V0 + 0,?V0 + 2
   \   000031   85....       MOV     ?V0 + 1,?V0 + 3
   \   000034                ; Setup parameters for call to function labs
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   25..         ADD     A,?V0 + 0
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   35..         ADDC    A,?V0 + 1
   \   000042   8882         MOV     DPL,R0
   \   000044   F583         MOV     DPH,A
   \   000046   78..         MOV     R0,#?V0 + 4
   \   000048   12....       LCALL   ?L_MOV_X
   \   00004B   E5..         MOV     A,?V0 + 14
   \   00004D   25..         ADD     A,?V0 + 0
   \   00004F   F582         MOV     DPL,A
   \   000051   E5..         MOV     A,?V0 + 15
   \   000053   35..         ADDC    A,?V0 + 1
   \   000055   F583         MOV     DPH,A
   \   000057   78..         MOV     R0,#?V0 + 4
   \   000059   12....       LCALL   ?L_SUB_X
   \   00005C   AA..         MOV     R2,?V0 + 4
   \   00005E   AB..         MOV     R3,?V0 + 5
   \   000060   AC..         MOV     R4,?V0 + 6
   \   000062   AD..         MOV     R5,?V0 + 7
   \   000064   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000067   12....       LCALL   ?L_TO_FLT
   \   00006A   90....       MOV     DPTR,#__Constant_37800000
   \   00006D   78..         MOV     R0,#?V0 + 8
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 4
   \   000074   79..         MOV     R1,#?V0 + 8
   \   000076   12....       LCALL   ?FLT_MUL
   2043                  if (st_shift[jj]) {
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   E582         MOV     A,DPL
   \   000080   25..         ADD     A,?V0 + 0
   \   000082   F582         MOV     DPL,A
   \   000084   E583         MOV     A,DPH
   \   000086   35..         ADDC    A,?V0 + 1
   \   000088   F583         MOV     DPH,A
   \   00008A   78..         MOV     R0,#?V0 + 0
   \   00008C   12....       LCALL   ?L_MOV_X
   \   00008F   90....       MOV     DPTR,#__Constant_0
   \   000092   78..         MOV     R0,#?V0 + 8
   \   000094   12....       LCALL   ?L_MOV_X
   \   000097   78..         MOV     R0,#?V0 + 0
   \   000099   79..         MOV     R1,#?V0 + 8
   \   00009B   12....       LCALL   ?FLT_EQ
   \   00009E   602C         JZ      ??accel_self_test_1
   2044                      st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
   2045                      if (fabs(st_shift_var) > test.max_accel_var)
                                 ^
Warning[Pe223]: function "fabsf" declared implicitly
   \   0000A0                ; Setup parameters for call to function fabsf
   \   0000A0   78..         MOV     R0,#?V0 + 4
   \   0000A2   79..         MOV     R1,#?V0 + 0
   \   0000A4   12....       LCALL   ?FLT_DIV
   \   0000A7   90....       MOV     DPTR,#__Constant_bf800000
   \   0000AA   78..         MOV     R0,#?V0 + 0
   \   0000AC   12....       LCALL   ?L_MOV_X
   \   0000AF   78..         MOV     R0,#?V0 + 4
   \   0000B1   79..         MOV     R1,#?V0 + 0
   \   0000B3   12....       LCALL   ?FLT_ADD
   \   0000B6   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   0000B9   4033         JC      ??accel_self_test_2
   2046                          result |= 1 << jj;
   \                     ??accel_self_test_3:
   \   0000BB   75..01       MOV     ?V0 + 0,#0x1
   \   0000BE   75..00       MOV     ?V0 + 1,#0x0
   \   0000C1   EE           MOV     A,R6
   \   0000C2   78..         MOV     R0,#?V0 + 0
   \   0000C4   12....       LCALL   ?S_SHL
   \   0000C7   12....       LCALL   ?Subroutine73 & 0xFFFF
   2047                  } else if ((st_shift_cust < test.min_g) ||
   \                     ??CrossCallReturnLabel_116:
   \   0000CA   8022         SJMP    ??accel_self_test_2
   2048                      (st_shift_cust > test.max_g))
   \                     ??accel_self_test_1:
   \   0000CC   90....       MOV     DPTR,#__Constant_3e99999a
   \   0000CF   78..         MOV     R0,#?V0 + 0
   \   0000D1   12....       LCALL   ?L_MOV_X
   \   0000D4   78..         MOV     R0,#?V0 + 4
   \   0000D6   79..         MOV     R1,#?V0 + 0
   \   0000D8   12....       LCALL   ?FLT_LT
   \   0000DB   40DE         JC      ??accel_self_test_3
   \   0000DD   90....       MOV     DPTR,#__Constant_3f733334
   \   0000E0   78..         MOV     R0,#?V0 + 0
   \   0000E2   12....       LCALL   ?L_MOV_X
   \   0000E5   78..         MOV     R0,#?V0 + 4
   \   0000E7   79..         MOV     R1,#?V0 + 0
   \   0000E9   12....       LCALL   ?FLT_GE
   \   0000EC   40CD         JC      ??accel_self_test_3
   2049                      result |= 1 << jj;
   2050              }
   \                     ??accel_self_test_2:
   \   0000EE   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   0000F1   5003         JNC     $+5
   \   0000F3   02....       LJMP    ??accel_self_test_0 & 0xFFFF
   2051          
   2052              return result;
   \   0000F6   AA..         MOV     R2,?V0 + 12
   \   0000F8   AB..         MOV     R3,?V0 + 13
   \   0000FA   740E         MOV     A,#0xe
   \   0000FC   02....       LJMP    ?Subroutine6 & 0xFFFF
   2053          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   45..         ORL     A,?V0 + 12
   \   000004   F5..         MOV     ?V0 + 12,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   45..         ORL     A,?V0 + 13
   \   00000A   F5..         MOV     ?V0 + 13,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   12....       LCALL   ??labs?relay
   \   000003   8A..         MOV     ?V0 + 4,R2
   \   000005   8B..         MOV     ?V0 + 5,R3
   \   000007   8C..         MOV     ?V0 + 6,R4
   \   000009   8D..         MOV     ?V0 + 7,R5
   \   00000B   78..         MOV     R0,#?V0 + 4
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   8C..         MOV     ?V0 + 14,R4
   \   000007   8D..         MOV     ?V0 + 15,R5
   \   000009   75..00       MOV     ?V0 + 12,#0x0
   \   00000C   75..00       MOV     ?V0 + 13,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   AA..         MOV     R2,?V0 + 4
   \   000002   AB..         MOV     R3,?V0 + 5
   \   000004   AC..         MOV     R4,?V0 + 6
   \   000006   AD..         MOV     R5,?V0 + 7
   \   000008   12....       LCALL   ??fabsf?relay
   \   00000B   C3           CLR     C
   \   00000C   EA           MOV     A,R2
   \   00000D   9401         SUBB    A,#0x1
   \   00000F   EB           MOV     A,R3
   \   000010   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000003   9403         SUBB    A,#0x3
   \   000005   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   EF           MOV     A,R7
   \   000001                REQUIRE ??Subroutine129_0
   \   000001                ; // Fall through to label ??Subroutine129_0
   2054          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2055          static int gyro_self_test(long *bias_regular, long *bias_st)
   \                     gyro_self_test:
   2056          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7403         MOV     A,#0x3
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine63 & 0xFFFF
   2057              int jj, result = 0;
   2058              unsigned char tmp[3];
   2059              float st_shift, st_shift_cust, st_shift_var;
   2060          
   2061              if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
   \                     ??CrossCallReturnLabel_99:
   \   000012                ; Setup parameters for call to function I2C_Read
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   7B03         MOV     R3,#0x3
   \   00001E   7A0D         MOV     R2,#0xd
   \   000020   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000023   6007         JZ      ??gyro_self_test_0
   2062                  return 0x07;
   \   000025   7A07         MOV     R2,#0x7
   \   000027   7B00         MOV     R3,#0x0
   \   000029   02....       LJMP    ??gyro_self_test_1 & 0xFFFF
   2063          
   2064              tmp[0] &= 0x1F;
   \                     ??gyro_self_test_0:
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   541F         ANL     A,#0x1f
   \   000035   F0           MOVX    @DPTR,A
   2065              tmp[1] &= 0x1F;
   \   000036   7401         MOV     A,#0x1
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   541F         ANL     A,#0x1f
   \   00003E   F0           MOVX    @DPTR,A
   2066              tmp[2] &= 0x1F;
   \   00003F   7402         MOV     A,#0x2
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E0           MOVX    A,@DPTR
   \   000045   541F         ANL     A,#0x1f
   \   000047   F0           MOVX    @DPTR,A
   2067          
   2068              for (jj = 0; jj < 3; jj++) {
   \   000048   7E00         MOV     R6,#0x0
   \   00004A   7F00         MOV     R7,#0x0
   2069                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \                     ??gyro_self_test_2:
   \   00004C   8E..         MOV     ?V0 + 0,R6
   \   00004E   8F..         MOV     ?V0 + 1,R7
   \   000050   7402         MOV     A,#0x2
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?S_SHL
   \   000057   AA..         MOV     R2,?V0 + 0
   \   000059   AB..         MOV     R3,?V0 + 1
   \   00005B                ; Setup parameters for call to function labs
   \   00005B   7403         MOV     A,#0x3
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   2A           ADD     A,R2
   \   000062   F8           MOV     R0,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   3B           ADDC    A,R3
   \   000066   8882         MOV     DPL,R0
   \   000068   F583         MOV     DPH,A
   \   00006A   78..         MOV     R0,#?V0 + 0
   \   00006C   12....       LCALL   ?L_MOV_X
   \   00006F   E5..         MOV     A,?V0 + 14
   \   000071   2A           ADD     A,R2
   \   000072   F582         MOV     DPL,A
   \   000074   E5..         MOV     A,?V0 + 15
   \   000076   3B           ADDC    A,R3
   \   000077   F583         MOV     DPH,A
   \   000079   78..         MOV     R0,#?V0 + 0
   \   00007B   12....       LCALL   ?L_SUB_X
   \   00007E   AA..         MOV     R2,?V0 + 0
   \   000080   AB..         MOV     R3,?V0 + 1
   \   000082   AC..         MOV     R4,?V0 + 2
   \   000084   AD..         MOV     R5,?V0 + 3
   \   000086   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000089   12....       LCALL   ?L_TO_FLT
   \   00008C   90....       MOV     DPTR,#__Constant_37800000
   \   00008F   78..         MOV     R0,#?V0 + 0
   \   000091   12....       LCALL   ?L_MOV_X
   \   000094   78..         MOV     R0,#?V0 + 4
   \   000096   79..         MOV     R1,#?V0 + 0
   \   000098   12....       LCALL   ?FLT_MUL
   2070                  if (tmp[jj]) {
   \   00009B   85..82       MOV     DPL,?XSP + 0
   \   00009E   85..83       MOV     DPH,?XSP + 1
   \   0000A1   E582         MOV     A,DPL
   \   0000A3   2E           ADD     A,R6
   \   0000A4   FA           MOV     R2,A
   \   0000A5   E583         MOV     A,DPH
   \   0000A7   3F           ADDC    A,R7
   \   0000A8   FB           MOV     R3,A
   \   0000A9   8A82         MOV     DPL,R2
   \   0000AB   8B83         MOV     DPH,R3
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   604E         JZ      ??gyro_self_test_3
   2071                      st_shift = 3275.f / test.gyro_sens;
   \   0000B0   90....       MOV     DPTR,#__Constant_41c80000
   \   0000B3   78..         MOV     R0,#?V0 + 0
   \   0000B5   12....       LCALL   ?L_MOV_X
   \   0000B8   800F         SJMP    ??gyro_self_test_4
   2072                      while (--tmp[jj])
   2073                          st_shift *= 1.046f;
   \                     ??gyro_self_test_5:
   \   0000BA   90....       MOV     DPTR,#__Constant_3f85e354
   \   0000BD   78..         MOV     R0,#?V0 + 8
   \   0000BF   12....       LCALL   ?L_MOV_X
   \   0000C2   78..         MOV     R0,#?V0 + 0
   \   0000C4   79..         MOV     R1,#?V0 + 8
   \   0000C6   12....       LCALL   ?FLT_MUL
   \                     ??gyro_self_test_4:
   \   0000C9   8A82         MOV     DPL,R2
   \   0000CB   8B83         MOV     DPH,R3
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   14           DEC     A
   \   0000CF   F0           MOVX    @DPTR,A
   \   0000D0   70E8         JNZ     ??gyro_self_test_5
   2074                      st_shift_var = st_shift_cust / st_shift - 1.f;
   2075                      if (fabs(st_shift_var) > test.max_gyro_var)
                                 ^
Warning[Pe223]: function "fabsf" declared implicitly
   \   0000D2                ; Setup parameters for call to function fabsf
   \   0000D2   78..         MOV     R0,#?V0 + 4
   \   0000D4   79..         MOV     R1,#?V0 + 0
   \   0000D6   12....       LCALL   ?FLT_DIV
   \   0000D9   90....       MOV     DPTR,#__Constant_bf800000
   \   0000DC   78..         MOV     R0,#?V0 + 0
   \   0000DE   12....       LCALL   ?L_MOV_X
   \   0000E1   78..         MOV     R0,#?V0 + 4
   \   0000E3   79..         MOV     R1,#?V0 + 0
   \   0000E5   12....       LCALL   ?FLT_ADD
   \   0000E8   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   0000EB   4033         JC      ??gyro_self_test_6
   2076                          result |= 1 << jj;
   \                     ??gyro_self_test_7:
   \   0000ED   75..01       MOV     ?V0 + 0,#0x1
   \   0000F0   75..00       MOV     ?V0 + 1,#0x0
   \   0000F3   EE           MOV     A,R6
   \   0000F4   78..         MOV     R0,#?V0 + 0
   \   0000F6   12....       LCALL   ?S_SHL
   \   0000F9   12....       LCALL   ?Subroutine73 & 0xFFFF
   2077                  } else if ((st_shift_cust < test.min_dps) ||
   \                     ??CrossCallReturnLabel_117:
   \   0000FC   8022         SJMP    ??gyro_self_test_6
   2078                      (st_shift_cust > test.max_dps))
   \                     ??gyro_self_test_3:
   \   0000FE   90....       MOV     DPTR,#__Constant_41200000
   \   000101   78..         MOV     R0,#?V0 + 0
   \   000103   12....       LCALL   ?L_MOV_X
   \   000106   78..         MOV     R0,#?V0 + 4
   \   000108   79..         MOV     R1,#?V0 + 0
   \   00010A   12....       LCALL   ?FLT_LT
   \   00010D   40DE         JC      ??gyro_self_test_7
   \   00010F   90....       MOV     DPTR,#__Constant_42d20001
   \   000112   78..         MOV     R0,#?V0 + 0
   \   000114   12....       LCALL   ?L_MOV_X
   \   000117   78..         MOV     R0,#?V0 + 4
   \   000119   79..         MOV     R1,#?V0 + 0
   \   00011B   12....       LCALL   ?FLT_GE
   \   00011E   40CD         JC      ??gyro_self_test_7
   2079                      result |= 1 << jj;
   2080              }
   \                     ??gyro_self_test_6:
   \   000120   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000123   5003         JNC     $+5
   \   000125   02....       LJMP    ??gyro_self_test_2 & 0xFFFF
   2081              return result;
   \   000128   AA..         MOV     R2,?V0 + 12
   \   00012A   AB..         MOV     R3,?V0 + 13
   \                     ??gyro_self_test_1:
   \   00012C   7405         MOV     A,#0x5
   \   00012E                REQUIRE ?Subroutine6
   \   00012E                ; // Fall through to label ?Subroutine6
   2082          }
   2083          
   2084          #ifdef AK89xx_SECONDARY
   2085          static int compass_self_test(void)
   2086          {
   2087              unsigned char tmp[6];
   2088              unsigned char tries = 10;
   2089              int result = 0x07;
   2090              short data;
   2091          
   2092              mpu_set_bypass(1);
   2093          
   2094              tmp[0] = AKM_POWER_DOWN;
   2095              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2096                  return 0x07;
   2097              tmp[0] = AKM_BIT_SELF_TEST;
   2098              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
   2099                  goto AKM_restore;
   2100              tmp[0] = AKM_MODE_SELF_TEST;
   2101              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2102                  goto AKM_restore;
   2103          
   2104              do {
   2105                  delay_ms(10);
   2106                  if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
   2107                      goto AKM_restore;
   2108                  if (tmp[0] & AKM_DATA_READY)
   2109                      break;
   2110              } while (tries--);
   2111              if (!(tmp[0] & AKM_DATA_READY))
   2112                  goto AKM_restore;
   2113          
   2114              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
   2115                  goto AKM_restore;
   2116          
   2117              result = 0;
   2118              data = (short)(tmp[1] << 8) | tmp[0];
   2119              if ((data > 100) || (data < -100))
   2120                  result |= 0x01;
   2121              data = (short)(tmp[3] << 8) | tmp[2];
   2122              if ((data > 100) || (data < -100))
   2123                  result |= 0x02;
   2124              data = (short)(tmp[5] << 8) | tmp[4];
   2125              if ((data > -300) || (data < -1000))
   2126                  result |= 0x04;
   2127          
   2128          AKM_restore:
   2129              tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
   2130              i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
   2131              tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
   2132              i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
   2133              mpu_set_bypass(0);
   2134              return result;
   2135          }
   2136          #endif
   2137          #endif
   2138          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2139          static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
   \                     get_st_biases:
   2140          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV     A,#-0x1f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740F         MOV     A,#0xf
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   740D         MOV     A,#0xd
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   EC           MOV     A,R4
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   ED           MOV     A,R5
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   E9           MOV     A,R1
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   F0           MOVX    @DPTR,A
   2141              unsigned char data[MAX_PACKET_LENGTH];
   2142              unsigned char packet_count, ii;
   2143              unsigned short fifo_count;
   2144          
   2145              data[0] = 0x01;
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   7401         MOV     A,#0x1
   \   00002D   F0           MOVX    @DPTR,A
   2146              data[1] = 0;
   \   00002E   04           INC     A
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E4           CLR     A
   \   000033   F0           MOVX    @DPTR,A
   2147              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \   000034                ; Setup parameters for call to function I2C_Write
   \   000034   04           INC     A
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   00003B   6007         JZ      ??get_st_biases_0
   2148                  return -1;
   \                     ??get_st_biases_1:
   \   00003D   7AFF         MOV     R2,#-0x1
   \   00003F   7BFF         MOV     R3,#-0x1
   \   000041   02....       LJMP    ??get_st_biases_2 & 0xFFFF
   2149              delay_ms(200);
   \                     ??get_st_biases_0:
   \   000044                ; Setup parameters for call to function delay_ms
   \   000044   7AC8         MOV     R2,#-0x38
   \   000046   7B00         MOV     R3,#0x0
   \   000048   12....       LCALL   ??delay_ms?relay
   2150              data[0] = 0;
   \   00004B   7401         MOV     A,#0x1
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   12....       LCALL   ?Subroutine58 & 0xFFFF
   2151              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \                     ??CrossCallReturnLabel_256:
   \   000053   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000056   70E5         JNZ     ??get_st_biases_1
   2152                  return -1;
   2153              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   000058                ; Setup parameters for call to function I2C_Write
   \   000058   7401         MOV     A,#0x1
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000060   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000063   70D8         JNZ     ??get_st_biases_1
   2154                  return -1;
   2155              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \   000065                ; Setup parameters for call to function I2C_Write
   \   000065   7401         MOV     A,#0x1
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   AC82         MOV     R4,DPL
   \   00006C   AD83         MOV     R5,DPH
   \   00006E   7B01         MOV     R3,#0x1
   \   000070   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000073   70C8         JNZ     ??get_st_biases_1
   2156                  return -1;
   2157              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   \   000075                ; Setup parameters for call to function I2C_Write
   \   000075   7401         MOV     A,#0x1
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   AC82         MOV     R4,DPL
   \   00007C   AD83         MOV     R5,DPH
   \   00007E   7B01         MOV     R3,#0x1
   \   000080   90....       MOV     DPTR,#st
   \   000083   E0           MOVX    A,@DPTR
   \   000084   2417         ADD     A,#0x17
   \   000086   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000089   70B2         JNZ     ??get_st_biases_1
   2158                  return -1;
   2159              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   00008B                ; Setup parameters for call to function I2C_Write
   \   00008B   7401         MOV     A,#0x1
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000093   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000096   70A5         JNZ     ??get_st_biases_1
   2160                  return -1;
   2161              data[0] = BIT_FIFO_RST | BIT_DMP_RST;
   \   000098   7401         MOV     A,#0x1
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   12....       LCALL   ?Subroutine34 & 0xFFFF
   2162              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \                     ??CrossCallReturnLabel_166:
   \   0000A0   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   0000A3   7098         JNZ     ??get_st_biases_1
   2163                  return -1;
   2164              delay_ms(15);
   \   0000A5                ; Setup parameters for call to function delay_ms
   \   0000A5   7A0F         MOV     R2,#0xf
   \   0000A7   7B00         MOV     R3,#0x0
   \   0000A9   12....       LCALL   ??delay_ms?relay
   2165              data[0] = st.test->reg_lpf;
   \   0000AC   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   C0E0         PUSH    A
   \   0000B3   7401         MOV     A,#0x1
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   D0E0         POP     A
   \   0000BA   12....       LCALL   ?Subroutine35 & 0xFFFF
   2166              if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \                     ??CrossCallReturnLabel_202:
   \   0000BD   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   0000C0   6003         JZ      $+5
   \   0000C2   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2167                  return -1;
   2168              data[0] = st.test->reg_rate_div;
   \   0000C5   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   C0E0         PUSH    A
   \   0000CB   7401         MOV     A,#0x1
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   D0E0         POP     A
   \   0000D2   12....       LCALL   ?Subroutine37 & 0xFFFF
   2169              if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
   \                     ??CrossCallReturnLabel_194:
   \   0000D5   A3           INC     DPTR
   \   0000D6   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   0000D9   6003         JZ      $+5
   \   0000DB   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   \   0000DE   90....       MOV     DPTR,#st + 33
   \   0000E1   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000E4   F8           MOV     R0,A
   \   0000E5   85..82       MOV     DPL,?XSP + 0
   \   0000E8   85..83       MOV     DPH,?XSP + 1
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   600E         JZ      ??get_st_biases_3
   2170                  return -1;
   2171              if (hw_test)
   2172                  data[0] = st.test->reg_gyro_fsr | 0xE0;
   \   0000EE   74E0         MOV     A,#-0x20
   \   0000F0   48           ORL     A,R0
   \   0000F1   C0E0         PUSH    A
   \   0000F3   7401         MOV     A,#0x1
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   D0E0         POP     A
   \   0000FA   8006         SJMP    ??get_st_biases_4
   2173              else
   2174                  data[0] = st.test->reg_gyro_fsr;
   \                     ??get_st_biases_3:
   \   0000FC   7401         MOV     A,#0x1
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   E8           MOV     A,R0
   \                     ??get_st_biases_4:
   \   000102   F0           MOVX    @DPTR,A
   2175              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
   \   000103                ; Setup parameters for call to function I2C_Write
   \   000103   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000106   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   000109   6003         JZ      $+5
   \   00010B   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2176                  return -1;
   2177          
   2178              if (hw_test)
   \   00010E   85..82       MOV     DPL,?XSP + 0
   \   000111   85..83       MOV     DPH,?XSP + 1
   \   000114   E0           MOVX    A,@DPTR
   \   000115   6013         JZ      ??get_st_biases_5
   2179                  data[0] = st.test->reg_accel_fsr | 0xE0;
   \   000117   90....       MOV     DPTR,#st + 33
   \   00011A   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00011D   44E0         ORL     A,#0xe0
   \   00011F   C0E0         PUSH    A
   \   000121   7401         MOV     A,#0x1
   \   000123   12....       LCALL   ?XSTACK_DISP0_8
   \   000126   D0E0         POP     A
   \   000128   8007         SJMP    ??get_st_biases_6
   2180              else
   2181                  data[0] = test.reg_accel_fsr;
   \                     ??get_st_biases_5:
   \   00012A   7401         MOV     A,#0x1
   \   00012C   12....       LCALL   ?XSTACK_DISP0_8
   \   00012F   7418         MOV     A,#0x18
   \                     ??get_st_biases_6:
   \   000131   12....       LCALL   ?Subroutine23 & 0xFFFF
   2182              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??CrossCallReturnLabel_214:
   \   000134   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   000137   6003         JZ      $+5
   \   000139   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2183                  return -1;
   2184              if (hw_test)
   \   00013C   85..82       MOV     DPL,?XSP + 0
   \   00013F   85..83       MOV     DPH,?XSP + 1
   \   000142   E0           MOVX    A,@DPTR
   \   000143   6007         JZ      ??get_st_biases_7
   2185                  delay_ms(200);
   \   000145                ; Setup parameters for call to function delay_ms
   \   000145   7AC8         MOV     R2,#-0x38
   \   000147   7B00         MOV     R3,#0x0
   \   000149   12....       LCALL   ??delay_ms?relay
   2186          
   2187              /* Fill FIFO for test.wait_ms milliseconds. */
   2188              data[0] = BIT_FIFO_EN;
   \                     ??get_st_biases_7:
   \   00014C   7401         MOV     A,#0x1
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   7440         MOV     A,#0x40
   \   000153   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   2189              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \                     ??CrossCallReturnLabel_171:
   \   000156   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000159   6003         JZ      $+5
   \   00015B   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2190                  return -1;
   2191          
   2192              data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
   \   00015E   7401         MOV     A,#0x1
   \   000160   12....       LCALL   ?XSTACK_DISP0_8
   \   000163   7478         MOV     A,#0x78
   \   000165   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   2193              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??CrossCallReturnLabel_208:
   \   000168   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   00016B   6003         JZ      $+5
   \   00016D   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2194                  return -1;
   2195              delay_ms(test.wait_ms);
   \   000170                ; Setup parameters for call to function delay_ms
   \   000170   7A32         MOV     R2,#0x32
   \   000172   7B00         MOV     R3,#0x0
   \   000174   12....       LCALL   ??delay_ms?relay
   2196              data[0] = 0;
   \   000177   7401         MOV     A,#0x1
   \   000179   12....       LCALL   ?XSTACK_DISP0_8
   \   00017C   12....       LCALL   ?Subroutine33 & 0xFFFF
   2197              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??CrossCallReturnLabel_207:
   \   00017F   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   000182   6003         JZ      $+5
   \   000184   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2198                  return -1;
   2199          
   2200              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \   000187                ; Setup parameters for call to function I2C_Read
   \   000187   7401         MOV     A,#0x1
   \   000189   12....       LCALL   ?XSTACK_DISP0_8
   \   00018C   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   00018F   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000192   6003         JZ      $+5
   \   000194   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2201                  return -1;
   2202          
   2203              fifo_count = (data[0] << 8) | data[1];
   2204              packet_count = fifo_count / MAX_PACKET_LENGTH;
   \   000197   7401         MOV     A,#0x1
   \   000199   12....       LCALL   ?XSTACK_DISP0_8
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   F9           MOV     R1,A
   \   00019E   7402         MOV     A,#0x2
   \   0001A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   F8           MOV     R0,A
   \   0001A5   7A0C         MOV     R2,#0xc
   \   0001A7   7B00         MOV     R3,#0x0
   \   0001A9   12....       LCALL   ?US_DIV_MOD
   \   0001AC   E8           MOV     A,R0
   \   0001AD   F5..         MOV     ?V0 + 0,A
   2205              gyro[0] = gyro[1] = gyro[2] = 0;
   \   0001AF   740F         MOV     A,#0xf
   \   0001B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   2408         ADD     A,#0x8
   \   0001B7   F5..         MOV     ?V0 + 14,A
   \   0001B9   A3           INC     DPTR
   \   0001BA   E0           MOVX    A,@DPTR
   \   0001BB   3400         ADDC    A,#0x0
   \   0001BD   F5..         MOV     ?V0 + 15,A
   \   0001BF   90....       MOV     DPTR,#__Constant_0
   \   0001C2   12....       LCALL   ?XLOAD_R2345
   \   0001C5   85..82       MOV     DPL,?V0 + 14
   \   0001C8   85..83       MOV     DPH,?V0 + 15
   \   0001CB   12....       LCALL   ?XSTORE_R2345
   \   0001CE   740F         MOV     A,#0xf
   \   0001D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   2404         ADD     A,#0x4
   \   0001D6   F5..         MOV     ?V0 + 12,A
   \   0001D8   A3           INC     DPTR
   \   0001D9   E0           MOVX    A,@DPTR
   \   0001DA   3400         ADDC    A,#0x0
   \   0001DC   F5..         MOV     ?V0 + 13,A
   \   0001DE   90....       MOV     DPTR,#__Constant_0
   \   0001E1   12....       LCALL   ?XLOAD_R2345
   \   0001E4   85..82       MOV     DPL,?V0 + 12
   \   0001E7   85..83       MOV     DPH,?V0 + 13
   \   0001EA   12....       LCALL   ?XSTORE_R2345
   \   0001ED   90....       MOV     DPTR,#__Constant_0
   \   0001F0   12....       LCALL   ?XLOAD_R2345
   \   0001F3   740F         MOV     A,#0xf
   \   0001F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F8   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   0001FB   12....       LCALL   ?XSTORE_R2345
   2206              accel[0] = accel[1] = accel[2] = 0;
   \   0001FE   740D         MOV     A,#0xd
   \   000200   12....       LCALL   ?XSTACK_DISP0_8
   \   000203   E0           MOVX    A,@DPTR
   \   000204   2408         ADD     A,#0x8
   \   000206   FE           MOV     R6,A
   \   000207   A3           INC     DPTR
   \   000208   E0           MOVX    A,@DPTR
   \   000209   3400         ADDC    A,#0x0
   \   00020B   FF           MOV     R7,A
   \   00020C   90....       MOV     DPTR,#__Constant_0
   \   00020F   12....       LCALL   ?XLOAD_R2345
   \   000212   8E82         MOV     DPL,R6
   \   000214   8F83         MOV     DPH,R7
   \   000216   12....       LCALL   ?XSTORE_R2345
   \   000219   740D         MOV     A,#0xd
   \   00021B   12....       LCALL   ?XSTACK_DISP0_8
   \   00021E   E0           MOVX    A,@DPTR
   \   00021F   2404         ADD     A,#0x4
   \   000221   F8           MOV     R0,A
   \   000222   A3           INC     DPTR
   \   000223   E0           MOVX    A,@DPTR
   \   000224   3400         ADDC    A,#0x0
   \   000226   F9           MOV     R1,A
   \   000227   7411         MOV     A,#0x11
   \   000229   12....       LCALL   ?XSTACK_DISP0_8
   \   00022C   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   00022F   90....       MOV     DPTR,#__Constant_0
   \   000232   12....       LCALL   ?XLOAD_R2345
   \   000235   7411         MOV     A,#0x11
   \   000237   12....       LCALL   ?XSTACK_DISP0_8
   \   00023A   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   00023D   12....       LCALL   ?XSTORE_R2345
   \   000240   90....       MOV     DPTR,#__Constant_0
   \   000243   12....       LCALL   ?XLOAD_R2345
   \   000246   740D         MOV     A,#0xd
   \   000248   12....       LCALL   ?XSTACK_DISP0_8
   \   00024B   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   00024E   12....       LCALL   ?XSTORE_R2345
   2207          
   2208              for (ii = 0; ii < packet_count; ii++) {
   \   000251   75..00       MOV     ?V0 + 1,#0x0
   \   000254   02....       LJMP    ??get_st_biases_8 & 0xFFFF
   2209                  short accel_cur[3], gyro_cur[3];
   2210                  if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
   \                     ??get_st_biases_9:
   \   000257                ; Setup parameters for call to function I2C_Read
   \   000257   7401         MOV     A,#0x1
   \   000259   12....       LCALL   ?XSTACK_DISP0_8
   \   00025C   AC82         MOV     R4,DPL
   \   00025E   AD83         MOV     R5,DPH
   \   000260   7B0C         MOV     R3,#0xc
   \   000262   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000265   8B..         MOV     ?V0 + 3,R3
   \   000267   EA           MOV     A,R2
   \   000268   45..         ORL     A,?V0 + 3
   \   00026A   6003         JZ      $+5
   \   00026C   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2211                      return -1;
   2212                  accel_cur[0] = ((short)data[0] << 8) | data[1];
   \   00026F   7401         MOV     A,#0x1
   \   000271   12....       LCALL   ?XSTACK_DISP0_8
   \   000274   E0           MOVX    A,@DPTR
   \   000275   F9           MOV     R1,A
   \   000276   7402         MOV     A,#0x2
   \   000278   12....       LCALL   ?XSTACK_DISP0_8
   \   00027B   E0           MOVX    A,@DPTR
   \   00027C   F8           MOV     R0,A
   \   00027D   7419         MOV     A,#0x19
   \   00027F   12....       LCALL   ?XSTACK_DISP0_8
   \   000282   12....       LCALL   ?Subroutine66 & 0xFFFF
   2213                  accel_cur[1] = ((short)data[2] << 8) | data[3];
   \                     ??CrossCallReturnLabel_163:
   \   000285   7403         MOV     A,#0x3
   \   000287   12....       LCALL   ?XSTACK_DISP0_8
   \   00028A   E0           MOVX    A,@DPTR
   \   00028B   F9           MOV     R1,A
   \   00028C   7404         MOV     A,#0x4
   \   00028E   12....       LCALL   ?XSTACK_DISP0_8
   \   000291   E0           MOVX    A,@DPTR
   \   000292   FC           MOV     R4,A
   \   000293   E9           MOV     A,R1
   \   000294   FD           MOV     R5,A
   \   000295   741B         MOV     A,#0x1b
   \   000297   12....       LCALL   ?XSTACK_DISP0_8
   \   00029A   EC           MOV     A,R4
   \   00029B   F0           MOVX    @DPTR,A
   \   00029C   A3           INC     DPTR
   \   00029D   ED           MOV     A,R5
   \   00029E   F0           MOVX    @DPTR,A
   2214                  accel_cur[2] = ((short)data[4] << 8) | data[5];
   \   00029F   7405         MOV     A,#0x5
   \   0002A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A4   E0           MOVX    A,@DPTR
   \   0002A5   F9           MOV     R1,A
   \   0002A6   7406         MOV     A,#0x6
   \   0002A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AB   E0           MOVX    A,@DPTR
   \   0002AC   FA           MOV     R2,A
   \   0002AD   E9           MOV     A,R1
   \   0002AE   FB           MOV     R3,A
   \   0002AF   741D         MOV     A,#0x1d
   \   0002B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B4   EA           MOV     A,R2
   \   0002B5   F0           MOVX    @DPTR,A
   \   0002B6   A3           INC     DPTR
   \   0002B7   EB           MOV     A,R3
   \   0002B8   F0           MOVX    @DPTR,A
   2215                  accel[0] += (long)accel_cur[0];
   \   0002B9   7419         MOV     A,#0x19
   \   0002BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BE   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0002C1   740D         MOV     A,#0xd
   \   0002C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C6   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0002C9   12....       LCALL   ?L_ADD_TO_X
   2216                  accel[1] += (long)accel_cur[1];
   \   0002CC   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   0002CF   7411         MOV     A,#0x11
   \   0002D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D4   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0002D7   12....       LCALL   ?L_ADD_TO_X
   2217                  accel[2] += (long)accel_cur[2];
   \   0002DA   8A..         MOV     ?V0 + 4,R2
   \   0002DC   EB           MOV     A,R3
   \   0002DD   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   0002E0   8E82         MOV     DPL,R6
   \   0002E2   8F83         MOV     DPH,R7
   \   0002E4   78..         MOV     R0,#?V0 + 4
   \   0002E6   12....       LCALL   ?L_ADD_TO_X
   2218                  gyro_cur[0] = (((short)data[6] << 8) | data[7]);
   \   0002E9   7407         MOV     A,#0x7
   \   0002EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002EE   E0           MOVX    A,@DPTR
   \   0002EF   F9           MOV     R1,A
   \   0002F0   7408         MOV     A,#0x8
   \   0002F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F5   E0           MOVX    A,@DPTR
   \   0002F6   F8           MOV     R0,A
   \   0002F7   7413         MOV     A,#0x13
   \   0002F9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002FC   12....       LCALL   ?Subroutine66 & 0xFFFF
   2219                  gyro_cur[1] = (((short)data[8] << 8) | data[9]);
   \                     ??CrossCallReturnLabel_164:
   \   0002FF   7409         MOV     A,#0x9
   \   000301   12....       LCALL   ?XSTACK_DISP0_8
   \   000304   E0           MOVX    A,@DPTR
   \   000305   F9           MOV     R1,A
   \   000306   740A         MOV     A,#0xa
   \   000308   12....       LCALL   ?XSTACK_DISP0_8
   \   00030B   E0           MOVX    A,@DPTR
   \   00030C   FC           MOV     R4,A
   \   00030D   E9           MOV     A,R1
   \   00030E   FD           MOV     R5,A
   \   00030F   7415         MOV     A,#0x15
   \   000311   12....       LCALL   ?XSTACK_DISP0_8
   \   000314   EC           MOV     A,R4
   \   000315   F0           MOVX    @DPTR,A
   \   000316   A3           INC     DPTR
   \   000317   ED           MOV     A,R5
   \   000318   F0           MOVX    @DPTR,A
   2220                  gyro_cur[2] = (((short)data[10] << 8) | data[11]);
   \   000319   740B         MOV     A,#0xb
   \   00031B   12....       LCALL   ?XSTACK_DISP0_8
   \   00031E   E0           MOVX    A,@DPTR
   \   00031F   F9           MOV     R1,A
   \   000320   740C         MOV     A,#0xc
   \   000322   12....       LCALL   ?XSTACK_DISP0_8
   \   000325   E0           MOVX    A,@DPTR
   \   000326   FA           MOV     R2,A
   \   000327   E9           MOV     A,R1
   \   000328   FB           MOV     R3,A
   \   000329   7417         MOV     A,#0x17
   \   00032B   12....       LCALL   ?XSTACK_DISP0_8
   \   00032E   EA           MOV     A,R2
   \   00032F   F0           MOVX    @DPTR,A
   \   000330   A3           INC     DPTR
   \   000331   EB           MOV     A,R3
   \   000332   F0           MOVX    @DPTR,A
   2221                  gyro[0] += (long)gyro_cur[0];
   \   000333   7413         MOV     A,#0x13
   \   000335   12....       LCALL   ?XSTACK_DISP0_8
   \   000338   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00033B   740F         MOV     A,#0xf
   \   00033D   12....       LCALL   ?XSTACK_DISP0_8
   \   000340   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000343   12....       LCALL   ?L_ADD_TO_X
   2222                  gyro[1] += (long)gyro_cur[1];
   \   000346   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000349   85..82       MOV     DPL,?V0 + 12
   \   00034C   85..83       MOV     DPH,?V0 + 13
   \   00034F   78..         MOV     R0,#?V0 + 4
   \   000351   12....       LCALL   ?L_ADD_TO_X
   2223                  gyro[2] += (long)gyro_cur[2];
   \   000354   8A..         MOV     ?V0 + 4,R2
   \   000356   EB           MOV     A,R3
   \   000357   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   2224              }
   \                     ??CrossCallReturnLabel_190:
   \   00035A   85..82       MOV     DPL,?V0 + 14
   \   00035D   85..83       MOV     DPH,?V0 + 15
   \   000360   78..         MOV     R0,#?V0 + 4
   \   000362   12....       LCALL   ?L_ADD_TO_X
   \   000365   05..         INC     ?V0 + 1
   \                     ??get_st_biases_8:
   \   000367   E5..         MOV     A,?V0 + 1
   \   000369   C3           CLR     C
   \   00036A   95..         SUBB    A,?V0 + 0
   \   00036C   5003         JNC     $+5
   \   00036E   02....       LJMP    ??get_st_biases_9 & 0xFFFF
   2225          #ifdef EMPL_NO_64BIT
   2226              gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
   2227              gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
   2228              gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
   2229              if (has_accel) {
   2230                  accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
   2231                      packet_count);
   2232                  accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
   2233                      packet_count);
   2234                  accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
   2235                      packet_count);
   2236                  /* Don't remove gravity! */
   2237                  accel[2] -= 65536L;
   2238              }
   2239          #else
   2240              gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
   \   000371   E5..         MOV     A,?V0 + 0
   \   000373   F5..         MOV     ?V0 + 4,A
   \   000375   E4           CLR     A
   \   000376   F5..         MOV     ?V0 + 5,A
   \   000378   F5..         MOV     ?V0 + 6,A
   \   00037A   F5..         MOV     ?V0 + 7,A
   \   00037C   740F         MOV     A,#0xf
   \   00037E   12....       LCALL   ?XSTACK_DISP0_8
   \   000381   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000384   78..         MOV     R0,#?V0 + 0
   \   000386   12....       LCALL   ?L_MOV_X
   \   000389   7410         MOV     A,#0x10
   \   00038B   78..         MOV     R0,#?V0 + 0
   \   00038D   12....       LCALL   ?L_SHL
   \   000390   90....       MOV     DPTR,#__Constant_83
   \   000393   78..         MOV     R0,#?V0 + 8
   \   000395   12....       LCALL   ?L_MOV_X
   \   000398   78..         MOV     R0,#?V0 + 0
   \   00039A   79..         MOV     R1,#?V0 + 8
   \   00039C   12....       LCALL   ?UL_DIV_MOD
   \   00039F   85....       MOV     ?V0 + 8,?V0 + 4
   \   0003A2   85....       MOV     ?V0 + 9,?V0 + 5
   \   0003A5   85....       MOV     ?V0 + 10,?V0 + 6
   \   0003A8   85....       MOV     ?V0 + 11,?V0 + 7
   \   0003AB   78..         MOV     R0,#?V0 + 0
   \   0003AD   79..         MOV     R1,#?V0 + 8
   \   0003AF   12....       LCALL   ?UL_DIV_MOD
   \   0003B2   740F         MOV     A,#0xf
   \   0003B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B7   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   0003BA   78..         MOV     R0,#?V0 + 0
   \   0003BC   12....       LCALL   ?L_MOV_TO_X
   2241              gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
   \   0003BF   85..82       MOV     DPL,?V0 + 12
   \   0003C2   85..83       MOV     DPH,?V0 + 13
   \   0003C5   78..         MOV     R0,#?V0 + 0
   \   0003C7   12....       LCALL   ?L_MOV_X
   \   0003CA   7410         MOV     A,#0x10
   \   0003CC   78..         MOV     R0,#?V0 + 0
   \   0003CE   12....       LCALL   ?L_SHL
   \   0003D1   90....       MOV     DPTR,#__Constant_83
   \   0003D4   78..         MOV     R0,#?V0 + 8
   \   0003D6   12....       LCALL   ?L_MOV_X
   \   0003D9   78..         MOV     R0,#?V0 + 0
   \   0003DB   79..         MOV     R1,#?V0 + 8
   \   0003DD   12....       LCALL   ?UL_DIV_MOD
   \   0003E0   85....       MOV     ?V0 + 8,?V0 + 4
   \   0003E3   85....       MOV     ?V0 + 9,?V0 + 5
   \   0003E6   85....       MOV     ?V0 + 10,?V0 + 6
   \   0003E9   85....       MOV     ?V0 + 11,?V0 + 7
   \   0003EC   78..         MOV     R0,#?V0 + 0
   \   0003EE   79..         MOV     R1,#?V0 + 8
   \   0003F0   12....       LCALL   ?UL_DIV_MOD
   \   0003F3   85..82       MOV     DPL,?V0 + 12
   \   0003F6   85..83       MOV     DPH,?V0 + 13
   \   0003F9   78..         MOV     R0,#?V0 + 0
   \   0003FB   12....       LCALL   ?L_MOV_TO_X
   2242              gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
   \   0003FE   85..82       MOV     DPL,?V0 + 14
   \   000401   85..83       MOV     DPH,?V0 + 15
   \   000404   78..         MOV     R0,#?V0 + 0
   \   000406   12....       LCALL   ?L_MOV_X
   \   000409   7410         MOV     A,#0x10
   \   00040B   78..         MOV     R0,#?V0 + 0
   \   00040D   12....       LCALL   ?L_SHL
   \   000410   90....       MOV     DPTR,#__Constant_83
   \   000413   78..         MOV     R0,#?V0 + 8
   \   000415   12....       LCALL   ?L_MOV_X
   \   000418   78..         MOV     R0,#?V0 + 0
   \   00041A   79..         MOV     R1,#?V0 + 8
   \   00041C   12....       LCALL   ?UL_DIV_MOD
   \   00041F   85....       MOV     ?V0 + 8,?V0 + 4
   \   000422   85....       MOV     ?V0 + 9,?V0 + 5
   \   000425   85....       MOV     ?V0 + 10,?V0 + 6
   \   000428   85....       MOV     ?V0 + 11,?V0 + 7
   \   00042B   78..         MOV     R0,#?V0 + 0
   \   00042D   79..         MOV     R1,#?V0 + 8
   \   00042F   12....       LCALL   ?UL_DIV_MOD
   \   000432   85..82       MOV     DPL,?V0 + 14
   \   000435   85..83       MOV     DPH,?V0 + 15
   \   000438   78..         MOV     R0,#?V0 + 0
   \   00043A   12....       LCALL   ?L_MOV_TO_X
   2243              accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
   2244                  packet_count);
   \   00043D   740D         MOV     A,#0xd
   \   00043F   12....       LCALL   ?XSTACK_DISP0_8
   \   000442   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000445   12....       LCALL   ?L_MOV_X
   \   000448   7410         MOV     A,#0x10
   \   00044A   78..         MOV     R0,#?V0 + 8
   \   00044C   12....       LCALL   ?L_SHL
   \   00044F   740B         MOV     A,#0xb
   \   000451   78..         MOV     R0,#?V0 + 8
   \   000453   12....       LCALL   ?UL_SHR
   \   000456   85....       MOV     ?V0 + 0,?V0 + 4
   \   000459   F5..         MOV     ?V0 + 1,A
   \   00045B   F5..         MOV     ?V0 + 2,A
   \   00045D   F5..         MOV     ?V0 + 3,A
   \   00045F   78..         MOV     R0,#?V0 + 8
   \   000461   79..         MOV     R1,#?V0 + 0
   \   000463   12....       LCALL   ?UL_DIV_MOD
   \   000466   740D         MOV     A,#0xd
   \   000468   12....       LCALL   ?XSTACK_DISP0_8
   \   00046B   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   00046E   12....       LCALL   ?L_MOV_TO_X
   2245              accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
   2246                  packet_count);
   \   000471   7411         MOV     A,#0x11
   \   000473   12....       LCALL   ?XSTACK_DISP0_8
   \   000476   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000479   12....       LCALL   ?L_MOV_X
   \   00047C   7410         MOV     A,#0x10
   \   00047E   78..         MOV     R0,#?V0 + 8
   \   000480   12....       LCALL   ?L_SHL
   \   000483   740B         MOV     A,#0xb
   \   000485   78..         MOV     R0,#?V0 + 8
   \   000487   12....       LCALL   ?UL_SHR
   \   00048A   85....       MOV     ?V0 + 0,?V0 + 4
   \   00048D   F5..         MOV     ?V0 + 1,A
   \   00048F   F5..         MOV     ?V0 + 2,A
   \   000491   F5..         MOV     ?V0 + 3,A
   \   000493   78..         MOV     R0,#?V0 + 8
   \   000495   79..         MOV     R1,#?V0 + 0
   \   000497   12....       LCALL   ?UL_DIV_MOD
   \   00049A   7411         MOV     A,#0x11
   \   00049C   12....       LCALL   ?XSTACK_DISP0_8
   \   00049F   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   0004A2   12....       LCALL   ?L_MOV_TO_X
   2247              accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
   2248                  packet_count);
   \   0004A5   8E82         MOV     DPL,R6
   \   0004A7   8F83         MOV     DPH,R7
   \   0004A9   78..         MOV     R0,#?V0 + 0
   \   0004AB   12....       LCALL   ?L_MOV_X
   \   0004AE   7410         MOV     A,#0x10
   \   0004B0   78..         MOV     R0,#?V0 + 0
   \   0004B2   12....       LCALL   ?L_SHL
   \   0004B5   740B         MOV     A,#0xb
   \   0004B7   78..         MOV     R0,#?V0 + 0
   \   0004B9   12....       LCALL   ?UL_SHR
   \   0004BC   78..         MOV     R0,#?V0 + 0
   \   0004BE   79..         MOV     R1,#?V0 + 4
   \   0004C0   12....       LCALL   ?UL_DIV_MOD
   \   0004C3   8E82         MOV     DPL,R6
   \   0004C5   8F83         MOV     DPH,R7
   \   0004C7   78..         MOV     R0,#?V0 + 0
   \   0004C9   12....       LCALL   ?L_MOV_TO_X
   2249              /* Don't remove gravity! */
   2250              if (accel[2] > 0L)
   \   0004CC   90....       MOV     DPTR,#__Constant_1
   \   0004CF   78..         MOV     R0,#?V0 + 0
   \   0004D1   12....       LCALL   ?L_MOV_X
   \   0004D4   8F83         MOV     DPH,R7
   \   0004D6   8E82         MOV     DPL,R6
   \   0004D8   78..         MOV     R0,#?V0 + 0
   \   0004DA   12....       LCALL   ?SL_GT_X
   \   0004DD   4005         JC      ??get_st_biases_10
   2251                  accel[2] -= 65536L;
   \   0004DF   90....       MOV     DPTR,#__Constant_ffff0000
   \   0004E2   8003         SJMP    ??get_st_biases_11
   2252              else
   2253                  accel[2] += 65536L;
   \                     ??get_st_biases_10:
   \   0004E4   90....       MOV     DPTR,#__Constant_10000
   \                     ??get_st_biases_11:
   \   0004E7   78..         MOV     R0,#?V0 + 0
   \   0004E9   12....       LCALL   ?L_MOV_X
   \   0004EC   8E82         MOV     DPL,R6
   \   0004EE   8F83         MOV     DPH,R7
   \   0004F0   78..         MOV     R0,#?V0 + 0
   \   0004F2   12....       LCALL   ?L_ADD_TO_X
   2254          #endif
   2255          
   2256              return 0;
   \   0004F5   7A00         MOV     R2,#0x0
   \   0004F7   7B00         MOV     R3,#0x0
   \                     ??get_st_biases_2:
   \   0004F9   741F         MOV     A,#0x1f
   \   0004FB   02....       LJMP    ?Subroutine6 & 0xFFFF
   2257          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   8C..         MOV     ?V0 + 4,R4
   \   000002   ED           MOV     A,R5
   \   000003                REQUIRE ??Subroutine118_0
   \   000003                ; // Fall through to label ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                REQUIRE ??Subroutine120_0
   \   000001                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                REQUIRE ??Subroutine124_0
   \   000001                ; // Fall through to label ??Subroutine124_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   90....       MOV     DPTR,#st + 33
   \   000003                REQUIRE ??Subroutine125_0
   \   000003                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000003   78..         MOV     R0,#?V0 + 8
   \   000005   22           RET
   2258          
   2259          /**
   2260           *  @brief      Trigger gyro/accel/compass self-test.
   2261           *  On success/error, the self-test returns a mask representing the sensor(s)
   2262           *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
   2263           *  a zero (0) indicates a failure.
   2264           *
   2265           *  \n The mask is defined as follows:
   2266           *  \n Bit 0:   Gyro.
   2267           *  \n Bit 1:   Accel.
   2268           *  \n Bit 2:   Compass.
   2269           *
   2270           *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
   2271           *  this function can still be used to obtain the accel and gyro biases.
   2272           *
   2273           *  \n This function must be called with the device either face-up or face-down
   2274           *  (z-axis is parallel to gravity).
   2275           *  @param[out] gyro        Gyro biases in q16 format.
   2276           *  @param[out] accel       Accel biases (if applicable) in q16 format.
   2277           *  @return     Result mask (see above).
   2278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2279          int mpu_run_self_test(long *gyro, long *accel)
   \                     mpu_run_self_test:
   2280          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   2281          #ifdef MPU6050
   2282              const unsigned char tries = 2;
   2283              long gyro_st[3], accel_st[3];
   2284              unsigned char accel_result, gyro_result;
   2285          #ifdef AK89xx_SECONDARY
   2286              unsigned char compass_result;
   2287          #endif
   2288              int ii;
   2289          #endif
   2290              int result;
   2291              unsigned char accel_fsr, fifo_sensors, sensors_on;
   2292              unsigned short gyro_fsr, sample_rate, lpf;
   2293              unsigned char dmp_was_on;
   2294          
   2295              if (st.chip_cfg.dmp_on) {
   \   000012   90....       MOV     DPTR,#st + 29
   \   000015   E0           MOVX    A,@DPTR
   \   000016   600A         JZ      ??mpu_run_self_test_0
   2296                  mpu_set_dmp_state(0);
   \   000018                ; Setup parameters for call to function mpu_set_dmp_state
   \   000018   7900         MOV     R1,#0x0
   \   00001A   12....       LCALL   ??mpu_set_dmp_state?relay
   2297                  dmp_was_on = 1;
   \   00001D   75..01       MOV     ?V0 + 0,#0x1
   \   000020   8003         SJMP    ??mpu_run_self_test_1
   2298              } else
   2299                  dmp_was_on = 0;
   \                     ??mpu_run_self_test_0:
   \   000022   75..00       MOV     ?V0 + 0,#0x0
   2300          
   2301              /* Get initial settings. */
   2302              mpu_get_gyro_fsr(&gyro_fsr);
   \                     ??mpu_run_self_test_1:
   \   000025                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000025   7406         MOV     A,#0x6
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   AA82         MOV     R2,DPL
   \   00002C   AB83         MOV     R3,DPH
   \   00002E   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2303              mpu_get_accel_fsr(&accel_fsr);
   \   000031                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000031   7401         MOV     A,#0x1
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   12....       LCALL   ??mpu_get_accel_fsr?relay
   2304              mpu_get_lpf(&lpf);
   \   00003D                ; Setup parameters for call to function mpu_get_lpf
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   AA82         MOV     R2,DPL
   \   000044   AB83         MOV     R3,DPH
   \   000046   12....       LCALL   ??mpu_get_lpf?relay
   2305              mpu_get_sample_rate(&sample_rate);
   \   000049                ; Setup parameters for call to function mpu_get_sample_rate
   \   000049   7404         MOV     A,#0x4
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   AA82         MOV     R2,DPL
   \   000050   AB83         MOV     R3,DPH
   \   000052   12....       LCALL   ??mpu_get_sample_rate?relay
   2306              sensors_on = st.chip_cfg.sensors;
   \   000055   90....       MOV     DPTR,#st + 6
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5..         MOV     ?V0 + 1,A
   2307              mpu_get_fifo_config(&fifo_sensors);
   \   00005B                ; Setup parameters for call to function mpu_get_fifo_config
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   ??mpu_get_fifo_config?relay
   2308          
   2309              /* For older chips, the self-test will be different. */
   2310          #if defined MPU6050
   2311              for (ii = 0; ii < tries; ii++)
   \   000068   7E00         MOV     R6,#0x0
   \   00006A   7F00         MOV     R7,#0x0
   2312                  if (!get_st_biases(gyro, accel, 0))
   \                     ??mpu_run_self_test_2:
   \   00006C                ; Setup parameters for call to function get_st_biases
   \   00006C   7900         MOV     R1,#0x0
   \   00006E   AC..         MOV     R4,?V0 + 2
   \   000070   AD..         MOV     R5,?V0 + 3
   \   000072   AA..         MOV     R2,?V0 + 4
   \   000074   AB..         MOV     R3,?V0 + 5
   \   000076   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000079   6005         JZ      ??mpu_run_self_test_3
   \   00007B   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00007E   40EC         JC      ??mpu_run_self_test_2
   2313                      break;
   2314              if (ii == tries) {
   \                     ??mpu_run_self_test_3:
   \   000080   7402         MOV     A,#0x2
   \   000082   6E           XRL     A,R6
   \   000083   7001         JNZ     ??mpu_run_self_test_4
   \   000085   EF           MOV     A,R7
   \                     ??mpu_run_self_test_4:
   \   000086   7004         JNZ     ??mpu_run_self_test_5
   2315                  /* If we reach this point, we most likely encountered an I2C error.
   2316                   * We'll just report an error for all three sensors.
   2317                   */
   2318                  result = 0;
   \                     ??mpu_run_self_test_6:
   \   000088   7E00         MOV     R6,#0x0
   2319                  goto restore;
   \   00008A   805B         SJMP    ??mpu_run_self_test_7
   2320              }
   2321              for (ii = 0; ii < tries; ii++)
   \                     ??mpu_run_self_test_5:
   \   00008C   7E00         MOV     R6,#0x0
   \   00008E   7F00         MOV     R7,#0x0
   2322                  if (!get_st_biases(gyro_st, accel_st, 1))
   \                     ??mpu_run_self_test_8:
   \   000090                ; Setup parameters for call to function get_st_biases
   \   000090   7901         MOV     R1,#0x1
   \   000092   7408         MOV     A,#0x8
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   AC82         MOV     R4,DPL
   \   000099   AD83         MOV     R5,DPH
   \   00009B   7414         MOV     A,#0x14
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   0000A7   6005         JZ      ??mpu_run_self_test_9
   \   0000A9   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0000AC   40E2         JC      ??mpu_run_self_test_8
   2323                      break;
   2324              if (ii == tries) {
   \                     ??mpu_run_self_test_9:
   \   0000AE   7402         MOV     A,#0x2
   \   0000B0   6E           XRL     A,R6
   \   0000B1   7001         JNZ     ??mpu_run_self_test_10
   \   0000B3   EF           MOV     A,R7
   \                     ??mpu_run_self_test_10:
   \   0000B4   60D2         JZ      ??mpu_run_self_test_6
   2325                  /* Again, probably an I2C error. */
   2326                  result = 0;
   2327                  goto restore;
   2328              }
   2329              accel_result = accel_self_test(accel, accel_st);
   \   0000B6                ; Setup parameters for call to function accel_self_test
   \   0000B6   7408         MOV     A,#0x8
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   AC82         MOV     R4,DPL
   \   0000BD   AD83         MOV     R5,DPH
   \   0000BF   AA..         MOV     R2,?V0 + 2
   \   0000C1   AB..         MOV     R3,?V0 + 3
   \   0000C3   12....       LCALL   ??accel_self_test?relay
   \   0000C6   EA           MOV     A,R2
   \   0000C7   F5..         MOV     ?V0 + 2,A
   2330              gyro_result = gyro_self_test(gyro, gyro_st);
   \   0000C9                ; Setup parameters for call to function gyro_self_test
   \   0000C9   7414         MOV     A,#0x14
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   AC82         MOV     R4,DPL
   \   0000D0   AD83         MOV     R5,DPH
   \   0000D2   AA..         MOV     R2,?V0 + 4
   \   0000D4   AB..         MOV     R3,?V0 + 5
   \   0000D6   12....       LCALL   ??gyro_self_test?relay
   2331          
   2332              result = 0;
   \   0000D9   7E00         MOV     R6,#0x0
   2333              if (!gyro_result)
   \   0000DB   EA           MOV     A,R2
   \   0000DC   7001         JNZ     ??mpu_run_self_test_11
   2334                  result |= 0x01;
   \   0000DE   0E           INC     R6
   2335              if (!accel_result)
   \                     ??mpu_run_self_test_11:
   \   0000DF   E5..         MOV     A,?V0 + 2
   \   0000E1   7004         JNZ     ??mpu_run_self_test_7
   2336                  result |= 0x02;
   \   0000E3   7402         MOV     A,#0x2
   \   0000E5   4E           ORL     A,R6
   \   0000E6   FE           MOV     R6,A
   2337          
   2338          #ifdef AK89xx_SECONDARY
   2339              compass_result = compass_self_test();
   2340              if (!compass_result)
   2341                  result |= 0x04;
   2342          #endif
   2343          restore:
   2344          #elif defined MPU6500
   2345              /* For now, this function will return a "pass" result for all three sensors
   2346               * for compatibility with current test applications.
   2347               */
   2348              get_st_biases(gyro, accel, 0);
   2349              result = 0x7;
   2350          #endif
   2351              /* Set to invalid values to ensure no I2C writes are skipped. */
   2352              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_run_self_test_7:
   \   0000E7   12....       LCALL   ?Subroutine59 & 0xFFFF
   2353              st.chip_cfg.accel_fsr = 0xFF;
   2354              st.chip_cfg.lpf = 0xFF;
   2355              st.chip_cfg.sample_rate = 0xFFFF;
   2356              st.chip_cfg.sensors = 0xFF;
   2357              st.chip_cfg.fifo_enable = 0xFF;
   2358              st.chip_cfg.clk_src = INV_CLK_PLL;
   2359              mpu_set_gyro_fsr(gyro_fsr);
   \                     ??CrossCallReturnLabel_92:
   \   0000EA                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   0000EA   7406         MOV     A,#0x6
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   12....       LCALL   ?Subroutine49 & 0xFFFF
   2360              mpu_set_accel_fsr(accel_fsr);
   \                     ??CrossCallReturnLabel_73:
   \   0000F2                ; Setup parameters for call to function mpu_set_accel_fsr
   \   0000F2   7401         MOV     A,#0x1
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   F9           MOV     R1,A
   \   0000F9   12....       LCALL   ??mpu_set_accel_fsr?relay
   2361              mpu_set_lpf(lpf);
   \   0000FC                ; Setup parameters for call to function mpu_set_lpf
   \   0000FC   7402         MOV     A,#0x2
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   12....       LCALL   ?Subroutine50 & 0xFFFF
   2362              mpu_set_sample_rate(sample_rate);
   \                     ??CrossCallReturnLabel_75:
   \   000104                ; Setup parameters for call to function mpu_set_sample_rate
   \   000104   7404         MOV     A,#0x4
   \   000106   12....       LCALL   ?XSTACK_DISP0_8
   \   000109   12....       LCALL   ?Subroutine38 & 0xFFFF
   2363              mpu_set_sensors(sensors_on);
   \                     ??CrossCallReturnLabel_42:
   \   00010C                ; Setup parameters for call to function mpu_set_sensors
   \   00010C   A9..         MOV     R1,?V0 + 1
   \   00010E   12....       LCALL   ??mpu_set_sensors?relay
   2364              mpu_configure_fifo(fifo_sensors);
   \   000111                ; Setup parameters for call to function mpu_configure_fifo
   \   000111   85..82       MOV     DPL,?XSP + 0
   \   000114   85..83       MOV     DPH,?XSP + 1
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F9           MOV     R1,A
   \   000119   12....       LCALL   ??mpu_configure_fifo?relay
   2365          
   2366              if (dmp_was_on)
   \   00011C   E5..         MOV     A,?V0 + 0
   \   00011E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000120   5005         JNC     ??mpu_run_self_test_12
   2367                  mpu_set_dmp_state(1);
   \   000122                ; Setup parameters for call to function mpu_set_dmp_state
   \   000122   7901         MOV     R1,#0x1
   \   000124   12....       LCALL   ??mpu_set_dmp_state?relay
   2368          
   2369              return result;
   \                     ??mpu_run_self_test_12:
   \   000127   EE           MOV     A,R6
   \   000128   FA           MOV     R2,A
   \   000129   7B00         MOV     R3,#0x0
   \   00012B   7420         MOV     A,#0x20
   \   00012D   02....       LJMP    ??Subroutine105_0 & 0xFFFF
   2370          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ??get_st_biases?relay
   \   000003   8B..         MOV     ?V0 + 7,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003   9402         SUBB    A,#0x2
   \   000005   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000003   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   90....       MOV     DPTR,#st + 4
   \   000003   74FF         MOV     A,#-0x1
   \   000005   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000008   90....       MOV     DPTR,#st + 6
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   90....       MOV     DPTR,#st + 11
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   90....       MOV     DPTR,#st + 8
   \   000013   7401         MOV     A,#0x1
   \   000015   F0           MOVX    @DPTR,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000003   12....       LCALL   ??mpu_set_lpf?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000003   12....       LCALL   ??mpu_set_gyro_fsr?relay
   \   000006   22           RET
   2371          
   2372          /**
   2373           *  @brief      Write to the DMP memory.
   2374           *  This function prevents I2C writes past the bank boundaries. The DMP memory
   2375           *  is only accessible when the chip is awake.
   2376           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2377           *  @param[in]  length      Number of bytes to write.
   2378           *  @param[in]  data        Bytes to write to memory.
   2379           *  @return     0 if successful.
   2380           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2381          int mpu_write_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_write_mem:
   2382                  unsigned char *data)
   2383          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740E         MOV     A,#0xe
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   12....       LCALL   ?Subroutine44 & 0xFFFF
   2384              unsigned char tmp[2];
   2385          
   2386              if (!data)
   \                     ??CrossCallReturnLabel_56:
   \   000016   7006         JNZ     ??mpu_write_mem_0
   2387                  return -1;
   \                     ??mpu_write_mem_1:
   \   000018   7AFF         MOV     R2,#-0x1
   \   00001A   7BFF         MOV     R3,#-0x1
   \   00001C   804B         SJMP    ??mpu_write_mem_2
   2388              if (!st.chip_cfg.sensors)
   \                     ??mpu_write_mem_0:
   \   00001E   90....       MOV     DPTR,#st + 6
   \   000021   E0           MOVX    A,@DPTR
   \   000022   60F4         JZ      ??mpu_write_mem_1
   2389                  return -1;
   2390          
   2391              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   000024   EB           MOV     A,R3
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   F0           MOVX    @DPTR,A
   2392              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   00002C   7401         MOV     A,#0x1
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine27 & 0xFFFF
   2393          
   2394              /* Check bank boundaries. */
   2395              if (tmp[1] + length > st.hw->bank_size)
   \                     ??CrossCallReturnLabel_27:
   \   000034   C082         PUSH    DPL
   \   000036   C083         PUSH    DPH
   \   000038   7401         MOV     A,#0x1
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   2E           ADD     A,R6
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   3F           ADDC    A,R7
   \   000042   FB           MOV     R3,A
   \   000043   D083         POP     DPH
   \   000045   D082         POP     DPL
   \   000047   C3           CLR     C
   \   000048   E0           MOVX    A,@DPTR
   \   000049   9A           SUBB    A,R2
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   9B           SUBB    A,R3
   \   00004D   40C9         JC      ??mpu_write_mem_1
   2396                  return -1;
   2397          
   2398              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   00004F                ; Setup parameters for call to function I2C_Write
   \   00004F   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000052   70C4         JNZ     ??mpu_write_mem_1
   2399                  return -1;
   2400              if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
   \   000054                ; Setup parameters for call to function I2C_Write
   \   000054   AC..         MOV     R4,?V0 + 0
   \   000056   AD..         MOV     R5,?V0 + 1
   \   000058   EE           MOV     A,R6
   \   000059   FB           MOV     R3,A
   \   00005A   90....       MOV     DPTR,#st
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2415         ADD     A,#0x15
   \   000060   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000063   70B3         JNZ     ??mpu_write_mem_1
   2401                  return -1;
   2402              return 0;
   \   000065   7A00         MOV     R2,#0x0
   \   000067   7B00         MOV     R3,#0x0
   \                     ??mpu_write_mem_2:
   \   000069                REQUIRE ?Subroutine5
   \   000069                ; // Fall through to label ?Subroutine5
   2403          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine130_0
   \   000002                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine131_0
   \   000003                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   E5..         MOV     A,?V0 + 0
   \   000009   45..         ORL     A,?V0 + 1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   7B02         MOV     R3,#0x2
   \   00000C   90....       MOV     DPTR,#st
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   2418         ADD     A,#0x18
   \   000012   F5..         MOV     ?V0 + 2,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   3400         ADDC    A,#0x0
   \   000018   85..82       MOV     DPL,?V0 + 2
   \   00001B   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00001E   12....       LCALL   ??I2C_Write?relay
   \   000021   8B..         MOV     ?V0 + 3,R3
   \   000023   EA           MOV     A,R2
   \   000024   45..         ORL     A,?V0 + 3
   \   000026   22           RET
   2404          
   2405          /**
   2406           *  @brief      Read from the DMP memory.
   2407           *  This function prevents I2C reads past the bank boundaries. The DMP memory
   2408           *  is only accessible when the chip is awake.
   2409           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2410           *  @param[in]  length      Number of bytes to read.
   2411           *  @param[out] data        Bytes read from memory.
   2412           *  @return     0 if successful.
   2413           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2414          int mpu_read_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_read_mem:
   2415                  unsigned char *data)
   2416          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740E         MOV     A,#0xe
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   12....       LCALL   ?Subroutine44 & 0xFFFF
   2417              unsigned char tmp[2];
   2418          
   2419              if (!data)
   \                     ??CrossCallReturnLabel_57:
   \   000016   7006         JNZ     ??mpu_read_mem_0
   2420                  return -1;
   \                     ??mpu_read_mem_1:
   \   000018   7AFF         MOV     R2,#-0x1
   \   00001A   7BFF         MOV     R3,#-0x1
   \   00001C   804B         SJMP    ??mpu_read_mem_2
   2421              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_mem_0:
   \   00001E   90....       MOV     DPTR,#st + 6
   \   000021   E0           MOVX    A,@DPTR
   \   000022   60F4         JZ      ??mpu_read_mem_1
   2422                  return -1;
   2423          
   2424              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   000024   EB           MOV     A,R3
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   F0           MOVX    @DPTR,A
   2425              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   00002C   7401         MOV     A,#0x1
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine27 & 0xFFFF
   2426          
   2427              /* Check bank boundaries. */
   2428              if (tmp[1] + length > st.hw->bank_size)
   \                     ??CrossCallReturnLabel_28:
   \   000034   C082         PUSH    DPL
   \   000036   C083         PUSH    DPH
   \   000038   7401         MOV     A,#0x1
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   2E           ADD     A,R6
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   3F           ADDC    A,R7
   \   000042   FB           MOV     R3,A
   \   000043   D083         POP     DPH
   \   000045   D082         POP     DPL
   \   000047   C3           CLR     C
   \   000048   E0           MOVX    A,@DPTR
   \   000049   9A           SUBB    A,R2
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   9B           SUBB    A,R3
   \   00004D   40C9         JC      ??mpu_read_mem_1
   2429                  return -1;
   2430          
   2431              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   00004F                ; Setup parameters for call to function I2C_Write
   \   00004F   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000052   70C4         JNZ     ??mpu_read_mem_1
   2432                  return -1;
   2433              if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
   \   000054                ; Setup parameters for call to function I2C_Read
   \   000054   AC..         MOV     R4,?V0 + 0
   \   000056   AD..         MOV     R5,?V0 + 1
   \   000058   EE           MOV     A,R6
   \   000059   FB           MOV     R3,A
   \   00005A   90....       MOV     DPTR,#st
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2415         ADD     A,#0x15
   \   000060   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000063   70B3         JNZ     ??mpu_read_mem_1
   2434                  return -1;
   2435              return 0;
   \   000065   7A00         MOV     R2,#0x0
   \   000067   7B00         MOV     R3,#0x0
   \                     ??mpu_read_mem_2:
   \   000069   80..         SJMP    ?Subroutine5
   2436          }
   2437          
   2438          /**
   2439           *  @brief      Load and verify DMP image.
   2440           *  @param[in]  length      Length of DMP image.
   2441           *  @param[in]  firmware    DMP code.
   2442           *  @param[in]  start_addr  Starting address of DMP code memory.
   2443           *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
   2444           *  @return     0 if successful.
   2445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2446          int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
   \                     mpu_load_firmware:
   2447              unsigned short start_addr, unsigned short sample_rate)
   2448          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   \   000012   7428         MOV     A,#0x28
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00001A   742A         MOV     A,#0x2a
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 6,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 7,A
   2449              unsigned short ii;
   2450              unsigned short this_write;
   2451              /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
   2452          #define LOAD_CHUNK  (16)
   2453              unsigned char cur[LOAD_CHUNK], tmp[2];
   2454          
   2455              if (st.chip_cfg.dmp_loaded)
   \   000026   90....       MOV     DPTR,#st + 30
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6007         JZ      ??mpu_load_firmware_0
   2456                  /* DMP should only be loaded once. */
   2457                  return -1;
   \                     ??mpu_load_firmware_1:
   \   00002C   7AFF         MOV     R2,#-0x1
   \                     ??mpu_load_firmware_2:
   \   00002E   7BFF         MOV     R3,#-0x1
   \   000030   02....       LJMP    ??CrossCallReturnLabel_253 & 0xFFFF
   2458          
   2459              if (!firmware)
   \                     ??mpu_load_firmware_0:
   \   000033   EC           MOV     A,R4
   \   000034   45..         ORL     A,?V0 + 5
   \   000036   60F4         JZ      ??mpu_load_firmware_1
   2460                  return -1;
   2461              for (ii = 0; ii < length; ii += this_write) {
   \   000038   7E00         MOV     R6,#0x0
   \   00003A   7F00         MOV     R7,#0x0
   \   00003C   8008         SJMP    ??mpu_load_firmware_3
   \                     ??mpu_load_firmware_4:
   \   00003E   EE           MOV     A,R6
   \   00003F   25..         ADD     A,?V0 + 10
   \   000041   FE           MOV     R6,A
   \   000042   EF           MOV     A,R7
   \   000043   35..         ADDC    A,?V0 + 11
   \   000045   FF           MOV     R7,A
   \                     ??mpu_load_firmware_3:
   \   000046   C3           CLR     C
   \   000047   EE           MOV     A,R6
   \   000048   95..         SUBB    A,?V0 + 2
   \   00004A   EF           MOV     A,R7
   \   00004B   95..         SUBB    A,?V0 + 3
   \   00004D   4003         JC      $+5
   \   00004F   02....       LJMP    ??mpu_load_firmware_5 & 0xFFFF
   2462                  this_write = min(LOAD_CHUNK, length - ii);
   \   000052   E5..         MOV     A,?V0 + 2
   \   000054   C3           CLR     C
   \   000055   9E           SUBB    A,R6
   \   000056   F8           MOV     R0,A
   \   000057   E5..         MOV     A,?V0 + 3
   \   000059   9F           SUBB    A,R7
   \   00005A   F9           MOV     R1,A
   \   00005B   C3           CLR     C
   \   00005C   E8           MOV     A,R0
   \   00005D   9411         SUBB    A,#0x11
   \   00005F   E9           MOV     A,R1
   \   000060   9400         SUBB    A,#0x0
   \   000062   4008         JC      ??mpu_load_firmware_6
   \   000064   75..10       MOV     ?V0 + 10,#0x10
   \   000067   75..00       MOV     ?V0 + 11,#0x0
   \   00006A   8004         SJMP    ??mpu_load_firmware_7
   \                     ??mpu_load_firmware_6:
   \   00006C   88..         MOV     ?V0 + 10,R0
   \   00006E   89..         MOV     ?V0 + 11,R1
   2463                  if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
   \                     ??mpu_load_firmware_7:
   \   000070   E5..         MOV     A,?V0 + 4
   \   000072   2E           ADD     A,R6
   \   000073   F5..         MOV     ?V0 + 12,A
   \   000075   E5..         MOV     A,?V0 + 5
   \   000077   3F           ADDC    A,R7
   \   000078   F5..         MOV     ?V0 + 13,A
   \   00007A                ; Setup parameters for call to function mpu_write_mem
   \   00007A   78..         MOV     R0,#?V0 + 12
   \   00007C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007F   AC..         MOV     R4,?V0 + 10
   \   000081   AD..         MOV     R5,?V0 + 11
   \   000083   EE           MOV     A,R6
   \   000084   FA           MOV     R2,A
   \   000085   EF           MOV     A,R7
   \   000086   FB           MOV     R3,A
   \   000087   12....       LCALL   ??mpu_write_mem?relay
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   8B..         MOV     ?V0 + 9,R3
   \   000091   EA           MOV     A,R2
   \   000092   45..         ORL     A,?V0 + 9
   \   000094   7096         JNZ     ??mpu_load_firmware_1
   2464                      return -1;
   2465                  if (mpu_read_mem(ii, this_write, cur))
   \   000096                ; Setup parameters for call to function mpu_read_mem
   \   000096   7402         MOV     A,#0x2
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   8582..       MOV     ?V0 + 8,DPL
   \   00009E   8583..       MOV     ?V0 + 9,DPH
   \   0000A1   78..         MOV     R0,#?V0 + 8
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A6   AC..         MOV     R4,?V0 + 10
   \   0000A8   AD..         MOV     R5,?V0 + 11
   \   0000AA   EE           MOV     A,R6
   \   0000AB   FA           MOV     R2,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   FB           MOV     R3,A
   \   0000AE   12....       LCALL   ??mpu_read_mem?relay
   \   0000B1   7402         MOV     A,#0x2
   \   0000B3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B6   8B..         MOV     ?V0 + 9,R3
   \   0000B8   EA           MOV     A,R2
   \   0000B9   45..         ORL     A,?V0 + 9
   \   0000BB   6003         JZ      $+5
   \   0000BD   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2466                      return -1;
   2467                  if (memcmp(firmware+ii, cur, this_write))
   \   0000C0                ; Setup parameters for call to function memcmp
   \   0000C0   78..         MOV     R0,#?V0 + 10
   \   0000C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C5   7404         MOV     A,#0x4
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   AC82         MOV     R4,DPL
   \   0000CC   AD83         MOV     R5,DPH
   \   0000CE   AA..         MOV     R2,?V0 + 12
   \   0000D0   AB..         MOV     R3,?V0 + 13
   \   0000D2   12....       LCALL   ??memcmp?relay
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DA   8B..         MOV     ?V0 + 9,R3
   \   0000DC   EA           MOV     A,R2
   \   0000DD   45..         ORL     A,?V0 + 9
   \   0000DF   7003         JNZ     $+5
   \   0000E1   02....       LJMP    ??mpu_load_firmware_4 & 0xFFFF
   2468                      return -2;
   \   0000E4   7AFE         MOV     R2,#-0x2
   \   0000E6   02....       LJMP    ??mpu_load_firmware_2 & 0xFFFF
   2469              }
   2470          
   2471              /* Set program start address. */
   2472              tmp[0] = start_addr >> 8;
   \                     ??mpu_load_firmware_5:
   \   0000E9   85..82       MOV     DPL,?XSP + 0
   \   0000EC   85..83       MOV     DPH,?XSP + 1
   \   0000EF   E5..         MOV     A,?V0 + 1
   \   0000F1   F0           MOVX    @DPTR,A
   2473              tmp[1] = start_addr & 0xFF;
   \   0000F2   7401         MOV     A,#0x1
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E5..         MOV     A,?V0 + 0
   \   0000F9   12....       LCALL   ?Subroutine61 & 0xFFFF
   2474              if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
   \                     ??CrossCallReturnLabel_94:
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   241A         ADD     A,#0x1a
   \   0000FF   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000102   6003         JZ      $+5
   \   000104   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2475                  return -1;
   2476          
   2477              st.chip_cfg.dmp_loaded = 1;
   \   000107   90....       MOV     DPTR,#st + 30
   \   00010A   7401         MOV     A,#0x1
   \   00010C   F0           MOVX    @DPTR,A
   2478              st.chip_cfg.dmp_sample_rate = sample_rate;
   \   00010D   A3           INC     DPTR
   \   00010E   E5..         MOV     A,?V0 + 6
   \   000110   F0           MOVX    @DPTR,A
   \   000111   A3           INC     DPTR
   \   000112   E5..         MOV     A,?V0 + 7
   \   000114   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   2479              return 0;
   \                     ??CrossCallReturnLabel_253:
   \   000117   7412         MOV     A,#0x12
   \   000119   02....       LJMP    ?Subroutine7 & 0xFFFF
   2480          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000003   7B02         MOV     R3,#0x2
   \   000005   90....       MOV     DPTR,#st
   \   000008   22           RET
   2481          
   2482          /**
   2483           *  @brief      Enable/disable DMP support.
   2484           *  @param[in]  enable  1 to turn on the DMP.
   2485           *  @return     0 if successful.
   2486           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2487          int mpu_set_dmp_state(unsigned char enable)
   \                     mpu_set_dmp_state:
   2488          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2489              unsigned char tmp;
   2490              if (st.chip_cfg.dmp_on == enable)
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   700C         JNZ     ??mpu_set_dmp_state_0
   2491                  return 0;
   \                     ??mpu_set_dmp_state_1:
   \   000013   7A00         MOV     R2,#0x0
   \   000015   7B00         MOV     R3,#0x0
   \                     ??mpu_set_dmp_state_2:
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001C   02....       LJMP    ?Subroutine4 & 0xFFFF
   2492          
   2493              if (enable) {
   \                     ??mpu_set_dmp_state_0:
   \   00001F   EE           MOV     A,R6
   \   000020   6030         JZ      ??mpu_set_dmp_state_3
   2494                  if (!st.chip_cfg.dmp_loaded)
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   7006         JNZ     ??mpu_set_dmp_state_4
   2495                      return -1;
   \   000026   7AFF         MOV     R2,#-0x1
   \   000028   7BFF         MOV     R3,#-0x1
   \   00002A   80EB         SJMP    ??mpu_set_dmp_state_2
   2496                  /* Disable data ready interrupt. */
   2497                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_4:
   \   00002C                ; Setup parameters for call to function set_int_enable
   \   00002C   7900         MOV     R1,#0x0
   \   00002E   12....       LCALL   ??set_int_enable?relay
   2498                  /* Disable bypass mode. */
   2499                  mpu_set_bypass(0);
   \   000031                ; Setup parameters for call to function mpu_set_bypass
   \   000031   7900         MOV     R1,#0x0
   \   000033   12....       LCALL   ??mpu_set_bypass?relay
   2500                  /* Keep constant sample rate, FIFO rate controlled by DMP. */
   2501                  mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
   \   000036                ; Setup parameters for call to function mpu_set_sample_rate
   \   000036   90....       MOV     DPTR,#st + 31
   \   000039   12....       LCALL   ?Subroutine38 & 0xFFFF
   2502                  /* Remove FIFO elements. */
   2503                  tmp = 0;
   \                     ??CrossCallReturnLabel_43:
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   E4           CLR     A
   \   000043   12....       LCALL   ?Subroutine29 & 0xFFFF
   2504                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2505                  st.chip_cfg.dmp_on = 1;
   \                     ??CrossCallReturnLabel_31:
   \   000046   7401         MOV     A,#0x1
   \   000048   F0           MOVX    @DPTR,A
   2506                  /* Enable DMP interrupt. */
   2507                  set_int_enable(1);
   \   000049                ; Setup parameters for call to function set_int_enable
   \   000049   F9           MOV     R1,A
   \   00004A   12....       LCALL   ??set_int_enable?relay
   2508                  mpu_reset_fifo();
   \   00004D                ; Setup parameters for call to function mpu_reset_fifo
   \                     ??mpu_set_dmp_state_5:
   \   00004D   12....       LCALL   ??mpu_reset_fifo?relay
   \   000050   80C1         SJMP    ??mpu_set_dmp_state_1
   2509              } else {
   2510                  /* Disable DMP interrupt. */
   2511                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_3:
   \   000052                ; Setup parameters for call to function set_int_enable
   \   000052   7900         MOV     R1,#0x0
   \   000054   12....       LCALL   ??set_int_enable?relay
   2512                  /* Restore FIFO settings. */
   2513                  tmp = st.chip_cfg.fifo_enable;
   \   000057   90....       MOV     DPTR,#st + 11
   \   00005A   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   00005D   12....       LCALL   ?Subroutine29 & 0xFFFF
   2514                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2515                  st.chip_cfg.dmp_on = 0;
   \                     ??CrossCallReturnLabel_32:
   \   000060   E4           CLR     A
   \   000061   F0           MOVX    @DPTR,A
   2516                  mpu_reset_fifo();
   \   000062                ; Setup parameters for call to function mpu_reset_fifo
   \   000062   80E9         SJMP    ??mpu_set_dmp_state_5
   2517              }
   2518              return 0;
   2519          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   7A23         MOV     R2,#0x23
   \   000005   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   000008   90....       MOV     DPTR,#st + 29
   \   00000B   22           RET
   2520          
   2521          /**
   2522           *  @brief      Get DMP state.
   2523           *  @param[out] enabled 1 if enabled.
   2524           *  @return     0 if successful.
   2525           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2526          int mpu_get_dmp_state(unsigned char *enabled)
   \                     mpu_get_dmp_state:
   2527          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2528              enabled[0] = st.chip_cfg.dmp_on;
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   02....       LJMP    ?Subroutine1 & 0xFFFF
   2529              return 0;
   2530          }
   2531          
   2532          
   2533          /* This initialization is similar to the one in ak8975.c. */
   2534          //static int setup_compass(void)
   2535          //{
   2536          //#ifdef AK89xx_SECONDARY
   2537          //    unsigned char data[4], akm_addr;
   2538          //
   2539          //    mpu_set_bypass(1);
   2540          //
   2541          //    /* Find compass. Possible addresses range from 0x0C to 0x0F. */
   2542          //    for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
   2543          //        int result;
   2544          //        result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
   2545          //        if (!result && (data[0] == AKM_WHOAMI))
   2546          //            break;
   2547          //    }
   2548          //
   2549          //    if (akm_addr > 0x0F) {
   2550          //        /* TODO: Handle this case in all compass-related functions. */
   2551          //        log_e("Compass not found.\n");
   2552          //        return -1;
   2553          //    }
   2554          //
   2555          //    st.chip_cfg.compass_addr = akm_addr;
   2556          //
   2557          //    data[0] = AKM_POWER_DOWN;
   2558          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2559          //        return -1;
   2560          //    delay_ms(1);
   2561          //
   2562          //    data[0] = AKM_FUSE_ROM_ACCESS;
   2563          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2564          //        return -1;
   2565          //    delay_ms(1);
   2566          //
   2567          //    /* Get sensitivity adjustment data from fuse ROM. */
   2568          //    if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
   2569          //        return -1;
   2570          //    st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
   2571          //    st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
   2572          //    st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
   2573          //
   2574          //    data[0] = AKM_POWER_DOWN;
   2575          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2576          //        return -1;
   2577          //    delay_ms(1);
   2578          //
   2579          //    mpu_set_bypass(0);
   2580          //
   2581          //    /* Set up master mode, master clock, and ES bit. */
   2582          //    data[0] = 0x40;
   2583          //    if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   2584          //        return -1;
   2585          //
   2586          //    /* Slave 0 reads from AKM data registers. */
   2587          //    data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
   2588          //    if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
   2589          //        return -1;
   2590          //
   2591          //    /* Compass reads start at this register. */
   2592          //    data[0] = AKM_REG_ST1;
   2593          //    if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
   2594          //        return -1;
   2595          //
   2596          //    /* Enable slave 0, 8-byte reads. */
   2597          //    data[0] = BIT_SLAVE_EN | 8;
   2598          //    if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
   2599          //        return -1;
   2600          //
   2601          //    /* Slave 1 changes AKM measurement mode. */
   2602          //    data[0] = st.chip_cfg.compass_addr;
   2603          //    if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
   2604          //        return -1;
   2605          //
   2606          //    /* AKM measurement mode register. */
   2607          //    data[0] = AKM_REG_CNTL;
   2608          //    if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
   2609          //        return -1;
   2610          //
   2611          //    /* Enable slave 1, 1-byte writes. */
   2612          //    data[0] = BIT_SLAVE_EN | 1;
   2613          //    if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
   2614          //        return -1;
   2615          //
   2616          //    /* Set slave 1 data. */
   2617          //    data[0] = AKM_SINGLE_MEASUREMENT;
   2618          //    if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
   2619          //        return -1;
   2620          //
   2621          //    /* Trigger slave 0 and slave 1 actions at each sample. */
   2622          //    data[0] = 0x03;
   2623          //    if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
   2624          //        return -1;
   2625          //
   2626          //#ifdef MPU9150
   2627          //    /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
   2628          //    data[0] = BIT_I2C_MST_VDDIO;
   2629          //    if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
   2630          //        return -1;
   2631          //#endif
   2632          //
   2633          //    return 0;
   2634          //#else
   2635          //    return -1;
   2636          //#endif
   2637          //}
   2638          
   2639          /**
   2640           *  @brief      Read raw compass data.
   2641           *  @param[out] data        Raw data in hardware units.
   2642           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   2643           *  @return     0 if successful.
   2644           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2645          int mpu_get_compass_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_compass_reg:
   2646          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2647          #ifdef AK89xx_SECONDARY
   2648              unsigned char tmp[9];
   2649          
   2650              if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   2651                  return -1;
   2652          
   2653          #ifdef AK89xx_BYPASS
   2654              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
   2655                  return -1;
   2656              tmp[8] = AKM_SINGLE_MEASUREMENT;
   2657              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
   2658                  return -1;
   2659          #else
   2660              if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
   2661                  return -1;
   2662          #endif
   2663          
   2664          #if defined AK8975_SECONDARY
   2665              /* AK8975 doesn't have the overrun error bit. */
   2666              if (!(tmp[0] & AKM_DATA_READY))
   2667                  return -2;
   2668              if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
   2669                  return -3;
   2670          #elif defined AK8963_SECONDARY
   2671              /* AK8963 doesn't have the data read error bit. */
   2672              if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
   2673                  return -2;
   2674              if (tmp[7] & AKM_OVERFLOW)
   2675                  return -3;
   2676          #endif
   2677              data[0] = (tmp[2] << 8) | tmp[1];
   2678              data[1] = (tmp[4] << 8) | tmp[3];
   2679              data[2] = (tmp[6] << 8) | tmp[5];
   2680          
   2681              data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
   2682              data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
   2683              data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
   2684          
   2685              if (timestamp)
   2686                  get_ms(timestamp);
   2687              return 0;
   2688          #else
   2689              return -1;
   \   000000   02....       LJMP    ?Subroutine2 & 0xFFFF
   2690          #endif
   2691          }
   2692          
   2693          /**
   2694           *  @brief      Get the compass full-scale range.
   2695           *  @param[out] fsr Current full-scale range.
   2696           *  @return     0 if successful.
   2697           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2698          int mpu_get_compass_fsr(unsigned short *fsr)
   \                     mpu_get_compass_fsr:
   2699          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2700          #ifdef AK89xx_SECONDARY
   2701              fsr[0] = st.hw->compass_fsr;
   2702              return 0;
   2703          #else
   2704              return -1;
   \   000000   02....       LJMP    ?Subroutine2 & 0xFFFF
   2705          #endif
   2706          }
   2707          
   2708          /**
   2709           *  @brief      Enters LP accel motion interrupt mode.
   2710           *  The behavior of this feature is very different between the MPU6050 and the
   2711           *  MPU6500. Each chip's version of this feature is explained below.
   2712           *
   2713           *  \n MPU6050:
   2714           *  \n When this mode is first enabled, the hardware captures a single accel
   2715           *  sample, and subsequent samples are compared with this one to determine if
   2716           *  the device is in motion. Therefore, whenever this "locked" sample needs to
   2717           *  be changed, this function must be called again.
   2718           *
   2719           *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
   2720           *  increments.
   2721           *
   2722           *  \n Low-power accel mode supports the following frequencies:
   2723           *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
   2724           *
   2725           *  \n MPU6500:
   2726           *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
   2727           *  sample. The hardware monitors the accel data and detects any large change
   2728           *  over a short period of time.
   2729           *
   2730           *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
   2731           *  increments.
   2732           *
   2733           *  \n MPU6500 Low-power accel mode supports the following frequencies:
   2734           *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
   2735           *
   2736           *  \n\n NOTES:
   2737           *  \n The driver will round down @e thresh to the nearest supported value if
   2738           *  an unsupported threshold is selected.
   2739           *  \n To select a fractional wake-up frequency, round down the value passed to
   2740           *  @e lpa_freq.
   2741           *  \n The MPU6500 does not support a delay parameter. If this function is used
   2742           *  for the MPU6500, the value passed to @e time will be ignored.
   2743           *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
   2744           *  the previous configuration.
   2745           *
   2746           *  @param[in]  thresh      Motion threshold in mg.
   2747           *  @param[in]  time        Duration in milliseconds that the accel data must
   2748           *                          exceed @e thresh before motion is reported.
   2749           *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
   2750           *  @return     0 if successful.
   2751           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2752          int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
   \                     mpu_lp_motion_interrupt:
   2753              unsigned char lpa_freq)
   2754          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
   2755              unsigned char data[3];
   2756          
   2757              if (lpa_freq) {
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??mpu_lp_motion_interrupt_0 & 0xFFFF
   2758                  unsigned char thresh_hw;
   2759          
   2760          #if defined MPU6050
   2761                  /* TODO: Make these const/#defines. */
   2762                  /* 1LSb = 32mg. */
   2763                  if (thresh > 8160)
   \   000013   C3           CLR     C
   \   000014   EA           MOV     A,R2
   \   000015   94E1         SUBB    A,#-0x1f
   \   000017   EB           MOV     A,R3
   \   000018   941F         SUBB    A,#0x1f
   \   00001A   4005         JC      ??mpu_lp_motion_interrupt_1
   2764                      thresh_hw = 255;
   \   00001C   75..FF       MOV     ?V0 + 0,#-0x1
   \   00001F   8019         SJMP    ??mpu_lp_motion_interrupt_2
   2765                  else if (thresh < 32)
   \                     ??mpu_lp_motion_interrupt_1:
   \   000021   C3           CLR     C
   \   000022   EA           MOV     A,R2
   \   000023   9420         SUBB    A,#0x20
   \   000025   EB           MOV     A,R3
   \   000026   9400         SUBB    A,#0x0
   \   000028   5005         JNC     ??mpu_lp_motion_interrupt_3
   2766                      thresh_hw = 1;
   \   00002A   75..01       MOV     ?V0 + 0,#0x1
   \   00002D   800B         SJMP    ??mpu_lp_motion_interrupt_2
   2767                  else
   2768                      thresh_hw = thresh >> 5;
   \                     ??mpu_lp_motion_interrupt_3:
   \   00002F   8A..         MOV     ?V0 + 0,R2
   \   000031   8B..         MOV     ?V0 + 1,R3
   \   000033   7405         MOV     A,#0x5
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?US_SHR
   2769          #elif defined MPU6500
   2770                  /* 1LSb = 4mg. */
   2771                  if (thresh > 1020)
   2772                      thresh_hw = 255;
   2773                  else if (thresh < 4)
   2774                      thresh_hw = 1;
   2775                  else
   2776                      thresh_hw = thresh >> 2;
   2777          #endif
   2778          
   2779                  if (!time)
   \                     ??mpu_lp_motion_interrupt_2:
   \   00003A   EF           MOV     A,R7
   \   00003B   7002         JNZ     ??mpu_lp_motion_interrupt_4
   2780                      /* Minimum duration must be 1ms. */
   2781                      time = 1;
   \   00003D   7F01         MOV     R7,#0x1
   2782          
   2783          #if defined MPU6050
   2784                  if (lpa_freq > 40)
   \                     ??mpu_lp_motion_interrupt_4:
   \   00003F   EE           MOV     A,R6
   \   000040   C3           CLR     C
   \   000041   9429         SUBB    A,#0x29
   \   000043   4007         JC      ??mpu_lp_motion_interrupt_5
   2785          #elif defined MPU6500
   2786                  if (lpa_freq > 640)
   2787          #endif
   2788                      /* At this point, the chip has not been re-configured, so the
   2789                       * function can safely exit.
   2790                       */
   2791                      return -1;
   \                     ??mpu_lp_motion_interrupt_6:
   \   000045   7AFF         MOV     R2,#-0x1
   \   000047   7BFF         MOV     R3,#-0x1
   \   000049   02....       LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
   2792          
   2793                  if (!st.chip_cfg.int_motion_only) {
   \                     ??mpu_lp_motion_interrupt_5:
   \   00004C   90....       MOV     DPTR,#st + 16
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   7042         JNZ     ??mpu_lp_motion_interrupt_8
   2794                      /* Store current settings for later. */
   2795                      if (st.chip_cfg.dmp_on) {
   \   000052   90....       MOV     DPTR,#st + 29
   \   000055   E0           MOVX    A,@DPTR
   \   000056   600C         JZ      ??mpu_lp_motion_interrupt_9
   2796                          mpu_set_dmp_state(0);
   \   000058                ; Setup parameters for call to function mpu_set_dmp_state
   \   000058   7900         MOV     R1,#0x0
   \   00005A   12....       LCALL   ??mpu_set_dmp_state?relay
   2797                          st.chip_cfg.cache.dmp_on = 1;
   \   00005D   90....       MOV     DPTR,#st + 26
   \   000060   7401         MOV     A,#0x1
   \   000062   8004         SJMP    ??mpu_lp_motion_interrupt_10
   2798                      } else
   2799                          st.chip_cfg.cache.dmp_on = 0;
   \                     ??mpu_lp_motion_interrupt_9:
   \   000064   90....       MOV     DPTR,#st + 26
   \   000067   E4           CLR     A
   \                     ??mpu_lp_motion_interrupt_10:
   \   000068   F0           MOVX    @DPTR,A
   2800                      mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
   \   000069                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000069   7A..         MOV     R2,#(st + 17) & 0xff
   \   00006B   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   00006D   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2801                      mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
   \   000070                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000070   7A..         MOV     R2,#(st + 19) & 0xff
   \   000072   7B..         MOV     R3,#((st + 19) >> 8) & 0xff
   \   000074   12....       LCALL   ??mpu_get_accel_fsr?relay
   2802                      mpu_get_lpf(&st.chip_cfg.cache.lpf);
   \   000077                ; Setup parameters for call to function mpu_get_lpf
   \   000077   7A..         MOV     R2,#(st + 20) & 0xff
   \   000079   7B..         MOV     R3,#((st + 20) >> 8) & 0xff
   \   00007B   12....       LCALL   ??mpu_get_lpf?relay
   2803                      mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
   \   00007E                ; Setup parameters for call to function mpu_get_sample_rate
   \   00007E   7A..         MOV     R2,#(st + 22) & 0xff
   \   000080   7B..         MOV     R3,#((st + 22) >> 8) & 0xff
   \   000082   12....       LCALL   ??mpu_get_sample_rate?relay
   2804                      st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
   \   000085   90....       MOV     DPTR,#st + 6
   \   000088   E0           MOVX    A,@DPTR
   \   000089   90....       MOV     DPTR,#st + 24
   \   00008C   F0           MOVX    @DPTR,A
   2805                      mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
   \   00008D                ; Setup parameters for call to function mpu_get_fifo_config
   \   00008D   7A..         MOV     R2,#(st + 25) & 0xff
   \   00008F   7B..         MOV     R3,#((st + 25) >> 8) & 0xff
   \   000091   12....       LCALL   ??mpu_get_fifo_config?relay
   2806                  }
   2807          
   2808          #ifdef MPU6050
   2809                  /* Disable hardware interrupts for now. */
   2810                  set_int_enable(0);
   \                     ??mpu_lp_motion_interrupt_8:
   \   000094                ; Setup parameters for call to function set_int_enable
   \   000094   7900         MOV     R1,#0x0
   \   000096   12....       LCALL   ??set_int_enable?relay
   2811          
   2812                  /* Enter full-power accel-only mode. */
   2813                  mpu_lp_accel_mode(0);
   \   000099                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000099   7900         MOV     R1,#0x0
   \   00009B   12....       LCALL   ??mpu_lp_accel_mode?relay
   2814          
   2815                  /* Override current LPF (and HPF) settings to obtain a valid accel
   2816                   * reading.
   2817                   */
   2818                  data[0] = INV_FILTER_256HZ_NOLPF2;
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   E4           CLR     A
   \   0000A5   12....       LCALL   ?Subroutine35 & 0xFFFF
   2819                  if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \                     ??CrossCallReturnLabel_203:
   \   0000A8   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0000AB   7098         JNZ     ??mpu_lp_motion_interrupt_6
   2820                      return -1;
   2821          
   2822                  /* NOTE: Digital high pass filter should be configured here. Since this
   2823                   * driver doesn't modify those bits anywhere, they should already be
   2824                   * cleared by default.
   2825                   */
   2826          
   2827                  /* Configure the device to send motion interrupts. */
   2828                  /* Enable motion interrupt. */
   2829                  data[0] = BIT_MOT_INT_EN;
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   7440         MOV     A,#0x40
   \   0000B5   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   2830                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \                     ??CrossCallReturnLabel_261:
   \   0000B8   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   0000BB   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   0000BE   6003         JZ      $+5
   \   0000C0   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2831                      goto lp_int_restore;
   2832          
   2833                  /* Set motion interrupt parameters. */
   2834                  data[0] = thresh_hw;
   \   0000C3   85..82       MOV     DPL,?XSP + 0
   \   0000C6   85..83       MOV     DPH,?XSP + 1
   \   0000C9   E5..         MOV     A,?V0 + 0
   \   0000CB   F0           MOVX    @DPTR,A
   2835                  data[1] = time;
   \   0000CC   7401         MOV     A,#0x1
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   EF           MOV     A,R7
   \   0000D2   12....       LCALL   ?Subroutine61 & 0xFFFF
   2836                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
   \                     ??CrossCallReturnLabel_95:
   \   0000D5   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   0000D8   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   0000DB   6003         JZ      $+5
   \   0000DD   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2837                      goto lp_int_restore;
   2838          
   2839                  /* Force hardware to "lock" current accel sample. */
   2840                  delay_ms(5);
   \   0000E0                ; Setup parameters for call to function delay_ms
   \   0000E0   7A05         MOV     R2,#0x5
   \   0000E2   7B00         MOV     R3,#0x0
   \   0000E4   12....       LCALL   ??delay_ms?relay
   2841                  data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
   \   0000E7   90....       MOV     DPTR,#st + 5
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   33           RLC     A
   \   0000EC   33           RLC     A
   \   0000ED   33           RLC     A
   \   0000EE   54F8         ANL     A,#0xf8
   \   0000F0   4407         ORL     A,#0x7
   \   0000F2   85..82       MOV     DPL,?XSP + 0
   \   0000F5   85..83       MOV     DPH,?XSP + 1
   \   0000F8   12....       LCALL   ?Subroutine23 & 0xFFFF
   2842                  if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??CrossCallReturnLabel_215:
   \   0000FB   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   0000FE   7075         JNZ     ??mpu_lp_motion_interrupt_11
   2843                      goto lp_int_restore;
   2844          
   2845                  /* Set up LP accel mode. */
   2846                  data[0] = BIT_LPA_CYCLE;
   \   000100   85..82       MOV     DPL,?XSP + 0
   \   000103   85..83       MOV     DPH,?XSP + 1
   \   000106   7420         MOV     A,#0x20
   \   000108   F0           MOVX    @DPTR,A
   2847                  if (lpa_freq == 1)
   \   000109   7401         MOV     A,#0x1
   \   00010B   6E           XRL     A,R6
   \   00010C   7008         JNZ     ??mpu_lp_motion_interrupt_12
   2848                      data[1] = INV_LPA_1_25HZ;
   \   00010E   7401         MOV     A,#0x1
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   E4           CLR     A
   \   000114   8023         SJMP    ??mpu_lp_motion_interrupt_13
   2849                  else if (lpa_freq <= 5)
   \                     ??mpu_lp_motion_interrupt_12:
   \   000116   EE           MOV     A,R6
   \   000117   C3           CLR     C
   \   000118   9406         SUBB    A,#0x6
   \   00011A   5009         JNC     ??mpu_lp_motion_interrupt_14
   2850                      data[1] = INV_LPA_5HZ;
   \   00011C   7401         MOV     A,#0x1
   \   00011E   12....       LCALL   ?XSTACK_DISP0_8
   \   000121   7401         MOV     A,#0x1
   \   000123   8014         SJMP    ??mpu_lp_motion_interrupt_13
   2851                  else if (lpa_freq <= 20)
   \                     ??mpu_lp_motion_interrupt_14:
   \   000125   EE           MOV     A,R6
   \   000126   C3           CLR     C
   \   000127   9415         SUBB    A,#0x15
   \   000129   7401         MOV     A,#0x1
   \   00012B   5007         JNC     ??mpu_lp_motion_interrupt_15
   2852                      data[1] = INV_LPA_20HZ;
   \   00012D   12....       LCALL   ?XSTACK_DISP0_8
   \   000130   7402         MOV     A,#0x2
   \   000132   8005         SJMP    ??mpu_lp_motion_interrupt_13
   2853                  else
   2854                      data[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_motion_interrupt_15:
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   7403         MOV     A,#0x3
   \                     ??mpu_lp_motion_interrupt_13:
   \   000139   F0           MOVX    @DPTR,A
   2855                  data[1] = (data[1] << 6) | BIT_STBY_XYZG;
   \   00013A   7401         MOV     A,#0x1
   \   00013C   12....       LCALL   ?XSTACK_DISP0_8
   \   00013F   12....       LCALL   ?Subroutine10 & 0xFFFF
   2856                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \                     ??CrossCallReturnLabel_276:
   \   000142   7031         JNZ     ??mpu_lp_motion_interrupt_11
   2857                      goto lp_int_restore;
   2858          
   2859                  st.chip_cfg.int_motion_only = 1;
   \   000144   90....       MOV     DPTR,#st + 16
   \   000147   7401         MOV     A,#0x1
   \   000149   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   2860                  return 0;
   2861          #elif defined MPU6500
   2862                  /* Disable hardware interrupts. */
   2863                  set_int_enable(0);
   2864          
   2865                  /* Enter full-power accel-only mode, no FIFO/DMP. */
   2866                  data[0] = 0;
   2867                  data[1] = 0;
   2868                  data[2] = BIT_STBY_XYZG;
   2869                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
   2870                      goto lp_int_restore;
   2871          
   2872                  /* Set motion threshold. */
   2873                  data[0] = thresh_hw;
   2874                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
   2875                      goto lp_int_restore;
   2876          
   2877                  /* Set wake frequency. */
   2878                  if (lpa_freq == 1)
   2879                      data[0] = INV_LPA_1_25HZ;
   2880                  else if (lpa_freq == 2)
   2881                      data[0] = INV_LPA_2_5HZ;
   2882                  else if (lpa_freq <= 5)
   2883                      data[0] = INV_LPA_5HZ;
   2884                  else if (lpa_freq <= 10)
   2885                      data[0] = INV_LPA_10HZ;
   2886                  else if (lpa_freq <= 20)
   2887                      data[0] = INV_LPA_20HZ;
   2888                  else if (lpa_freq <= 40)
   2889                      data[0] = INV_LPA_40HZ;
   2890                  else if (lpa_freq <= 80)
   2891                      data[0] = INV_LPA_80HZ;
   2892                  else if (lpa_freq <= 160)
   2893                      data[0] = INV_LPA_160HZ;
   2894                  else if (lpa_freq <= 320)
   2895                      data[0] = INV_LPA_320HZ;
   2896                  else
   2897                      data[0] = INV_LPA_640HZ;
   2898                  if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
   2899                      goto lp_int_restore;
   2900          
   2901                  /* Enable motion interrupt (MPU6500 version). */
   2902                  data[0] = BITS_WOM_EN;
   2903                  if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2904                      goto lp_int_restore;
   2905          
   2906                  /* Enable cycle mode. */
   2907                  data[0] = BIT_LPA_CYCLE;
   2908                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   2909                      goto lp_int_restore;
   2910          
   2911                  /* Enable interrupt. */
   2912                  data[0] = BIT_MOT_INT_EN;
   2913                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   2914                      goto lp_int_restore;
   2915          
   2916                  st.chip_cfg.int_motion_only = 1;
   2917                  return 0;
   2918          #endif
   2919              } else {
   \                     ??CrossCallReturnLabel_254:
   \   00014C   8066         SJMP    ??mpu_lp_motion_interrupt_7
   2920                  /* Don't "restore" the previous state if no state has been saved. */
   2921                  int ii;
   2922                  char *cache_ptr = (char*)&st.chip_cfg.cache;
   2923                  for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
   \                     ??mpu_lp_motion_interrupt_0:
   \   00014E   7800         MOV     R0,#0x0
   \   000150   7900         MOV     R1,#0x0
   2924                      if (cache_ptr[ii] != 0)
   \                     ??mpu_lp_motion_interrupt_16:
   \   000152   74..         MOV     A,#(st + 17) & 0xff
   \   000154   28           ADD     A,R0
   \   000155   F582         MOV     DPL,A
   \   000157   74..         MOV     A,#((st + 17) >> 8) & 0xff
   \   000159   39           ADDC    A,R1
   \   00015A   F583         MOV     DPH,A
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   7016         JNZ     ??mpu_lp_motion_interrupt_11
   2925                          goto lp_int_restore;
   2926                  }
   \   00015F   E8           MOV     A,R0
   \   000160   2401         ADD     A,#0x1
   \   000162   08           INC     R0
   \   000163   E9           MOV     A,R1
   \   000164   3400         ADDC    A,#0x0
   \   000166   F9           MOV     R1,A
   \   000167   C3           CLR     C
   \   000168   E8           MOV     A,R0
   \   000169   940A         SUBB    A,#0xa
   \   00016B   E9           MOV     A,R1
   \   00016C   9400         SUBB    A,#0x0
   \   00016E   4003         JC      $+5
   \   000170   02....       LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
   \   000173   80DD         SJMP    ??mpu_lp_motion_interrupt_16
   2927                  /* If we reach this point, motion interrupt mode hasn't been used yet. */
   2928                  return -1;
   2929              }
   2930          lp_int_restore:
   2931              /* Set to invalid values to ensure no I2C writes are skipped. */
   2932              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_lp_motion_interrupt_11:
   \   000175   12....       LCALL   ?Subroutine59 & 0xFFFF
   2933              st.chip_cfg.accel_fsr = 0xFF;
   2934              st.chip_cfg.lpf = 0xFF;
   2935              st.chip_cfg.sample_rate = 0xFFFF;
   2936              st.chip_cfg.sensors = 0xFF;
   2937              st.chip_cfg.fifo_enable = 0xFF;
   2938              st.chip_cfg.clk_src = INV_CLK_PLL;
   2939              mpu_set_sensors(st.chip_cfg.cache.sensors_on);
   \                     ??CrossCallReturnLabel_93:
   \   000178                ; Setup parameters for call to function mpu_set_sensors
   \   000178   90....       MOV     DPTR,#st + 24
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   F9           MOV     R1,A
   \   00017D   12....       LCALL   ??mpu_set_sensors?relay
   2940              mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
   \   000180                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   000180   90....       MOV     DPTR,#st + 17
   \   000183   12....       LCALL   ?Subroutine49 & 0xFFFF
   2941              mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
   \                     ??CrossCallReturnLabel_74:
   \   000186                ; Setup parameters for call to function mpu_set_accel_fsr
   \   000186   90....       MOV     DPTR,#st + 19
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   F9           MOV     R1,A
   \   00018B   12....       LCALL   ??mpu_set_accel_fsr?relay
   2942              mpu_set_lpf(st.chip_cfg.cache.lpf);
   \   00018E                ; Setup parameters for call to function mpu_set_lpf
   \   00018E   90....       MOV     DPTR,#st + 20
   \   000191   12....       LCALL   ?Subroutine50 & 0xFFFF
   2943              mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
   \                     ??CrossCallReturnLabel_76:
   \   000194                ; Setup parameters for call to function mpu_set_sample_rate
   \   000194   90....       MOV     DPTR,#st + 22
   \   000197   12....       LCALL   ?Subroutine38 & 0xFFFF
   2944              mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
   \                     ??CrossCallReturnLabel_44:
   \   00019A                ; Setup parameters for call to function mpu_configure_fifo
   \   00019A   90....       MOV     DPTR,#st + 25
   \   00019D   E0           MOVX    A,@DPTR
   \   00019E   F9           MOV     R1,A
   \   00019F   12....       LCALL   ??mpu_configure_fifo?relay
   2945          
   2946              if (st.chip_cfg.cache.dmp_on)
   \   0001A2   90....       MOV     DPTR,#st + 26
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   6005         JZ      ??mpu_lp_motion_interrupt_17
   2947                  mpu_set_dmp_state(1);
   \   0001A8                ; Setup parameters for call to function mpu_set_dmp_state
   \   0001A8   7901         MOV     R1,#0x1
   \   0001AA   12....       LCALL   ??mpu_set_dmp_state?relay
   2948          
   2949          #ifdef MPU6500
   2950              /* Disable motion interrupt (MPU6500 version). */
   2951              data[0] = 0;
   2952              if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2953                  goto lp_int_restore;
   2954          #endif
   2955          
   2956              st.chip_cfg.int_motion_only = 0;
   \                     ??mpu_lp_motion_interrupt_17:
   \   0001AD   90....       MOV     DPTR,#st + 16
   \   0001B0   E4           CLR     A
   \   0001B1   F0           MOVX    @DPTR,A
   2957              return 0;
   \   0001B2   FA           MOV     R2,A
   \   0001B3   FB           MOV     R3,A
   \                     ??mpu_lp_motion_interrupt_7:
   \   0001B4   7403         MOV     A,#0x3
   \   0001B6   02....       LJMP    ??Subroutine130_0 & 0xFFFF
   2958          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   000003   8B..         MOV     ?V0 + 3,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 3
   \   000008   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for st>`:
   \   000000   ....         DW reg
   \   000002   ....         DW hw
   \   000004   00           DB 0
   \   000005   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00000D   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000015   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001D   00000000     DB 0, 0, 0, 0
   \   000021   ....         DW test

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_420c0000:
   \   000000   00000C42     DD 420C0000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_47800000:
   \   000000   00008047     DD 47800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_43030000:
   \   000000   00000343     DD 43030000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42830000:
   \   000000   00008342     DD 42830000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42033333:
   \   000000   33330342     DD 42033333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41833333:
   \   000000   33338341     DD 41833333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3eae147b:
   \   000000   7B14AE3E     DD 3EAE147BH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f845a1d:
   \   000000   1D5A843F     DD 3F845A1DH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_37800000:
   \   000000   00008037     DD 37800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_bf800000:
   \   000000   000080BF     DD 0BF800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e99999a:
   \   000000   9A99993E     DD 3E99999AH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f733334:
   \   000000   3433733F     DD 3F733334H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41c80000:
   \   000000   0000C841     DD 41C80000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f85e354:
   \   000000   54E3853F     DD 3F85E354H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41200000:
   \   000000   00002041     DD 41200000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42d20001:
   \   000000   0100D242     DD 42D20001H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_83:
   \   000000   83000000     DD 131

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffff0000:
   \   000000   0000FFFF     DD -65536

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_10000:
   \   000000   00000100     DD 65536

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_orientation_matrix_to_scalar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_orientation_matrix_to_scalar

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_row_2_scale?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_row_2_scale

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_ms?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_ms

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??set_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    set_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reg_dump?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reg_dump

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_accel_mode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_accel_mode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_temperature?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_temperature

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_bias?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_bias

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reset_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reset_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_fifo_config?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_fifo_config

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_configure_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_configure_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_power_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_power_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sensors?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sensors

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_int_status?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_int_status

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo_stream?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo_stream

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_bypass?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_bypass

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_level?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_level

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_latched?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_latched

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_accel_prod_shift?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_accel_prod_shift

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??accel_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    accel_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gyro_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gyro_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_st_biases?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_st_biases

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_write_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_write_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_load_firmware?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_load_firmware

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_motion_interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_motion_interrupt
   2959          
   2960          /**
   2961           *  @}
   2962           */
   2963          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     accel_self_test                    0      0     86
       -> get_accel_prod_shift          0      0     76
       -> labs                          0      0     76
       -> fabsf                         0      0     76
     get_accel_prod_shift               1      0     67
       -> I2C_Read                      0      0     58
     get_ms                             0      0      0
     get_st_biases                      2      0    103
       -> I2C_Write                     0      0    110
       -> delay_ms                      0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> delay_ms                      0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> delay_ms                      0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> delay_ms                      0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Read                      0      0    110
       -> I2C_Read                      0      0    110
     gyro_self_test                     0      0     77
       -> I2C_Read                      0      0     58
       -> labs                          0      0     58
       -> fabsf                         0      0     58
     inv_orientation_matrix_to_scalar
                                        0      0     14
       -> inv_row_2_scale               0      0     28
       -> inv_row_2_scale               0      0     28
       -> inv_row_2_scale               0      0     28
     inv_row_2_scale                    2      0     14
     mpu_configure_fifo                 0      0     60
       -> set_int_enable                0      0     24
       -> set_int_enable                0      0     24
       -> mpu_reset_fifo                0      0     24
     mpu_get_accel_fsr                  3      0     48
     mpu_get_accel_reg                  0      0     16
       -> I2C_Read                      0      0     32
     mpu_get_accel_sens                 2      0     46
     mpu_get_compass_fsr                0      0      0
     mpu_get_compass_reg                0      0      0
     mpu_get_compass_sample_rate        2      0      0
     mpu_get_dmp_state                  3      0      0
     mpu_get_fifo_config                3      0     48
     mpu_get_gyro_fsr                   2      0     48
     mpu_get_gyro_reg                   0      0     16
       -> I2C_Read                      0      0     32
     mpu_get_gyro_sens                  0      0     55
     mpu_get_int_status                 0      0     12
       -> I2C_Read                      0      0     24
     mpu_get_lpf                        2      0     48
     mpu_get_power_state                2      0      0
     mpu_get_sample_rate                2      0     48
     mpu_get_temperature                0      0     18
       -> I2C_Read                      0      0     36
     mpu_init                           0      0     18
       -> I2C_Write                     0      0     32
       -> delay_ms                      0      0     32
       -> I2C_Write                     0      0     32
       -> I2C_Read                      0      0     32
       -> memset                        0      0     36
       -> I2C_Read                      0      0     32
     mpu_load_firmware                  1      0     46
       -> mpu_write_mem                 0      0     84
       -> mpu_read_mem                  0      0     84
       -> memcmp                        0      0     84
       -> I2C_Write                     0      0     80
     mpu_lp_accel_mode                  1      0     27
       -> mpu_set_int_latched           0      0     24
       -> I2C_Write                     0      0     24
       -> mpu_set_int_latched           0      0     24
       -> mpu_set_lpf                   0      0     24
       -> mpu_set_lpf                   0      0     24
       -> mpu_set_lpf                   0      0     24
       -> mpu_set_lpf                   0      0     24
       -> I2C_Write                     0      0     24
       -> mpu_configure_fifo            0      0     24
     mpu_lp_motion_interrupt            1      0     15
       -> mpu_set_dmp_state             0      0     30
       -> mpu_get_gyro_fsr              0      0     30
       -> mpu_get_accel_fsr             0      0     30
       -> mpu_get_lpf                   0      0     30
       -> mpu_get_sample_rate           0      0     30
       -> mpu_get_fifo_config           0      0     30
       -> set_int_enable                0      0     30
       -> mpu_lp_accel_mode             0      0     30
       -> I2C_Write                     0      0     30
       -> I2C_Write                     0      0     30
       -> I2C_Write                     0      0     30
       -> delay_ms                      0      0     30
       -> I2C_Write                     0      0     30
       -> I2C_Write                     0      0     30
       -> mpu_set_sensors               0      0     30
       -> mpu_set_gyro_fsr              0      0     30
       -> mpu_set_accel_fsr             0      0     30
       -> mpu_set_lpf                   0      0     30
       -> mpu_set_sample_rate           0      0     30
       -> mpu_configure_fifo            0      0     30
       -> mpu_set_dmp_state             0      0     30
     mpu_read_fifo                      1      0     42
       -> I2C_Read                      0      0     72
       -> I2C_Read                      0      0     72
       -> mpu_reset_fifo                0      0     72
       -> I2C_Read                      0      0     72
     mpu_read_fifo_stream               1      0     20
       -> I2C_Read                      0      0     36
       -> I2C_Read                      0      0     36
       -> mpu_reset_fifo                0      0     36
       -> I2C_Read                      0      0     36
     mpu_read_mem                       2      0     56
       -> I2C_Write                     0      0     28
       -> I2C_Read                      0      0     28
     mpu_read_reg                       0      0      9
       -> I2C_Read                      0      0     18
     mpu_reg_dump                       0      0     11
       -> I2C_Read                      0      0     22
     mpu_reset_fifo                     0      0     47
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> delay_ms                      0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> delay_ms                      0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
     mpu_run_self_test                  0      0     94
       -> mpu_set_dmp_state             0      0     96
       -> mpu_get_gyro_fsr              0      0     96
       -> mpu_get_accel_fsr             0      0     96
       -> mpu_get_lpf                   0      0     96
       -> mpu_get_sample_rate           0      0     96
       -> mpu_get_fifo_config           0      0     96
       -> get_st_biases                 0      0     96
       -> get_st_biases                 0      0     96
       -> accel_self_test               0      0     96
       -> gyro_self_test                0      0     96
       -> mpu_set_gyro_fsr              0      0     96
       -> mpu_set_accel_fsr             0      0     96
       -> mpu_set_lpf                   0      0     96
       -> mpu_set_sample_rate           0      0     96
       -> mpu_set_sensors               0      0     96
       -> mpu_configure_fifo            0      0     96
       -> mpu_set_dmp_state             0      0     96
     mpu_set_accel_bias                 1      0     44
       -> I2C_Read                      0      0     88
       -> I2C_Read                      0      0     88
       -> I2C_Write                     0      0     88
     mpu_set_accel_fsr                  0      0     59
       -> I2C_Write                     0      0     22
     mpu_set_bypass                     0      0     21
       -> I2C_Read                      0      0     22
       -> I2C_Write                     0      0     22
       -> delay_ms                      0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Read                      0      0     22
       -> I2C_Write                     0      0     22
       -> delay_ms                      0      0     22
       -> I2C_Write                     0      0     22
     mpu_set_compass_sample_rate        0      0      0
     mpu_set_dmp_state                  1      0     58
       -> set_int_enable                0      0     20
       -> mpu_set_bypass                0      0     20
       -> mpu_set_sample_rate           0      0     20
       -> I2C_Write                     0      0     20
       -> set_int_enable                0      0     20
       -> mpu_reset_fifo                0      0     20
       -> set_int_enable                0      0     20
       -> I2C_Write                     0      0     20
       -> mpu_reset_fifo                0      0     20
     mpu_set_gyro_fsr                   0      0     59
       -> I2C_Write                     0      0     22
     mpu_set_int_latched                0      0     23
       -> I2C_Write                     0      0     22
     mpu_set_int_level                  2      0      0
     mpu_set_lpf                        0      0     59
       -> I2C_Write                     0      0     22
     mpu_set_sample_rate                1      0     59
       -> mpu_lp_accel_mode             0      0     22
       -> mpu_lp_accel_mode             0      0     22
       -> I2C_Write                     0      0     22
       -> mpu_set_lpf                   0      0     22
     mpu_set_sensors                    0      0     59
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> mpu_set_int_latched           0      0     22
       -> delay_ms                      0      0     22
     mpu_write_mem                      2      0     56
       -> I2C_Write                     0      0     28
       -> I2C_Write                     0      0     28
     run_self_test                      0      0     46
       -> mpu_run_self_test             0      0     92
       -> mpu_get_gyro_sens             0      0     92
       -> dmp_set_gyro_bias             0      0     92
       -> mpu_get_accel_sens            0      0     92
       -> dmp_set_accel_bias            0      0     92
     set_int_enable                     0      0     26
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22


   Segment part sizes:

     Function/Label                           Bytes
     --------------                           -----
     run_self_test                             334
     ??Subroutine105_0                           8
     ?Subroutine45                               8
     inv_orientation_matrix_to_scalar
                                                69
     ?Subroutine55                              13
     inv_row_2_scale                            72
     ?Subroutine57                               6
     ?Subroutine24                               1
     ??Subroutine106_0                          11
     ??Subroutine113_0                           2
     ??Subroutine114_0                           7
     ??Subroutine129_0                           8
     get_ms                                      3
     hw                                         10
     reg                                        27
     test                                       39
     st                                         35
     set_int_enable                            106
     ?Subroutine3                                2
     ??Subroutine115_0                           8
     ?Subroutine103                              8
     ?Subroutine104                              9
     ??Subroutine133_0                           7
     ?Subroutine95                               7
     ?Subroutine77                               4
     ?Subroutine101                             11
     ?Subroutine79                               2
     ??Subroutine134_0                           7
     ?Subroutine99                               9
     ??Subroutine138_0                           3
     ??Subroutine139_0                           9
     mpu_reg_dump                               80
     ?Subroutine47                              13
     ?Subroutine25                               9
     ?Subroutine68                               9
     ?Subroutine83                               6
     ?Subroutine98                              14
     mpu_read_reg                               57
     ?Subroutine4                                5
     ?Subroutine31                               4
     ?Subroutine76                               8
     ?Subroutine52                               4
     mpu_init                                  257
     ?Subroutine8                                5
     ?Subroutine67                              12
     ?Subroutine64                               4
     ?Subroutine78                               7
     ??Subroutine120_0                          12
     ?Subroutine85                               3
     ??Subroutine126_0                           4
     ?Subroutine100                              4
     ?Subroutine11                               3
     ??Subroutine127_0                           2
     ??Subroutine128_0                           9
     ?Subroutine93                              14
     ??Subroutine137_0                           6
     mpu_lp_accel_mode                         163
     ?Subroutine9                                5
     ?Subroutine69                              10
     ?Subroutine102                              8
     ?Subroutine10                               8
     ??Subroutine135_0                           3
     ??Subroutine136_0                           6
     mpu_get_gyro_reg                           88
     ?Subroutine46                              10
     ?Subroutine39                              12
     ?Subroutine28                              16
     ?Subroutine90                               6
     ?Subroutine48                              11
     mpu_get_accel_reg                          86
     ?Subroutine0                                2
     mpu_get_temperature                       190
     ?Subroutine84                               8
     ?Subroutine14                              11
     mpu_set_accel_bias                        573
     ?Subroutine71                               9
     ?Subroutine66                               1
     ??Subroutine107_0                           5
     ?Subroutine62                               8
     ?Subroutine41                              12
     ?Subroutine40                               9
     ?Subroutine36                               4
     ??Subroutine118_0                          10
     ??Subroutine119_0                           4
     ?Subroutine94                               8
     ?Subroutine88                               6
     mpu_reset_fifo                            263
     ?Subroutine34                               2
     ??Subroutine108_0                           1
     ??Subroutine109_0                           6
     ??Subroutine110_0                           8
     ?Subroutine20                               3
     ??Subroutine117_0                           8
     ?Subroutine33                               1
     ??Subroutine121_0                           1
     ??Subroutine122_0                           4
     ??Subroutine123_0                           4
     ?Subroutine82                              14
     ?Subroutine58                               1
     mpu_get_gyro_fsr                           78
     ??Subroutine112_0                           3
     mpu_set_gyro_fsr                          121
     ?Subroutine91                               6
     ??Subroutine111_0                           7
     ?Subroutine19                              14
     ?Subroutine87                              10
     ?Subroutine32                               9
     mpu_get_accel_fsr                          79
     mpu_set_accel_fsr                         111
     ??Subroutine124_0                          13
     ?Subroutine81                               4
     ?Subroutine97                              11
     mpu_get_lpf                                89
     mpu_set_lpf                               156
     mpu_get_sample_rate                        35
     ?Subroutine65                               3
     ??Subroutine132_0                           6
     mpu_set_sample_rate                       164
     ?Subroutine89                              10
     ?Subroutine37                               3
     mpu_get_compass_sample_rate                19
     mpu_set_compass_sample_rate                 0
     ?Subroutine2                                7
     mpu_get_gyro_sens                          67
     mpu_get_accel_sens                        104
     mpu_get_fifo_config                        10
     ?Subroutine1                                5
     mpu_configure_fifo                        112
     ??Subroutine131_0                           5
     mpu_get_power_state                        21
     mpu_set_sensors                           162
     mpu_get_int_status                         64
     mpu_read_fifo                             466
     ?Subroutine60                               2
     ??Subroutine116_0                          12
     ?Subroutine51                              10
     ?Subroutine42                              20
     ?Subroutine86                              13
     ?Subroutine43                               7
     ?Subroutine17                               8
     ?Subroutine12                              11
     ?Subroutine6                                8
     ?Subroutine21                              13
     ?Subroutine80                               7
     ?Subroutine92                              11
     mpu_read_fifo_stream                      215
     ?Subroutine18                               5
     mpu_set_bypass                            252
     mpu_set_int_level                          11
     mpu_set_int_latched                       107
     get_accel_prod_shift                      266
     ?Subroutine7                                8
     ?Subroutine30                               7
     accel_self_test                           255
     ?Subroutine73                              13
     ?Subroutine72                              14
     ?Subroutine63                              16
     ?Subroutine56                              20
     ?Subroutine53                               9
     ?Subroutine96                              11
     ?Subroutine75                               1
     gyro_self_test                            302
     get_st_biases                            1278
     ?Subroutine70                               3
     ?Subroutine35                               1
     ?Subroutine26                               6
     ?Subroutine23                               1
     ?Subroutine22                               3
     ??Subroutine125_0                           5
     ?Subroutine15                               6
     mpu_run_self_test                         304
     ?Subroutine74                               9
     ?Subroutine54                               9
     ?Subroutine38                               7
     ?Subroutine59                              23
     ?Subroutine50                               7
     ?Subroutine49                               7
     mpu_write_mem                             105
     ?Subroutine5                                2
     ??Subroutine130_0                           3
     ?Subroutine44                              12
     ?Subroutine27                              11
     ?Subroutine13                              39
     mpu_read_mem                              107
     mpu_load_firmware                         284
     ?Subroutine61                               9
     mpu_set_dmp_state                         100
     ?Subroutine29                              12
     mpu_get_dmp_state                          10
     mpu_get_compass_reg                         3
     mpu_get_compass_fsr                         3
     mpu_lp_motion_interrupt                   441
     ?Subroutine16                               9
     ?<Initializer for st>                      35
     __Constant_420c0000                         4
     __Constant_47800000                         4
     __Constant_43030000                         4
     __Constant_42830000                         4
     __Constant_42033333                         4
     __Constant_41833333                         4
     __Constant_0                                4
     __Constant_3eae147b                         4
     __Constant_3f845a1d                         4
     __Constant_37800000                         4
     __Constant_bf800000                         4
     __Constant_3e99999a                         4
     __Constant_3f733334                         4
     __Constant_41c80000                         4
     __Constant_3f85e354                         4
     __Constant_41200000                         4
     __Constant_42d20001                         4
     __Constant_83                               4
     __Constant_1                                4
     __Constant_ffff0000                         4
     __Constant_10000                            4
     ??run_self_test?relay                       6
     ??inv_orientation_matrix_to_scalar?relay    6
     ??inv_row_2_scale?relay                     6
     ??get_ms?relay                              6
     ??set_int_enable?relay                      6
     ??mpu_reg_dump?relay                        6
     ??mpu_read_reg?relay                        6
     ??mpu_init?relay                            6
     ??mpu_lp_accel_mode?relay                   6
     ??mpu_get_gyro_reg?relay                    6
     ??mpu_get_accel_reg?relay                   6
     ??mpu_get_temperature?relay                 6
     ??mpu_set_accel_bias?relay                  6
     ??mpu_reset_fifo?relay                      6
     ??mpu_get_gyro_fsr?relay                    6
     ??mpu_set_gyro_fsr?relay                    6
     ??mpu_get_accel_fsr?relay                   6
     ??mpu_set_accel_fsr?relay                   6
     ??mpu_get_lpf?relay                         6
     ??mpu_set_lpf?relay                         6
     ??mpu_get_sample_rate?relay                 6
     ??mpu_set_sample_rate?relay                 6
     ??mpu_get_compass_sample_rate?relay         6
     ??mpu_set_compass_sample_rate?relay         6
     ??mpu_get_gyro_sens?relay                   6
     ??mpu_get_accel_sens?relay                  6
     ??mpu_get_fifo_config?relay                 6
     ??mpu_configure_fifo?relay                  6
     ??mpu_get_power_state?relay                 6
     ??mpu_set_sensors?relay                     6
     ??mpu_get_int_status?relay                  6
     ??mpu_read_fifo?relay                       6
     ??mpu_read_fifo_stream?relay                6
     ??mpu_set_bypass?relay                      6
     ??mpu_set_int_level?relay                   6
     ??mpu_set_int_latched?relay                 6
     ??get_accel_prod_shift?relay                6
     ??accel_self_test?relay                     6
     ??gyro_self_test?relay                      6
     ??get_st_biases?relay                       6
     ??mpu_run_self_test?relay                   6
     ??mpu_write_mem?relay                       6
     ??mpu_read_mem?relay                        6
     ??mpu_load_firmware?relay                   6
     ??mpu_set_dmp_state?relay                   6
     ??mpu_get_dmp_state?relay                   6
     ??mpu_get_compass_reg?relay                 6
     ??mpu_get_compass_fsr?relay                 6
     ??mpu_lp_motion_interrupt?relay             6

 
 9 320 bytes in segment BANKED_CODE
   294 bytes in segment BANK_RELAYS
    35 bytes in segment XDATA_I
    35 bytes in segment XDATA_ID
   160 bytes in segment XDATA_ROM_C
 
 9 649 bytes of CODE  memory
    76 bytes of CONST memory (+ 84 bytes shared)
    35 bytes of XDATA memory

Errors: none
Warnings: 2

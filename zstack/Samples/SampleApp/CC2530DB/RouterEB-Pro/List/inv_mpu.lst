###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         25/Dec/2018  16:53:09 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\Source\MPU6050_DMP\inv_mpu.c                    #
#    Command line       =  -f F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú #
#                          \ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Samp #
#                          leApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.c #
#                          fg (-DCPU32MHZ -DROOT=__near_func                  #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE -DRTR_NWK         #
#                          -DBLINK_LEDS) -f F:\key_pro\AAAAAgraduation_projec #
#                          t\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530 #
#                          DB\f8wConfig.cfg (-DSECURE=0                       #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\Source\MPU6050_DMP\inv_mpu.c -D ZIGBEEPRO -D    #
#                          ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC  #
#                          -D LCD_SUPPORTED=DEBUG -D STM32F10X_MD -D          #
#                          USE_STDPERIPH_DRIVER -lC                           #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\RouterEB-Pro\List\ -lA                 #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\RouterEB-Pro\List\ --diag_suppress     #
#                          Pe001,Pa010 -o F:\key_pro\AAAAAgraduation_project\ #
#                          Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\ #
#                          Samples\SampleApp\CC2530DB\RouterEB-Pro\Obj\ -e    #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú #
#                          \ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Samp #
#                          leApp\CC2530DB\ -I F:\key_pro\AAAAAgraduation_proj #
#                          ect\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\SOURCE\ -I       #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\ZMAIN\TI2530DB\ -I            #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\ -I       #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\ #
#                           -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã– #
#                          Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Sam #
#                          pleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530EB\ -I F:\key_pro\AAAAAgraduation_project #
#                          \Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack #
#                          \Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONE #
#                          NTS\OSAL\MCU\CCSOC\ -I F:\key_pro\AAAAAgraduation_ #
#                          project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\OSAL\INCLUDE\ -I                        #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\    #
#                          -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú #
#                          \ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Samp #
#                          leApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK #
#                          \ -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã #
#                          –Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Sa #
#                          mpleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S #
#                          EC\ -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥ #
#                          ≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\ #
#                          SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK #
#                          \SAPI\ -I F:\key_pro\AAAAAgraduation_project\Ωªª•œ #
#                          µÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Sampl #
#                          es\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ST #
#                          ACK\SYS\ -I F:\key_pro\AAAAAgraduation_project\Ωªª #
#                          •œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ #
#                          STACK\ZDO\ -I F:\key_pro\AAAAAgraduation_project\Ω #
#                          ªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\S #
#                          amples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENT #
#                          S\ZMAC\F8W\ -I F:\key_pro\AAAAAgraduation_project\ #
#                          Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\ #
#                          Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\ZMAC\ -I F:\key_pro\AAAAAgraduation_project\Ωªª #
#                          •œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Sam #
#                          ples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ #
#                          SERVICES\SADDR\ -I F:\key_pro\AAAAAgraduation_proj #
#                          ect\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\SERVICES\SDATA\ -I                          #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\ #
#                           -I F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã– #
#                          Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\Sam #
#                          pleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\ -I F:\key_pro\AAAAAgraduation_project\Ωªª• #
#                          œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samp #
#                          les\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\M #
#                          AC\LOW_LEVEL\srf04\ -I F:\key_pro\AAAAAgraduation_ #
#                          project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -I     #
#                          F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\..\..\..\ -Ohz          #
#    List file          =  F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\RouterEB-Pro\List\inv_mpu.lst          #
#    Object file        =  F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ #
#                          ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\RouterEB-Pro\Obj\inv_mpu.r51           #
#                                                                             #
#                                                                             #
###############################################################################

F:\key_pro\AAAAAgraduation_project\Ωªª•œµÕ≥≥Ã–Ú\ ÷ª∑\ ÷ª∑\÷ª∑¢ÀÕ ˝æ›\Projects\zstack\Samples\SampleApp\Source\MPU6050_DMP\inv_mpu.c
      1          /*
      2           $License:
      3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
      4              See included License.txt for License information.
      5           $
      6           */
      7          /**
      8           *  @addtogroup  DRIVERS Sensor Driver Layer
      9           *  @brief       Hardware drivers to communicate with sensors via I2C.
     10           *
     11           *  @{
     12           *      @file       inv_mpu.c
     13           *      @brief      An I2C-based driver for Invensense gyroscopes.
     14           *      @details    This driver currently works for the following devices:
     15           *                  MPU6050
     16           *                  MPU6500
     17           *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
     18           *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
     19           *
     20           */
     21          
     22          
     23          //”≥…‰’‚Àƒ∏ˆ∫Ø ˝
     24          //#define i2c_write   I2C_Write
     25          //#define i2c_read    I2C_Read
     26          //#define delay_ms    delay_ms
     27          //#define get_ms      get_ms
     28          
     29          #include <stdio.h>
     30          #include <stdint.h>
     31          #include <stdlib.h>
     32          #include <string.h>
     33          #include <math.h>
     34          
     35          #include "inv_mpu.h"
     36          #include "iic.h"
     37          //#include "mpu6050.h"
     38          #include "delay.h"
     39          
     40          extern int I2C_Write(unsigned char addr, unsigned char reg, unsigned char len, unsigned char* data);
     41          extern int I2C_Read(unsigned char addr, unsigned char reg, unsigned char len, unsigned char *buf);
     42          int dmp_set_gyro_bias(long *bias) ;
     43          int dmp_set_accel_bias(long *bias);
     44          
     45          /* The following functions must be defined for this platform:
     46           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
     47           *      unsigned char length, unsigned char const *data)
     48           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
     49           *      unsigned char length, unsigned char *data)
     50           * delay_ms(unsigned long num_ms)
     51           * get_ms(unsigned long *count)
     52           * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
     53           * labs(long x)
     54           * fabsf(float x)
     55           * min(int a, int b)
     56           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     57          void run_self_test(void)
   \                     run_self_test:
     58          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
     59              int result;
     60          //    char test_packet[4] = {0};
     61              long gyro[3], accel[3];
     62          
     63              result = mpu_run_self_test(gyro, accel);
     64              if (result == 0x7) {
   \   00000A                ; Setup parameters for call to function mpu_run_self_test
   \   00000A   7406         MOV     A,#0x6
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   7412         MOV     A,#0x12
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??mpu_run_self_test?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   7407         MOV     A,#0x7
   \   000023   65..         XRL     A,?V0 + 0
   \   000025   7001         JNZ     ??run_self_test_0
   \   000027   EB           MOV     A,R3
   \                     ??run_self_test_0:
   \   000028   6003         JZ      $+5
   \   00002A   02....       LJMP    ??run_self_test_1 & 0xFFFF
     65                  /* Test passed. We can trust the gyro data here, so let's push it down
     66                   * to the DMP.
     67                   */
     68                  float sens;
     69                  unsigned short accel_sens;
     70                  mpu_get_gyro_sens(&sens);
   \   00002D                ; Setup parameters for call to function mpu_get_gyro_sens
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   AA82         MOV     R2,DPL
   \   000034   AB83         MOV     R3,DPH
   \   000036   12....       LCALL   ??mpu_get_gyro_sens?relay
     71                  gyro[0] = (long)(gyro[0] * sens);
   \   000039   7412         MOV     A,#0x12
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?L_MOV_X
   \   000043   78..         MOV     R0,#?V0 + 0
   \   000045   12....       LCALL   ?L_TO_FLT
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   78..         MOV     R0,#?V0 + 4
   \   00004F   12....       LCALL   ?L_MOV_X
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   79..         MOV     R1,#?V0 + 4
   \   000056   12....       LCALL   ?FLT_MUL
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?FLT_TO_L
   \   00005E   7412         MOV     A,#0x12
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_MOV_TO_X
     72                  gyro[1] = (long)(gyro[1] * sens);
   \   000068   7416         MOV     A,#0x16
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 0
   \   000074   12....       LCALL   ?L_TO_FLT
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   78..         MOV     R0,#?V0 + 4
   \   00007E   12....       LCALL   ?L_MOV_X
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   79..         MOV     R1,#?V0 + 4
   \   000085   12....       LCALL   ?FLT_MUL
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?FLT_TO_L
   \   00008D   7416         MOV     A,#0x16
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?L_MOV_TO_X
     73                  gyro[2] = (long)(gyro[2] * sens);
   \   000097   741A         MOV     A,#0x1a
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?L_MOV_X
   \   0000A1   78..         MOV     R0,#?V0 + 0
   \   0000A3   12....       LCALL   ?L_TO_FLT
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?L_MOV_X
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   79..         MOV     R1,#?V0 + 4
   \   0000B4   12....       LCALL   ?FLT_MUL
   \   0000B7   78..         MOV     R0,#?V0 + 0
   \   0000B9   12....       LCALL   ?FLT_TO_L
   \   0000BC   741A         MOV     A,#0x1a
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   78..         MOV     R0,#?V0 + 0
   \   0000C3   12....       LCALL   ?L_MOV_TO_X
     74                  dmp_set_gyro_bias(gyro);
   \   0000C6                ; Setup parameters for call to function dmp_set_gyro_bias
   \   0000C6   7412         MOV     A,#0x12
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   AA82         MOV     R2,DPL
   \   0000CD   AB83         MOV     R3,DPH
   \   0000CF   12....       LCALL   ??dmp_set_gyro_bias?relay
     75                  mpu_get_accel_sens(&accel_sens);
   \   0000D2                ; Setup parameters for call to function mpu_get_accel_sens
   \   0000D2   85..82       MOV     DPL,?XSP + 0
   \   0000D5   85..83       MOV     DPH,?XSP + 1
   \   0000D8   AA82         MOV     R2,DPL
   \   0000DA   AB83         MOV     R3,DPH
   \   0000DC   12....       LCALL   ??mpu_get_accel_sens?relay
     76                  accel[0] *= accel_sens;
   \   0000DF   85..82       MOV     DPL,?XSP + 0
   \   0000E2   85..83       MOV     DPH,?XSP + 1
   \   0000E5   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000E8   E4           CLR     A
   \   0000E9   F5..         MOV     ?V0 + 2,A
   \   0000EB   F5..         MOV     ?V0 + 3,A
   \   0000ED   7406         MOV     A,#0x6
   \   0000EF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F2   78..         MOV     R0,#?V0 + 4
   \   0000F4   12....       LCALL   ?L_MOV_X
   \   0000F7   78..         MOV     R0,#?V0 + 4
   \   0000F9   79..         MOV     R1,#?V0 + 0
   \   0000FB   12....       LCALL   ?L_MUL
   \   0000FE   7406         MOV     A,#0x6
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   78..         MOV     R0,#?V0 + 4
   \   000105   12....       LCALL   ?L_MOV_TO_X
     77                  accel[1] *= accel_sens;
   \   000108   740A         MOV     A,#0xa
   \   00010A   12....       LCALL   ?XSTACK_DISP0_8
   \   00010D   78..         MOV     R0,#?V0 + 4
   \   00010F   12....       LCALL   ?L_MOV_X
   \   000112   78..         MOV     R0,#?V0 + 4
   \   000114   79..         MOV     R1,#?V0 + 0
   \   000116   12....       LCALL   ?L_MUL
   \   000119   740A         MOV     A,#0xa
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   78..         MOV     R0,#?V0 + 4
   \   000120   12....       LCALL   ?L_MOV_TO_X
     78                  accel[2] *= accel_sens;
   \   000123   740E         MOV     A,#0xe
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   78..         MOV     R0,#?V0 + 4
   \   00012A   12....       LCALL   ?L_MOV_X
   \   00012D   78..         MOV     R0,#?V0 + 4
   \   00012F   79..         MOV     R1,#?V0 + 0
   \   000131   12....       LCALL   ?L_MUL
   \   000134   740E         MOV     A,#0xe
   \   000136   12....       LCALL   ?XSTACK_DISP0_8
   \   000139   78..         MOV     R0,#?V0 + 4
   \   00013B   12....       LCALL   ?L_MOV_TO_X
     79                  dmp_set_accel_bias(accel);
   \   00013E                ; Setup parameters for call to function dmp_set_accel_bias
   \   00013E   7406         MOV     A,#0x6
   \   000140   12....       LCALL   ?XSTACK_DISP0_8
   \   000143   AA82         MOV     R2,DPL
   \   000145   AB83         MOV     R3,DPH
   \   000147   12....       LCALL   ??dmp_set_accel_bias?relay
     80              }
     81          }
   \                     ??run_self_test_1:
   \   00014A   741E         MOV     A,#0x1e
   \   00014C   80..         SJMP    ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   22           RET
     82          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     83           unsigned short inv_orientation_matrix_to_scalar(
   \                     inv_orientation_matrix_to_scalar:
     84              const signed char *mtx)
     85          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
     86              unsigned short scalar;
     87          
     88              /*
     89                 XYZ  010_001_000 Identity Matrix
     90                 XZY  001_010_000
     91                 YXZ  010_000_001
     92                 YZX  000_010_001
     93                 ZXY  001_000_010
     94                 ZYX  000_001_010
     95               */
     96          
     97              scalar  = inv_row_2_scale(mtx);
   \   000009                ; Setup parameters for call to function inv_row_2_scale
   \   000009   12....       LCALL   ??inv_row_2_scale?relay
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
     98              scalar |= inv_row_2_scale(mtx + 3) << 3;
   \   000010                ; Setup parameters for call to function inv_row_2_scale
   \   000010   EE           MOV     A,R6
   \   000011   2403         ADD     A,#0x3
   \   000013   12....       LCALL   ?Subroutine55 & 0xFFFF
     99              scalar |= inv_row_2_scale(mtx + 6) << 6;
    100          
    101          
    102              return scalar;
   \                     ??CrossCallReturnLabel_87:
   \   000016   7403         MOV     A,#0x3
   \   000018   78..         MOV     R0,#?V0 + 2
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   E5..         MOV     A,?V0 + 0
   \   00001F   45..         ORL     A,?V0 + 2
   \   000021   F5..         MOV     ?V0 + 0,A
   \   000023   E5..         MOV     A,?V0 + 1
   \   000025   45..         ORL     A,?V0 + 3
   \   000027   F5..         MOV     ?V0 + 1,A
   \   000029                ; Setup parameters for call to function inv_row_2_scale
   \   000029   EE           MOV     A,R6
   \   00002A   2406         ADD     A,#0x6
   \   00002C   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00002F   7406         MOV     A,#0x6
   \   000031   78..         MOV     R0,#?V0 + 2
   \   000033   12....       LCALL   ?S_SHL
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   45..         ORL     A,?V0 + 2
   \   00003A   FA           MOV     R2,A
   \   00003B   E5..         MOV     A,?V0 + 1
   \   00003D   45..         ORL     A,?V0 + 3
   \   00003F   FB           MOV     R3,A
   \   000040   7F06         MOV     R7,#0x6
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
    103          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   FA           MOV     R2,A
   \   000001   EF           MOV     A,R7
   \   000002   3400         ADDC    A,#0x0
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??inv_row_2_scale?relay
   \   000008   8A..         MOV     ?V0 + 2,R2
   \   00000A   8B..         MOV     ?V0 + 3,R3
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    104           unsigned short inv_row_2_scale(const signed char *row)
   \                     inv_row_2_scale:
    105          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    106              unsigned short b;
    107          
    108              if (row[0] > 0)
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   00000B   4004         JC      ??inv_row_2_scale_0
    109                  b = 0;
   \   00000D   7A00         MOV     R2,#0x0
   \   00000F   8034         SJMP    ??inv_row_2_scale_1
    110              else if (row[0] < 0)
   \                     ??inv_row_2_scale_0:
   \   000011   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000014   5004         JNC     ??inv_row_2_scale_2
    111                  b = 4;
   \   000016   7A04         MOV     R2,#0x4
   \   000018   802B         SJMP    ??inv_row_2_scale_1
    112              else if (row[1] > 0)
   \                     ??inv_row_2_scale_2:
   \   00001A   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   00001D   4004         JC      ??inv_row_2_scale_3
    113                  b = 1;
   \   00001F   7A01         MOV     R2,#0x1
   \   000021   8022         SJMP    ??inv_row_2_scale_1
    114              else if (row[1] < 0)
   \                     ??inv_row_2_scale_3:
   \   000023   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000026   5004         JNC     ??inv_row_2_scale_4
    115                  b = 5;
   \   000028   7A05         MOV     R2,#0x5
   \   00002A   8019         SJMP    ??inv_row_2_scale_1
    116              else if (row[2] > 0)
   \                     ??inv_row_2_scale_4:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   A3           INC     DPTR
   \   000031   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000034   4004         JC      ??inv_row_2_scale_5
    117                  b = 2;
   \   000036   7A02         MOV     R2,#0x2
   \   000038   800B         SJMP    ??inv_row_2_scale_1
    118              else if (row[2] < 0)
   \                     ??inv_row_2_scale_5:
   \   00003A   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00003D   5004         JNC     ??inv_row_2_scale_6
    119                  b = 6;
   \   00003F   7A06         MOV     R2,#0x6
   \   000041   8002         SJMP    ??inv_row_2_scale_1
    120              else
    121                  b = 7;      // error
   \                     ??inv_row_2_scale_6:
   \   000043   7A07         MOV     R2,#0x7
   \                     ??inv_row_2_scale_1:
   \   000045   02....       LJMP    ??Subroutine112_0 & 0xFFFF
    122              return b;
    123          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   E8           MOV     A,R0
   \   000001   C3           CLR     C
   \   000002   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine105_0
   \   000001                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   C3           CLR     C
   \   000003   9401         SUBB    A,#0x1
   \   000005   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000007   65D0         XRL     A,PSW
   \   000009   33           RLC     A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   7B00         MOV     R3,#0x0
   \   000002                REQUIRE ??Subroutine113_0
   \   000002                ; // Fall through to label ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   9400         SUBB    A,#0x0
   \   000002   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000004   65D0         XRL     A,PSW
   \   000006   33           RLC     A
   \   000007   22           RET
    124          
    125          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    126          void get_ms(unsigned long *time)
   \                     get_ms:
    127          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    128          
    129          }
   \   000000   02....       LJMP    ?BRET
    130          
    131          #define MPU6050
    132          #define MOTION_DRIVER_TARGET_MSP430
    133          
    134          #if defined MOTION_DRIVER_TARGET_MSP430
    135          /*#include "msp430.h"
    136          #include "msp430_i2c.h"
    137          #include "msp430_clock.h"
    138          #include "msp430_interrupt.h" */
    139          
    140          #define i2c_write   I2C_Write
    141          #define i2c_read    I2C_Read
    142          #define delay_ms    delay_ms
    143          #define get_ms      get_ms
    144          
    145          //static int reg_int_cb(struct int_param_s *int_param)
    146          //{
    147          //    /*return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
    148          //        int_param->active_low);*/
    149          //		return 0;
    150          //}	  
    151          //#define log_i(...)     do {} while (0)
    152          //#define log_e(...)     do {} while (0)
    153          //#define log_e    PrintChar
    154          //#define log_i    PrintChar
    155          /* labs is already defined by TI's toolchain. */
    156          /* fabs is for doubles. fabsf is for floats. */
    157          ///////∂Œ–°—Û///////////////
    158          #define fabs(x)     (((x)>0)?(x):-(x))
    159          /////////////////////////////////
    160          //#define fabs        fabsf
    161          #define min(a,b) ((a<b)?a:b)
    162          
    163          #elif defined EMPL_TARGET_MSP430
    164          //#include "msp430.h"
    165          //#include "msp430_i2c.h"
    166          //#include "msp430_clock.h"
    167          //#include "msp430_interrupt.h"
    168          #include "log.h"
    169          #define i2c_write   msp430_i2c_write
    170          #define i2c_read    msp430_i2c_read
    171          #define delay_ms    msp430_delay_ms
    172          #define get_ms      msp430_get_clock_ms
    173          static inline int reg_int_cb(struct int_param_s *int_param)
    174          {
    175              return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
    176                  int_param->active_low);
    177          }
    178          #define log_i       MPL_LOGI
    179          #define log_e       MPL_LOGE
    180          /* labs is already defined by TI's toolchain. */
    181          /* fabs is for doubles. fabsf is for floats. */
    182          #define fabs        fabsf
    183          #define min(a,b) ((a<b)?a:b)
    184          #elif defined EMPL_TARGET_UC3L0
    185          /* Instead of using the standard TWI driver from the ASF library, we're using
    186           * a TWI driver that follows the slave address + register address convention.
    187           */
    188          #include "twi.h"
    189          #include "delay.h"
    190          #include "sysclk.h"
    191          #include "log.h"
    192          #include "sensors_xplained.h"
    193          #include "uc3l0_clock.h"
    194          #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
    195          #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
    196          /* delay_ms is a function already defined in ASF. */
    197          #define get_ms  uc3l0_get_clock_ms
    198          
    199          static inline int reg_int_cb(struct int_param_s *int_param)
    200          {
    201              sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
    202              return 0;
    203          }
    204          #define log_i       MPL_LOGI
    205          #define log_e       MPL_LOGE
    206          /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
    207          #define labs        abs
    208          #define fabs(x)     (((x)>0)?(x):-(x))
    209          #else
    210          //#error  Gyro driver is missing the system layer implementations.
    211          #endif
    212          
    213          #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
    214          //#error  Which gyro are you using? Define MPUxxxx in your compiler options.
    215          #endif
    216          
    217          /* Time for some messy macro work. =]
    218           * #define MPU9150
    219           * is equivalent to..
    220           * #define MPU6050
    221           * #define AK8975_SECONDARY
    222           *
    223           * #define MPU9250
    224           * is equivalent to..
    225           * #define MPU6500
    226           * #define AK8963_SECONDARY
    227           */
    228          #if defined MPU9150
    229          #ifndef MPU6050
    230          #define MPU6050
    231          #endif                          /* #ifndef MPU6050 */
    232          #if defined AK8963_SECONDARY
    233          #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
    234          #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
    235          #define AK8975_SECONDARY
    236          #endif                          /* #if defined AK8963_SECONDARY */
    237          #elif defined MPU9250           /* #if defined MPU9150 */
    238          #ifndef MPU6500
    239          #define MPU6500
    240          #endif                          /* #ifndef MPU6500 */
    241          #if defined AK8975_SECONDARY
    242          #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
    243          #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
    244          #define AK8963_SECONDARY
    245          #endif                          /* #if defined AK8975_SECONDARY */
    246          #endif                          /* #if defined MPU9150 */
    247          
    248          #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
    249          #define AK89xx_SECONDARY
    250          #else
    251          /* #warning "No compass = less profit for Invensense. Lame." */
    252          #endif
    253          
    254          static int set_int_enable(unsigned char enable);
    255          
    256          /* Hardware registers needed by driver. */
    257          struct gyro_reg_s {
    258              unsigned char who_am_i;
    259              unsigned char rate_div;
    260              unsigned char lpf;
    261              unsigned char prod_id;
    262              unsigned char user_ctrl;
    263              unsigned char fifo_en;
    264              unsigned char gyro_cfg;
    265              unsigned char accel_cfg;
    266          
    267              //unsigned char accel_cfg2;
    268          
    269              //unsigned char lp_accel_odr;
    270          
    271              unsigned char motion_thr;
    272              unsigned char motion_dur;
    273              unsigned char fifo_count_h;
    274              unsigned char fifo_r_w;
    275              unsigned char raw_gyro;
    276              unsigned char raw_accel;
    277              unsigned char temp;
    278              unsigned char int_enable;
    279              unsigned char dmp_int_status;
    280              unsigned char int_status;
    281          
    282              //unsigned char accel_intel;
    283          
    284              unsigned char pwr_mgmt_1;
    285              unsigned char pwr_mgmt_2;
    286              unsigned char int_pin_cfg;
    287              unsigned char mem_r_w;
    288              unsigned char accel_offs;
    289              unsigned char i2c_mst;
    290              unsigned char bank_sel;
    291              unsigned char mem_start_addr;
    292              unsigned char prgm_start_h;
    293          #if defined AK89xx_SECONDARY
    294              unsigned char s0_addr;
    295              unsigned char s0_reg;
    296              unsigned char s0_ctrl;
    297              unsigned char s1_addr;
    298              unsigned char s1_reg;
    299              unsigned char s1_ctrl;
    300              unsigned char s4_ctrl;
    301              unsigned char s0_do;
    302              unsigned char s1_do;
    303              unsigned char i2c_delay_ctrl;
    304              unsigned char raw_compass;
    305              /* The I2C_MST_VDDIO bit is in this register. */
    306              unsigned char yg_offs_tc;
    307          #endif
    308          };
    309          
    310          /* Information specific to a particular device. */
    311          struct hw_s {
    312              unsigned char addr;
    313              unsigned short max_fifo;
    314              unsigned char num_reg;
    315              unsigned short temp_sens;
    316              short temp_offset;
    317              unsigned short bank_size;
    318          #if defined AK89xx_SECONDARY
    319              unsigned short compass_fsr;
    320          #endif
    321          };
    322          
    323          /* When entering motion interrupt mode, the driver keeps track of the
    324           * previous state so that it can be restored at a later time.
    325           * TODO: This is tacky. Fix it.
    326           */
    327          struct motion_int_cache_s {
    328              unsigned short gyro_fsr;
    329              unsigned char accel_fsr;
    330              unsigned short lpf;
    331              unsigned short sample_rate;
    332              unsigned char sensors_on;
    333              unsigned char fifo_sensors;
    334              unsigned char dmp_on;
    335          };
    336          
    337          /* Cached chip configuration data.
    338           * TODO: A lot of these can be handled with a bitmask.
    339           */
    340          struct chip_cfg_s {
    341              /* Matches gyro_cfg >> 3 & 0x03 */
    342              unsigned char gyro_fsr;
    343              /* Matches accel_cfg >> 3 & 0x03 */
    344              unsigned char accel_fsr;
    345              /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
    346              unsigned char sensors;
    347              /* Matches config register. */
    348              unsigned char lpf;
    349              unsigned char clk_src;
    350              /* Sample rate, NOT rate divider. */
    351              unsigned short sample_rate;
    352              /* Matches fifo_en register. */
    353              unsigned char fifo_enable;
    354              /* Matches int enable register. */
    355              unsigned char int_enable;
    356              /* 1 if devices on auxiliary I2C bus appear on the primary. */
    357              unsigned char bypass_mode;
    358              /* 1 if half-sensitivity.
    359               * NOTE: This doesn't belong here, but everything else in hw_s is const,
    360               * and this allows us to save some precious RAM.
    361               */
    362              unsigned char accel_half;
    363              /* 1 if device in low-power accel-only mode. */
    364              unsigned char lp_accel_mode;
    365              /* 1 if interrupts are only triggered on motion events. */
    366              unsigned char int_motion_only;
    367              struct motion_int_cache_s cache;
    368              /* 1 for active low interrupts. */
    369              unsigned char active_low_int;
    370              /* 1 for latched interrupts. */
    371              unsigned char latched_int;
    372              /* 1 if DMP is enabled. */
    373              unsigned char dmp_on;
    374              /* Ensures that DMP will only be loaded once. */
    375              unsigned char dmp_loaded;
    376              /* Sampling rate used when DMP is enabled. */
    377              unsigned short dmp_sample_rate;
    378          #ifdef AK89xx_SECONDARY
    379              /* Compass sample rate. */
    380              unsigned short compass_sample_rate;
    381              unsigned char compass_addr;
    382              short mag_sens_adj[3];
    383          #endif
    384          };
    385          
    386          /* Information for self-test. */
    387          struct test_s {
    388              unsigned long gyro_sens;
    389              unsigned long accel_sens;
    390              unsigned char reg_rate_div;
    391              unsigned char reg_lpf;
    392              unsigned char reg_gyro_fsr;
    393              unsigned char reg_accel_fsr;
    394              unsigned short wait_ms;
    395              unsigned char packet_thresh;
    396              float min_dps;
    397              float max_dps;
    398              float max_gyro_var;
    399              float min_g;
    400              float max_g;
    401              float max_accel_var;
    402          };
    403          
    404          /* Gyro driver state variables. */
    405          struct gyro_state_s {
    406              const struct gyro_reg_s *reg;
    407              const struct hw_s *hw;
    408              struct chip_cfg_s chip_cfg;
    409              const struct test_s *test;
    410          };
    411          
    412          /* Filter configurations. */
    413          enum lpf_e {
    414              INV_FILTER_256HZ_NOLPF2 = 0,
    415              INV_FILTER_188HZ,
    416              INV_FILTER_98HZ,
    417              INV_FILTER_42HZ,
    418              INV_FILTER_20HZ,
    419              INV_FILTER_10HZ,
    420              INV_FILTER_5HZ,
    421              INV_FILTER_2100HZ_NOLPF,
    422              NUM_FILTER
    423          };
    424          
    425          /* Full scale ranges. */
    426          enum gyro_fsr_e {
    427              INV_FSR_250DPS = 0,
    428              INV_FSR_500DPS,
    429              INV_FSR_1000DPS,
    430              INV_FSR_2000DPS,
    431              NUM_GYRO_FSR
    432          };
    433          
    434          /* Full scale ranges. */
    435          enum accel_fsr_e {
    436              INV_FSR_2G = 0,
    437              INV_FSR_4G,
    438              INV_FSR_8G,
    439              INV_FSR_16G,
    440              NUM_ACCEL_FSR
    441          };
    442          
    443          /* Clock sources. */
    444          enum clock_sel_e {
    445              INV_CLK_INTERNAL = 0,
    446              INV_CLK_PLL,
    447              NUM_CLK
    448          };
    449          
    450          /* Low-power accel wakeup rates. */
    451          enum lp_accel_rate_e {
    452          #if defined MPU6050
    453              INV_LPA_1_25HZ,
    454              INV_LPA_5HZ,
    455              INV_LPA_20HZ,
    456              INV_LPA_40HZ
    457          #elif defined MPU6500
    458              INV_LPA_0_3125HZ,
    459              INV_LPA_0_625HZ,
    460              INV_LPA_1_25HZ,
    461              INV_LPA_2_5HZ,
    462              INV_LPA_5HZ,
    463              INV_LPA_10HZ,
    464              INV_LPA_20HZ,
    465              INV_LPA_40HZ,
    466              INV_LPA_80HZ,
    467              INV_LPA_160HZ,
    468              INV_LPA_320HZ,
    469              INV_LPA_640HZ
    470          #endif
    471          };
    472          
    473          #define BIT_I2C_MST_VDDIO   (0x80)
    474          #define BIT_FIFO_EN         (0x40)
    475          #define BIT_DMP_EN          (0x80)
    476          #define BIT_FIFO_RST        (0x04)
    477          #define BIT_DMP_RST         (0x08)
    478          #define BIT_FIFO_OVERFLOW   (0x10)
    479          #define BIT_DATA_RDY_EN     (0x01)
    480          #define BIT_DMP_INT_EN      (0x02)
    481          #define BIT_MOT_INT_EN      (0x40)
    482          #define BITS_FSR            (0x18)
    483          #define BITS_LPF            (0x07)
    484          #define BITS_HPF            (0x07)
    485          #define BITS_CLK            (0x07)
    486          #define BIT_FIFO_SIZE_1024  (0x40)
    487          #define BIT_FIFO_SIZE_2048  (0x80)
    488          #define BIT_FIFO_SIZE_4096  (0xC0)
    489          #define BIT_RESET           (0x80)
    490          #define BIT_SLEEP           (0x40)
    491          #define BIT_S0_DELAY_EN     (0x01)
    492          #define BIT_S2_DELAY_EN     (0x04)
    493          #define BITS_SLAVE_LENGTH   (0x0F)
    494          #define BIT_SLAVE_BYTE_SW   (0x40)
    495          #define BIT_SLAVE_GROUP     (0x10)
    496          #define BIT_SLAVE_EN        (0x80)
    497          #define BIT_I2C_READ        (0x80)
    498          #define BITS_I2C_MASTER_DLY (0x1F)
    499          #define BIT_AUX_IF_EN       (0x20)
    500          #define BIT_ACTL            (0x80)
    501          #define BIT_LATCH_EN        (0x20)
    502          #define BIT_ANY_RD_CLR      (0x10)
    503          #define BIT_BYPASS_EN       (0x02)
    504          #define BITS_WOM_EN         (0xC0)
    505          #define BIT_LPA_CYCLE       (0x20)
    506          #define BIT_STBY_XA         (0x20)
    507          #define BIT_STBY_YA         (0x10)
    508          #define BIT_STBY_ZA         (0x08)
    509          #define BIT_STBY_XG         (0x04)
    510          #define BIT_STBY_YG         (0x02)
    511          #define BIT_STBY_ZG         (0x01)
    512          #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
    513          #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
    514          
    515          #if defined AK8975_SECONDARY
    516          #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
    517          #define AK89xx_FSR                  (9830)
    518          #elif defined AK8963_SECONDARY
    519          #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
    520          #define AK89xx_FSR                  (4915)
    521          #endif
    522          
    523          #ifdef AK89xx_SECONDARY
    524          #define AKM_REG_WHOAMI      (0x00)
    525          
    526          #define AKM_REG_ST1         (0x02)
    527          #define AKM_REG_HXL         (0x03)
    528          #define AKM_REG_ST2         (0x09)
    529          
    530          #define AKM_REG_CNTL        (0x0A)
    531          #define AKM_REG_ASTC        (0x0C)
    532          #define AKM_REG_ASAX        (0x10)
    533          #define AKM_REG_ASAY        (0x11)
    534          #define AKM_REG_ASAZ        (0x12)
    535          
    536          #define AKM_DATA_READY      (0x01)
    537          #define AKM_DATA_OVERRUN    (0x02)
    538          #define AKM_OVERFLOW        (0x80)
    539          #define AKM_DATA_ERROR      (0x40)
    540          
    541          #define AKM_BIT_SELF_TEST   (0x40)
    542          
    543          #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
    544          #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
    545          #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
    546          #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
    547          
    548          #define AKM_WHOAMI      (0x48)
    549          #endif
    550          
    551          #if defined MPU6050
    552          /*
    553          const struct gyro_reg_s reg = {
    554             .who_am_i       = 0x75,
    555              .rate_div       = 0x19,
    556              .lpf            = 0x1A,
    557              .prod_id        = 0x0C,
    558              .user_ctrl      = 0x6A,
    559              .fifo_en        = 0x23,
    560              .gyro_cfg       = 0x1B,
    561              .accel_cfg      = 0x1C,
    562              .motion_thr     = 0x1F,
    563              .motion_dur     = 0x20,
    564              .fifo_count_h   = 0x72,
    565              .fifo_r_w       = 0x74,
    566              .raw_gyro       = 0x43,
    567              .raw_accel      = 0x3B,
    568              .temp           = 0x41,
    569              .int_enable     = 0x38,
    570              .dmp_int_status = 0x39,
    571              .int_status     = 0x3A,
    572              .pwr_mgmt_1     = 0x6B,
    573              .pwr_mgmt_2     = 0x6C,
    574              .int_pin_cfg    = 0x37,
    575              .mem_r_w        = 0x6F,
    576              .accel_offs     = 0x06,
    577              .i2c_mst        = 0x24,
    578              .bank_sel       = 0x6D,
    579              .mem_start_addr = 0x6E,
    580              .prgm_start_h   = 0x70
    581          #ifdef AK89xx_SECONDARY
    582              ,.raw_compass   = 0x49,
    583              .yg_offs_tc     = 0x01,
    584              .s0_addr        = 0x25,
    585              .s0_reg         = 0x26,
    586              .s0_ctrl        = 0x27,
    587              .s1_addr        = 0x28,
    588              .s1_reg         = 0x29,
    589              .s1_ctrl        = 0x2A,
    590              .s4_ctrl        = 0x34,
    591              .s0_do          = 0x63,
    592              .s1_do          = 0x64,
    593              .i2c_delay_ctrl = 0x67
    594          #endif
    595          };
    596          const struct hw_s hw = {
    597              .addr           = 0x68,
    598              .max_fifo       = 1024,
    599              .num_reg        = 118,
    600              .temp_sens      = 340,
    601              .temp_offset    = -521,
    602              .bank_size      = 256
    603          #if defined AK89xx_SECONDARY
    604              ,.compass_fsr    = AK89xx_FSR
    605          #endif
    606          };
    607          */

   \                                 In  segment XDATA_ROM_C, align 1
    608          const struct hw_s hw={
   \                     hw:
   \   000000   68           DB 104
   \   000001   0004         DW 1024
   \   000003   76           DB 118
   \   000004   5401         DW 340
   \   000006   F7FD         DW -521
   \   000008   0001         DW 256
    609            0x68,	 //addr
    610            1024,	 //max_fifo
    611            118,	 //num_reg
    612            340,	 //temp_sens
    613            -521,	 //temp_offset
    614            256	 //bank_size
    615          };

   \                                 In  segment XDATA_ROM_C, align 1
    616          const struct gyro_reg_s reg = {
   \                     reg:
   \   000000   75           DB 117
   \   000001   19           DB 25
   \   000002   1A           DB 26
   \   000003   0C           DB 12
   \   000004   6A           DB 106
   \   000005   23           DB 35
   \   000006   1B           DB 27
   \   000007   1C           DB 28
   \   000008   1F           DB 31
   \   000009   20           DB 32
   \   00000A   72           DB 114
   \   00000B   74           DB 116
   \   00000C   43           DB 67
   \   00000D   3B           DB 59
   \   00000E   41           DB 65
   \   00000F   38           DB 56
   \   000010   39           DB 57
   \   000011   3A           DB 58
   \   000012   6B           DB 107
   \   000013   6C           DB 108
   \   000014   37           DB 55
   \   000015   6F           DB 111
   \   000016   06           DB 6
   \   000017   24           DB 36
   \   000018   6D           DB 109
   \   000019   6E           DB 110
   \   00001A   70           DB 112
    617          0x75,  //who_am_i
    618          0x19,  //rate_div
    619          0x1A,  //lpf
    620          0x0C,  //prod_id
    621          0x6A,  //user_ctrl
    622          0x23,  //fifo_en
    623          0x1B,  //gyro_cfg
    624          0x1C,  //accel_cfg
    625          0x1F,  // motion_thr
    626          0x20,  // motion_dur
    627          0x72,  // fifo_count_h
    628          0x74,  // fifo_r_w
    629          0x43,  // raw_gyro
    630          0x3B,  // raw_accel
    631          0x41,  // temp
    632          0x38,  // int_enable
    633          0x39,  //  dmp_int_status
    634          0x3A,  //  int_status
    635          0x6B,  // pwr_mgmt_1
    636          0x6C,  // pwr_mgmt_2
    637          0x37,  // int_pin_cfg
    638          0x6F,  // mem_r_w
    639          0x06,  // accel_offs
    640          0x24,  // i2c_mst
    641          0x6D,  // bank_sel
    642          0x6E,  // mem_start_addr
    643          0x70   // prgm_start_h
    644          };
    645          
    646          //const struct test_s test = {
    647          //    .gyro_sens      = 32768/250,
    648          //    .accel_sens     = 32768/16,	  
    649          //    .reg_rate_div   = 0,    /* 1kHz. */
    650          //    .reg_lpf        = 1,    /* 188Hz. */
    651          //    .reg_gyro_fsr   = 0,    /* 250dps. */
    652          //    .reg_accel_fsr  = 0x18, /* 16g. */
    653          //    .wait_ms        = 50,
    654          //    .packet_thresh  = 5,    /* 5% */
    655          //    .min_dps        = 10.f,
    656          //    .max_dps        = 105.f,
    657          //    .max_gyro_var   = 0.14f,
    658          //    .min_g          = 0.3f,
    659          //    .max_g          = 0.95f,
    660          //    .max_accel_var  = 0.14f
    661          //};

   \                                 In  segment XDATA_ROM_C, align 1
    662          const struct test_s test={
   \                     test:
   \   000000   83000000     DD 131
   \   000004   00080000     DD 2048
   \   000008   00           DB 0
   \   000009   01           DB 1
   \   00000A   00           DB 0
   \   00000B   18           DB 24
   \   00000C   3200         DW 50
   \   00000E   05           DB 5
   \   00000F   00002041     DD 41200000H
   \   000013   0000D242     DD 42D20000H
   \   000017   295C0F3E     DD 3E0F5C29H
   \   00001B   9A99993E     DD 3E99999AH
   \   00001F   3333733F     DD 3F733333H
   \   000023   295C0F3E     DD 3E0F5C29H
    663          32768/250,		 //gyro_sens
    664          32768/16,		 //	accel_sens
    665          0,				 //	reg_rate_div
    666          1,				//	reg_lpf
    667          0,				 //	reg_gyro_fsr
    668          0x18,			//	reg_accel_fsr
    669          50,				//	wait_ms
    670          5,				//	packet_thresh
    671          10.0f,			 //	min_dps
    672          105.0f,			 //	max_dps
    673          0.14f,			//	max_gyro_var
    674          0.3f,		   //	min_g
    675          0.95f,		   //	max_g
    676          0.14f		   //	max_accel_var
    677          };
    678          /*
    679          static struct gyro_state_s st = {
    680              .reg = &reg,
    681              .hw = &hw,
    682              .test = &test
    683          };	*/

   \                                 In  segment XDATA_I, align 1, keep-with-next
    684          static struct gyro_state_s st={
   \                     st:
   \   000000                DS 35
   \   000023                REQUIRE `?<Initializer for st>`
   \   000023                REQUIRE __INIT_XDATA_I
    685            &reg,
    686            &hw,
    687            {0},
    688            &test
    689          };
    690          //st.chip_cfg.dmp_on = 1;
    691          //st.dhip_cfg.fifo_enabel = 1;
    692          /*
    693          #elif defined MPU6500
    694          const struct gyro_reg_s reg = {
    695              .who_am_i       = 0x75,
    696              .rate_div       = 0x19,
    697              .lpf            = 0x1A,
    698              .prod_id        = 0x0C,
    699              .user_ctrl      = 0x6A,
    700              .fifo_en        = 0x23,
    701              .gyro_cfg       = 0x1B,
    702              .accel_cfg      = 0x1C,
    703              .accel_cfg2     = 0x1D,
    704              .lp_accel_odr   = 0x1E,
    705              .motion_thr     = 0x1F,
    706              .motion_dur     = 0x20,
    707              .fifo_count_h   = 0x72,
    708              .fifo_r_w       = 0x74,
    709              .raw_gyro       = 0x43,
    710              .raw_accel      = 0x3B,
    711              .temp           = 0x41,
    712              .int_enable     = 0x38,
    713              .dmp_int_status = 0x39,
    714              .int_status     = 0x3A,
    715              .accel_intel    = 0x69,
    716              .pwr_mgmt_1     = 0x6B,
    717              .pwr_mgmt_2     = 0x6C,
    718              .int_pin_cfg    = 0x37,
    719              .mem_r_w        = 0x6F,
    720              .accel_offs     = 0x77,
    721              .i2c_mst        = 0x24,
    722              .bank_sel       = 0x6D,
    723              .mem_start_addr = 0x6E,
    724              .prgm_start_h   = 0x70
    725          #ifdef AK89xx_SECONDARY
    726              ,.raw_compass   = 0x49,
    727              .s0_addr        = 0x25,
    728              .s0_reg         = 0x26,
    729              .s0_ctrl        = 0x27,
    730              .s1_addr        = 0x28,
    731              .s1_reg         = 0x29,
    732              .s1_ctrl        = 0x2A,
    733              .s4_ctrl        = 0x34,
    734              .s0_do          = 0x63,
    735              .s1_do          = 0x64,
    736              .i2c_delay_ctrl = 0x67
    737          #endif
    738          };
    739          const struct hw_s hw = {
    740              .addr           = 0x68,
    741              .max_fifo       = 1024,
    742              .num_reg        = 128,
    743              .temp_sens      = 321,
    744              .temp_offset    = 0,
    745              .bank_size      = 256
    746          #if defined AK89xx_SECONDARY
    747              ,.compass_fsr    = AK89xx_FSR
    748          #endif
    749          };
    750          */
    751          //const struct test_s test = {
    752          //    .gyro_sens      = 32768/250,
    753          //    .accel_sens     = 32768/16,
    754          //    .reg_rate_div   = 0,    /* 1kHz. */
    755          //    .reg_lpf        = 1,    /* 188Hz. */
    756          //    .reg_gyro_fsr   = 0,    /* 250dps. */
    757          //    .reg_accel_fsr  = 0x18, /* 16g. */
    758          //    .wait_ms        = 50,
    759          //    .packet_thresh  = 5,    /* 5% */
    760          //    .min_dps        = 10.f,
    761          //    .max_dps        = 105.f,
    762          //    .max_gyro_var   = 0.14f,
    763          //    .min_g          = 0.3f,
    764          //    .max_g          = 0.95f,
    765          //    .max_accel_var  = 0.14f
    766          //};
    767          //
    768          //static struct gyro_state_s st = {
    769          //    .reg = &reg,
    770          //    .hw = &hw,
    771          //    .test = &test
    772          //};
    773          #endif
    774          
    775          #define MAX_PACKET_LENGTH (12)
    776          
    777          #ifdef AK89xx_SECONDARY
    778          static int setup_compass(void);
    779          #define MAX_COMPASS_SAMPLE_RATE (100)
    780          #endif
    781          
    782          /**
    783           *  @brief      Enable/disable data ready interrupt.
    784           *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
    785           *  interrupt is used.
    786           *  @param[in]  enable      1 to enable interrupt.
    787           *  @return     0 if successful.
    788           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    789          static int set_int_enable(unsigned char enable)
   \                     set_int_enable:
    790          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    791              unsigned char tmp;
    792          
    793              if (st.chip_cfg.dmp_on) {
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   601D         JZ      ??set_int_enable_0
    794                  if (enable)
   \   000012   EE           MOV     A,R6
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   6004         JZ      ??set_int_enable_1
    795                      tmp = BIT_DMP_INT_EN;
   \   00001B   7402         MOV     A,#0x2
   \   00001D   8001         SJMP    ??set_int_enable_2
    796                  else
    797                      tmp = 0x00;
   \                     ??set_int_enable_1:
   \   00001F   E4           CLR     A
   \                     ??set_int_enable_2:
   \   000020   12....       LCALL   ??Subroutine132_0 & 0xFFFF
    798                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
   \                     ??CrossCallReturnLabel_254:
   \   000023   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000026   6035         JZ      ??set_int_enable_3
    799                      return -1;
   \                     ??set_int_enable_4:
   \   000028   7AFF         MOV     R2,#-0x1
   \   00002A   7BFF         MOV     R3,#-0x1
   \                     ??set_int_enable_5:
   \   00002C   02....       LJMP    ?Subroutine3 & 0xFFFF
    800                  st.chip_cfg.int_enable = tmp;
    801              } else {
    802                  if (!st.chip_cfg.sensors)
   \                     ??set_int_enable_0:
   \   00002F   90....       MOV     DPTR,#st + 6
   \   000032   E0           MOVX    A,@DPTR
   \   000033   60F3         JZ      ??set_int_enable_4
    803                      return -1;
    804                  if (enable && st.chip_cfg.int_enable)
   \   000035   EE           MOV     A,R6
   \   000036   6016         JZ      ??set_int_enable_6
   \   000038   90....       MOV     DPTR,#st + 12
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6006         JZ      ??set_int_enable_7
    805                      return 0;
   \                     ??set_int_enable_8:
   \   00003E   7A00         MOV     R2,#0x0
   \   000040   7B00         MOV     R3,#0x0
   \   000042   80E8         SJMP    ??set_int_enable_5
    806                  if (enable)
    807                      tmp = BIT_DATA_RDY_EN;
   \                     ??set_int_enable_7:
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   7401         MOV     A,#0x1
   \   00004C   8007         SJMP    ??set_int_enable_9
    808                  else
    809                      tmp = 0x00;
   \                     ??set_int_enable_6:
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   E4           CLR     A
    810                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
    811                      return -1;
    812                  st.chip_cfg.int_enable = tmp;
    813              }
   \                     ??set_int_enable_9:
   \   000055   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   000058   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   00005B   70CB         JNZ     ??set_int_enable_4
   \                     ??set_int_enable_3:
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   90....       MOV     DPTR,#st + 12
   \   000067   F0           MOVX    @DPTR,A
   \   000068   80D4         SJMP    ??set_int_enable_8
    814              return 0;
    815          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7401         MOV     A,#0x1
   \   000002                REQUIRE ??Subroutine114_0
   \   000002                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F02         MOV     R7,#0x2
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001   AC82         MOV     R4,DPL
   \   000003   AD83         MOV     R5,DPH
   \   000005   7B01         MOV     R3,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   240F         ADD     A,#0xf
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000003   90....       MOV     DPTR,#st
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F9           MOV     R1,A
   \   000006   8882         MOV     DPL,R0
   \   000008   8983         MOV     DPH,R1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002                REQUIRE ??Subroutine133_0
   \   000002                ; // Fall through to label ??Subroutine133_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   000003   12....       LCALL   ??I2C_Write?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000003                REQUIRE ??Subroutine138_0
   \   000003                ; // Fall through to label ??Subroutine138_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000003   8B..         MOV     ?V0 + 1,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 1
   \   000008   22           RET
    816          
    817          /**
    818           *  @brief      Register dump for testing.
    819           *  @return     0 if successful.
    820           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    821          int mpu_reg_dump(void)
   \                     mpu_reg_dump:
    822          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    823              unsigned char ii;
    824              unsigned char data;
    825          
    826              for (ii = 0; ii < st.hw->num_reg; ii++) {
   \   00000A   7E00         MOV     R6,#0x0
   \   00000C   8001         SJMP    ??mpu_reg_dump_0
   \                     ??mpu_reg_dump_1:
   \   00000E   0E           INC     R6
   \                     ??mpu_reg_dump_0:
   \   00000F   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000012   5035         JNC     ??mpu_reg_dump_2
    827                  if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
   \   000014   90....       MOV     DPTR,#st
   \   000017   E0           MOVX    A,@DPTR
   \   000018   240B         ADD     A,#0xb
   \   00001A   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   00001D   60EF         JZ      ??mpu_reg_dump_1
   \   00001F   90....       MOV     DPTR,#st
   \   000022   E0           MOVX    A,@DPTR
   \   000023   2415         ADD     A,#0x15
   \   000025   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000028   60E4         JZ      ??mpu_reg_dump_1
    828                      continue;
    829                  if (i2c_read(st.hw->addr, ii, 1, &data))
   \   00002A                ; Setup parameters for call to function I2C_Read
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   AC82         MOV     R4,DPL
   \   000032   AD83         MOV     R5,DPH
   \   000034   7B01         MOV     R3,#0x1
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   8882         MOV     DPL,R0
   \   00003A   8983         MOV     DPH,R1
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000041   60CB         JZ      ??mpu_reg_dump_1
    830                      return -1;
   \   000043   7AFF         MOV     R2,#-0x1
   \   000045   7BFF         MOV     R3,#-0x1
   \   000047   8004         SJMP    ??mpu_reg_dump_3
    831                  //log_i("%#5x: %#5x\r\n", ii, data);
    832              }
    833              return 0;
   \                     ??mpu_reg_dump_2:
   \   000049   7A00         MOV     R2,#0x0
   \   00004B   7B00         MOV     R3,#0x0
   \                     ??mpu_reg_dump_3:
   \   00004D   02....       LJMP    ?Subroutine3 & 0xFFFF
    834          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   FB           MOV     R3,A
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   6E           XRL     A,R6
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   EE           MOV     A,R6
   \   000006   C3           CLR     C
   \   000007   9A           SUBB    A,R2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ??I2C_Read?relay
   \   000003   8B..         MOV     ?V0 + 1,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   8882         MOV     DPL,R0
   \   00000A   8983         MOV     DPH,R1
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET
    835          
    836          /**
    837           *  @brief      Read from a single register.
    838           *  NOTE: The memory and FIFO read/write registers cannot be accessed.
    839           *  @param[in]  reg     Register address.
    840           *  @param[out] data    Register data.
    841           *  @return     0 if successful.
    842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    843          int mpu_read_reg(unsigned char reg, unsigned char *data)
   \                     mpu_read_reg:
    844          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
    845              if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
   \   00000B   90....       MOV     DPTR,#st
   \   00000E   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000011   6E           XRL     A,R6
   \   000012   600D         JZ      ??mpu_read_reg_0
   \   000014   90....       MOV     DPTR,#st
   \   000017   E0           MOVX    A,@DPTR
   \   000018   2415         ADD     A,#0x15
   \   00001A   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6E           XRL     A,R6
   \   00001F   7006         JNZ     ??mpu_read_reg_1
    846                  return -1;
   \                     ??mpu_read_reg_0:
   \   000021   7AFF         MOV     R2,#-0x1
   \   000023   7BFF         MOV     R3,#-0x1
   \   000025   8012         SJMP    ??mpu_read_reg_2
    847              if (reg >= st.hw->num_reg)
   \                     ??mpu_read_reg_1:
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   00002A   50F5         JNC     ??mpu_read_reg_0
    848                  return -1;
    849              return i2c_read(st.hw->addr, reg, 1, data);
   \   00002C                ; Setup parameters for call to function I2C_Read
   \   00002C   7B01         MOV     R3,#0x1
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   8882         MOV     DPL,R0
   \   000032   8983         MOV     DPH,R1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F9           MOV     R1,A
   \   000036   12....       LCALL   ??I2C_Read?relay
   \                     ??mpu_read_reg_2:
   \   000039                REQUIRE ?Subroutine4
   \   000039                ; // Fall through to label ?Subroutine4
    850          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   240B         ADD     A,#0xb
   \   000003   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000003   22           RET
    851          
    852          /**
    853           *  @brief      Initialize hardware.
    854           *  Initial configuration:\n
    855           *  Gyro FSR: +/- 2000DPS\n
    856           *  Accel FSR +/- 2G\n
    857           *  DLPF: 42Hz\n
    858           *  FIFO rate: 50Hz\n
    859           *  Clock source: Gyro PLL\n
    860           *  FIFO: Disabled.\n
    861           *  Data ready interrupt: Disabled, active low, unlatched.
    862           *  @param[in]  int_param   Platform-specific parameters to interrupt API.
    863           *  @return     0 if successful.
    864           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    865          int mpu_init(void)
   \                     mpu_init:
    866          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    867              unsigned char data[6], rev;
    868          
    869              /* Reset device. */
    870              data[0] = 0x80;//BIT_RESET;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7480         MOV     A,#-0x80
   \   000012   12....       LCALL   ?Subroutine63 & 0xFFFF
    871              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0])))
   \                     ??CrossCallReturnLabel_100:
   \   000015   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000018   6007         JZ      ??mpu_init_0
    872                  return -1;
   \                     ??mpu_init_1:
   \   00001A   7AFF         MOV     R2,#-0x1
   \   00001C   7BFF         MOV     R3,#-0x1
   \   00001E   02....       LJMP    ??mpu_init_2 & 0xFFFF
    873              delay_ms(100);
   \                     ??mpu_init_0:
   \   000021                ; Setup parameters for call to function delay_ms
   \   000021   7A64         MOV     R2,#0x64
   \   000023   12....       LCALL   ?Subroutine66 & 0xFFFF
    874          
    875              /* Wake up chip. */
    876              data[0] = 0x00;
   \                     ??CrossCallReturnLabel_103:
   \   000026   E4           CLR     A
   \   000027   12....       LCALL   ?Subroutine63 & 0xFFFF
    877              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0])))
   \                     ??CrossCallReturnLabel_101:
   \   00002A   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   00002D   70EB         JNZ     ??mpu_init_1
    878                  return -1;
    879           
    880          #if defined MPU6050
    881              /* Check product revision. */
    882              if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
   \   00002F                ; Setup parameters for call to function I2C_Read
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   AC82         MOV     R4,DPL
   \   000037   AD83         MOV     R5,DPH
   \   000039   7B06         MOV     R3,#0x6
   \   00003B   90....       MOV     DPTR,#st
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   2416         ADD     A,#0x16
   \   000041   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000044   70D4         JNZ     ??mpu_init_1
    883                  return -1;
    884              rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
    885                  (data[1] & 0x01);
   \   000046   7401         MOV     A,#0x1
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   E4           CLR     A
   \   00004F   33           RLC     A
   \   000050   F9           MOV     R1,A
   \   000051   7403         MOV     A,#0x3
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   E0           MOVX    A,@DPTR
   \   000057   A2E0         MOV     C,0xE0 /* A   */.0
   \   000059   E4           CLR     A
   \   00005A   33           RLC     A
   \   00005B   33           RLC     A
   \   00005C   F8           MOV     R0,A
   \   00005D   7405         MOV     A,#0x5
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   E0           MOVX    A,@DPTR
   \   000063   A2E0         MOV     C,0xE0 /* A   */.0
   \   000065   E4           CLR     A
   \   000066   33           RLC     A
   \   000067   33           RLC     A
   \   000068   33           RLC     A
   \   000069   48           ORL     A,R0
   \   00006A   49           ORL     A,R1
   \   00006B   F8           MOV     R0,A
    886          		
    887              if (rev) {
   \   00006C   7003         JNZ     $+5
   \   00006E   02....       LJMP    ??mpu_init_3 & 0xFFFF
    888                  /* Congrats, these parts are better. */
    889                  if (rev == 1)
   \   000071   7401         MOV     A,#0x1
   \   000073   68           XRL     A,R0
   \   000074   6003         JZ      $+5
   \   000076   02....       LJMP    ??mpu_init_4 & 0xFFFF
    890                      st.chip_cfg.accel_half = 1;
   \                     ??mpu_init_5:
   \   000079   90....       MOV     DPTR,#st + 14
   \   00007C   7401         MOV     A,#0x1
   \                     ??mpu_init_6:
   \   00007E   F0           MOVX    @DPTR,A
    891                  else if (rev == 2)
    892                      st.chip_cfg.accel_half = 0;
    893                  else {
    894                      //log_e("Unsupported software product rev %d.\n");
    895                      return -1;
    896                  }
    897              } else {
    898                  if (i2c_read(st.hw->addr, st.reg->prod_id, 1, &(data[0])))
    899                      return -1;
    900                  rev = data[0] & 0x0F;
    901                  if (!rev) {
    902                     // log_e("Product ID read as 0 indicates device is either "
    903                          //"incompatible or an MPU3050.\n");
    904                      return -1;
    905                  } else if (rev == 4) {
    906                      //log_i("Half sensitivity part found.\n");
    907                      st.chip_cfg.accel_half = 1;
    908                  } else
    909                      st.chip_cfg.accel_half = 0;
    910              }
    911          ////////////////////////////Œ¥÷¥––//////////////////////////////
    912          #elif defined MPU6500
    913          #define MPU6500_MEM_REV_ADDR    (0x17)
    914              if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
    915                  return -1;
    916              if (rev == 0x1)
    917                  st.chip_cfg.accel_half = 0;
    918              else {
    919                  //log_e("Unsupported software product rev %d.\n", rev);
    920                  return -1;
    921              }
    922          
    923              /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
    924               * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
    925               */
    926              data[0] = BIT_FIFO_SIZE_1024 | 0x8;
    927              if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
    928                  return -1;
    929          #endif
    930          /////////////////////////////////////////////////////////
    931              /* Set to invalid values to ensure no I2C writes are skipped. */
    932              st.chip_cfg.sensors = 0xFF;
   \   00007F   90....       MOV     DPTR,#st + 6
   \   000082   74FF         MOV     A,#-0x1
   \   000084   F0           MOVX    @DPTR,A
    933              st.chip_cfg.gyro_fsr = 0xFF;
   \   000085   90....       MOV     DPTR,#st + 4
   \   000088   12....       LCALL   ?Subroutine92 & 0xFFFF
    934              st.chip_cfg.accel_fsr = 0xFF;
    935              st.chip_cfg.lpf = 0xFF;
    936              st.chip_cfg.sample_rate = 0xFFFF;
    937              st.chip_cfg.fifo_enable = 0xFF;
   \                     ??CrossCallReturnLabel_145:
   \   00008B   A3           INC     DPTR
   \   00008C   F0           MOVX    @DPTR,A
    938              st.chip_cfg.bypass_mode = 0xFF;
   \   00008D   90....       MOV     DPTR,#st + 13
   \   000090   F0           MOVX    @DPTR,A
    939          //////////////////////////////////Œ¥÷¥––//////////////////////////////
    940          #ifdef AK89xx_SECONDARY
    941              st.chip_cfg.compass_sample_rate = 0xFFFF;
    942          #endif
    943          //////////////////////////////////////////////////////////////////////
    944              /* mpu_set_sensors always preserves this setting. */
    945              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   000091   90....       MOV     DPTR,#st + 8
   \   000094   7401         MOV     A,#0x1
   \   000096   F0           MOVX    @DPTR,A
    946              /* Handled in next call to mpu_set_bypass. */
    947              st.chip_cfg.active_low_int = 1;
   \   000097   90....       MOV     DPTR,#st + 27
   \   00009A   F0           MOVX    @DPTR,A
    948              st.chip_cfg.latched_int = 0;
   \   00009B   A3           INC     DPTR
   \   00009C   E4           CLR     A
   \   00009D   F0           MOVX    @DPTR,A
    949              st.chip_cfg.int_motion_only = 0;
   \   00009E   90....       MOV     DPTR,#st + 16
   \   0000A1   F0           MOVX    @DPTR,A
    950              st.chip_cfg.lp_accel_mode = 0;
   \   0000A2   90....       MOV     DPTR,#st + 15
   \   0000A5   F0           MOVX    @DPTR,A
    951              memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
   \   0000A6                ; Setup parameters for call to function memset
   \   0000A6   75..0A       MOV     ?V0 + 0,#0xa
   \   0000A9   F5..         MOV     ?V0 + 1,A
   \   0000AB   78..         MOV     R0,#?V0 + 0
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B0   7C00         MOV     R4,#0x0
   \   0000B2   7D00         MOV     R5,#0x0
   \   0000B4   7A..         MOV     R2,#(st + 17) & 0xff
   \   0000B6   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   0000B8   12....       LCALL   ??memset?relay
   \   0000BB   7402         MOV     A,#0x2
   \   0000BD   12....       LCALL   ?DEALLOC_XSTACK8
    952              st.chip_cfg.dmp_on = 0;
   \   0000C0   90....       MOV     DPTR,#st + 29
   \   0000C3   E4           CLR     A
   \   0000C4   F0           MOVX    @DPTR,A
    953              st.chip_cfg.dmp_loaded = 0;
   \   0000C5   A3           INC     DPTR
   \   0000C6   F0           MOVX    @DPTR,A
    954              st.chip_cfg.dmp_sample_rate = 0;
   \   0000C7   A3           INC     DPTR
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   F0           MOVX    @DPTR,A
    955              if (mpu_set_gyro_fsr(2000))
   \   0000CB                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   0000CB   7AD0         MOV     R2,#-0x30
   \   0000CD   7B07         MOV     R3,#0x7
   \   0000CF   12....       LCALL   ??mpu_set_gyro_fsr?relay
   \   0000D2   8B..         MOV     ?V0 + 1,R3
   \   0000D4   EA           MOV     A,R2
   \   0000D5   45..         ORL     A,?V0 + 1
   \   0000D7   6003         JZ      $+5
   \   0000D9   02....       LJMP    ??mpu_init_1 & 0xFFFF
    956                  return -1;
    957              if (mpu_set_accel_fsr(2))
   \   0000DC                ; Setup parameters for call to function mpu_set_accel_fsr
   \   0000DC   7902         MOV     R1,#0x2
   \   0000DE   12....       LCALL   ??mpu_set_accel_fsr?relay
   \   0000E1   8B..         MOV     ?V0 + 1,R3
   \   0000E3   EA           MOV     A,R2
   \   0000E4   45..         ORL     A,?V0 + 1
   \   0000E6   6003         JZ      $+5
   \   0000E8   02....       LJMP    ??mpu_init_1 & 0xFFFF
    958                  return -1;
    959              if (mpu_set_lpf(42))
   \   0000EB                ; Setup parameters for call to function mpu_set_lpf
   \   0000EB   7A2A         MOV     R2,#0x2a
   \   0000ED   7B00         MOV     R3,#0x0
   \   0000EF   12....       LCALL   ??mpu_set_lpf?relay
   \   0000F2   8B..         MOV     ?V0 + 1,R3
   \   0000F4   EA           MOV     A,R2
   \   0000F5   45..         ORL     A,?V0 + 1
   \   0000F7   6003         JZ      $+5
   \   0000F9   02....       LJMP    ??mpu_init_1 & 0xFFFF
    960                  return -1;
    961              if (mpu_set_sample_rate(50))
   \   0000FC                ; Setup parameters for call to function mpu_set_sample_rate
   \   0000FC   7A32         MOV     R2,#0x32
   \   0000FE   7B00         MOV     R3,#0x0
   \   000100   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000103   8B..         MOV     ?V0 + 1,R3
   \   000105   EA           MOV     A,R2
   \   000106   45..         ORL     A,?V0 + 1
   \   000108   6003         JZ      $+5
   \   00010A   02....       LJMP    ??mpu_init_1 & 0xFFFF
    962                  return -1;
    963              if (mpu_configure_fifo(0))
   \   00010D                ; Setup parameters for call to function mpu_configure_fifo
   \   00010D   7900         MOV     R1,#0x0
   \   00010F   12....       LCALL   ??mpu_configure_fifo?relay
   \   000112   8B..         MOV     ?V0 + 1,R3
   \   000114   EA           MOV     A,R2
   \   000115   45..         ORL     A,?V0 + 1
   \   000117   6003         JZ      $+5
   \   000119   02....       LJMP    ??mpu_init_1 & 0xFFFF
    964                  return -1;
    965          
    966              /*if (int_param)
    967                  reg_int_cb(int_param);*/
    968          ////////////////////////////////Œ¥÷¥––///////////////////////////////
    969          #ifdef AK89xx_SECONDARY
    970              setup_compass();
    971              if (mpu_set_compass_sample_rate(10))
    972                  return -1;
    973          ///////////////////////////////////////////////////////////////////////
    974          #else
    975          ////////////////////////////////ø…»•≥˝///////////////////////////////////
    976          				//printf("lalala");
    977              /* Already disabled by setup_compass. */
    978              if (mpu_set_bypass(0))
   \   00011C                ; Setup parameters for call to function mpu_set_bypass
   \   00011C   7900         MOV     R1,#0x0
   \   00011E   12....       LCALL   ??mpu_set_bypass?relay
   \   000121   8B..         MOV     ?V0 + 1,R3
   \   000123   EA           MOV     A,R2
   \   000124   45..         ORL     A,?V0 + 1
   \   000126   6003         JZ      $+5
   \   000128   02....       LJMP    ??mpu_init_1 & 0xFFFF
    979                  return -1;
    980          /////////////////////////////////////////////////////////////////////////
    981          #endif
    982          
    983              mpu_set_sensors(0);
   \   00012B                ; Setup parameters for call to function mpu_set_sensors
   \   00012B   7900         MOV     R1,#0x0
   \   00012D   12....       LCALL   ??mpu_set_sensors?relay
    984              return 0;
   \   000130   7A00         MOV     R2,#0x0
   \   000132   7B00         MOV     R3,#0x0
   \                     ??mpu_init_2:
   \   000134   02....       LJMP    ?Subroutine8 & 0xFFFF
   \                     ??mpu_init_4:
   \   000137   7402         MOV     A,#0x2
   \   000139   68           XRL     A,R0
   \   00013A   6003         JZ      $+5
   \   00013C   02....       LJMP    ??mpu_init_1 & 0xFFFF
   \                     ??mpu_init_7:
   \   00013F   90....       MOV     DPTR,#st + 14
   \   000142   E4           CLR     A
   \   000143   02....       LJMP    ??mpu_init_6 & 0xFFFF
   \                     ??mpu_init_3:
   \   000146                ; Setup parameters for call to function I2C_Read
   \   000146   85..82       MOV     DPL,?XSP + 0
   \   000149   85..83       MOV     DPH,?XSP + 1
   \   00014C   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   00014F   A3           INC     DPTR
   \   000150   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000153   6003         JZ      $+5
   \   000155   02....       LJMP    ??mpu_init_1 & 0xFFFF
   \   000158   85..82       MOV     DPL,?XSP + 0
   \   00015B   85..83       MOV     DPH,?XSP + 1
   \   00015E   E0           MOVX    A,@DPTR
   \   00015F   540F         ANL     A,#0xf
   \   000161   F8           MOV     R0,A
   \   000162   7003         JNZ     $+5
   \   000164   02....       LJMP    ??mpu_init_1 & 0xFFFF
   \   000167   7404         MOV     A,#0x4
   \   000169   68           XRL     A,R0
   \   00016A   70D3         JNZ     ??mpu_init_7
   \   00016C   02....       LJMP    ??mpu_init_5 & 0xFFFF
    985          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7406         MOV     A,#0x6
   \   000002   02....       LJMP    ??Subroutine114_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??delay_ms?relay
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   000003   12....       LCALL   ??I2C_Read?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   90....       MOV     DPTR,#st
   \   000003                REQUIRE ??Subroutine125_0
   \   000003                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003                REQUIRE ??Subroutine126_0
   \   000003                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002                REQUIRE ??Subroutine127_0
   \   000002                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000003   8B..         MOV     ?V0 + 1,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   90....       MOV     DPTR,#st + 7
   \   000006   F0           MOVX    @DPTR,A
   \   000007   90....       MOV     DPTR,#st + 9
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   90....       MOV     DPTR,#st
   \   000003   E0           MOVX    A,@DPTR
   \   000004   2412         ADD     A,#0x12
   \   000006                REQUIRE ??Subroutine137_0
   \   000006                ; // Fall through to label ??Subroutine137_0
    986          
    987          /**
    988           *  @brief      Enter low-power accel-only mode.
    989           *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
    990           *  the accelerometer at one of the following frequencies:
    991           *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
    992           *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
    993           *  \n If the requested rate is not one listed above, the device will be set to
    994           *  the next highest rate. Requesting a rate above the maximum supported
    995           *  frequency will result in an error.
    996           *  \n To select a fractional wake-up frequency, round down the value passed to
    997           *  @e rate.
    998           *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
    999           *                          accel mode.
   1000           *  @return     0 if successful.
   1001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1002          int mpu_lp_accel_mode(unsigned char rate)
   \                     mpu_lp_accel_mode:
   1003          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1004              unsigned char tmp[2];
   1005          
   1006              if (rate > 40)
   \   00000C   C3           CLR     C
   \   00000D   9429         SUBB    A,#0x29
   \   00000F   4007         JC      ??mpu_lp_accel_mode_0
   1007                  return -1;
   \                     ??mpu_lp_accel_mode_1:
   \   000011   7AFF         MOV     R2,#-0x1
   \   000013   7BFF         MOV     R3,#-0x1
   \   000015   02....       LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
   1008          
   1009              if (!rate) {
   \                     ??mpu_lp_accel_mode_0:
   \   000018   EE           MOV     A,R6
   \   000019   701B         JNZ     ??mpu_lp_accel_mode_3
   1010                  mpu_set_int_latched(0);
   \   00001B                ; Setup parameters for call to function mpu_set_int_latched
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   12....       LCALL   ?Subroutine69 & 0xFFFF
   1011                  tmp[0] = 0;
   \                     ??CrossCallReturnLabel_109:
   \   000020   E4           CLR     A
   \   000021   F0           MOVX    @DPTR,A
   1012                  tmp[1] = BIT_STBY_XYZG;
   \   000022   04           INC     A
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   7407         MOV     A,#0x7
   \   000028   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   1013                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \                     ??CrossCallReturnLabel_274:
   \   00002B   70E4         JNZ     ??mpu_lp_accel_mode_1
   1014                      return -1;
   1015                  st.chip_cfg.lp_accel_mode = 0;
   \   00002D   90....       MOV     DPTR,#st + 15
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
   1016                  return 0;
   \   000032   FA           MOV     R2,A
   \   000033   FB           MOV     R3,A
   \   000034   806D         SJMP    ??mpu_lp_accel_mode_2
   1017              }
   1018              /* For LP accel, we automatically configure the hardware to produce latched
   1019               * interrupts. In LP accel mode, the hardware cycles into sleep mode before
   1020               * it gets a chance to deassert the interrupt pin; therefore, we shift this
   1021               * responsibility over to the MCU.
   1022               *
   1023               * Any register read will clear the interrupt.
   1024               */
   1025              mpu_set_int_latched(1);
   \                     ??mpu_lp_accel_mode_3:
   \   000036                ; Setup parameters for call to function mpu_set_int_latched
   \   000036   7901         MOV     R1,#0x1
   \   000038   12....       LCALL   ?Subroutine69 & 0xFFFF
   1026          #if defined MPU6050
   1027              tmp[0] = BIT_LPA_CYCLE;
   \                     ??CrossCallReturnLabel_110:
   \   00003B   7420         MOV     A,#0x20
   \   00003D   F0           MOVX    @DPTR,A
   1028              if (rate == 1) {
   \   00003E   7401         MOV     A,#0x1
   \   000040   6E           XRL     A,R6
   \   000041   700C         JNZ     ??mpu_lp_accel_mode_4
   1029                  tmp[1] = INV_LPA_1_25HZ;
   \   000043   7401         MOV     A,#0x1
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   1030                  mpu_set_lpf(5);
   \   00004A                ; Setup parameters for call to function mpu_set_lpf
   \   00004A   7A05         MOV     R2,#0x5
   \   00004C   FB           MOV     R3,A
   \   00004D   802E         SJMP    ??mpu_lp_accel_mode_5
   1031              } else if (rate <= 5) {
   \                     ??mpu_lp_accel_mode_4:
   \   00004F   EE           MOV     A,R6
   \   000050   C3           CLR     C
   \   000051   9406         SUBB    A,#0x6
   \   000053   500C         JNC     ??mpu_lp_accel_mode_6
   1032                  tmp[1] = INV_LPA_5HZ;
   \   000055   7401         MOV     A,#0x1
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   7401         MOV     A,#0x1
   \   00005C   F0           MOVX    @DPTR,A
   1033                  mpu_set_lpf(5);
   \   00005D                ; Setup parameters for call to function mpu_set_lpf
   \   00005D   7A05         MOV     R2,#0x5
   \   00005F   801A         SJMP    ??mpu_lp_accel_mode_7
   1034              } else if (rate <= 20) {
   \                     ??mpu_lp_accel_mode_6:
   \   000061   EE           MOV     A,R6
   \   000062   C3           CLR     C
   \   000063   9415         SUBB    A,#0x15
   \   000065   7401         MOV     A,#0x1
   \   000067   500A         JNC     ??mpu_lp_accel_mode_8
   1035                  tmp[1] = INV_LPA_20HZ;
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   7402         MOV     A,#0x2
   \   00006E   F0           MOVX    @DPTR,A
   1036                  mpu_set_lpf(10);
   \   00006F                ; Setup parameters for call to function mpu_set_lpf
   \   00006F   7A0A         MOV     R2,#0xa
   \   000071   8008         SJMP    ??mpu_lp_accel_mode_7
   1037              } else {
   1038                  tmp[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_accel_mode_8:
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   7403         MOV     A,#0x3
   \   000078   F0           MOVX    @DPTR,A
   1039                  mpu_set_lpf(20);
   \   000079                ; Setup parameters for call to function mpu_set_lpf
   \   000079   7A14         MOV     R2,#0x14
   \                     ??mpu_lp_accel_mode_7:
   \   00007B   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_5:
   \   00007D   12....       LCALL   ??mpu_set_lpf?relay
   1040              }
   1041              tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
   \   000080   7401         MOV     A,#0x1
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   12....       LCALL   ?Subroutine10 & 0xFFFF
   1042              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \                     ??CrossCallReturnLabel_272:
   \   000088   7087         JNZ     ??mpu_lp_accel_mode_1
   1043                  return -1;
   1044          #elif defined MPU6500
   1045              /* Set wake frequency. */
   1046              if (rate == 1)
   1047                  tmp[0] = INV_LPA_1_25HZ;
   1048              else if (rate == 2)
   1049                  tmp[0] = INV_LPA_2_5HZ;
   1050              else if (rate <= 5)
   1051                  tmp[0] = INV_LPA_5HZ;
   1052              else if (rate <= 10)
   1053                  tmp[0] = INV_LPA_10HZ;
   1054              else if (rate <= 20)
   1055                  tmp[0] = INV_LPA_20HZ;
   1056              else if (rate <= 40)
   1057                  tmp[0] = INV_LPA_40HZ;
   1058              else if (rate <= 80)
   1059                  tmp[0] = INV_LPA_80HZ;
   1060              else if (rate <= 160)
   1061                  tmp[0] = INV_LPA_160HZ;
   1062              else if (rate <= 320)
   1063                  tmp[0] = INV_LPA_320HZ;
   1064              else
   1065                  tmp[0] = INV_LPA_640HZ;
   1066              if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
   1067                  return -1;
   1068              tmp[0] = BIT_LPA_CYCLE;
   1069              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
   1070                  return -1;
   1071          #endif
   1072              st.chip_cfg.sensors = INV_XYZ_ACCEL;
   \   00008A   90....       MOV     DPTR,#st + 6
   \   00008D   7408         MOV     A,#0x8
   \   00008F   F0           MOVX    @DPTR,A
   1073              st.chip_cfg.clk_src = 0;
   \   000090   90....       MOV     DPTR,#st + 8
   \   000093   E4           CLR     A
   \   000094   F0           MOVX    @DPTR,A
   1074              st.chip_cfg.lp_accel_mode = 1;
   \   000095   90....       MOV     DPTR,#st + 15
   \   000098   04           INC     A
   \   000099   F0           MOVX    @DPTR,A
   1075              mpu_configure_fifo(0);
   \   00009A                ; Setup parameters for call to function mpu_configure_fifo
   \   00009A   7900         MOV     R1,#0x0
   \   00009C   12....       LCALL   ??mpu_configure_fifo?relay
   1076          
   1077              return 0;
   \   00009F   7A00         MOV     R2,#0x0
   \   0000A1   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_2:
   \   0000A3                REQUIRE ?Subroutine9
   \   0000A3                ; // Fall through to label ?Subroutine9
   1078          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7402         MOV     A,#0x2
   \   000002   02....       LJMP    ??Subroutine114_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   12....       LCALL   ??mpu_set_int_latched?relay
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Read
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C4           SWAP    A
   \   000002   33           RLC     A
   \   000003   33           RLC     A
   \   000004   54C0         ANL     A,#0xc0
   \   000006   4407         ORL     A,#0x7
   \   000008                REQUIRE ??Subroutine134_0
   \   000008                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003                REQUIRE ??Subroutine135_0
   \   000003                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B02         MOV     R3,#0x2
   \   000006                REQUIRE ??Subroutine136_0
   \   000006                ; // Fall through to label ??Subroutine136_0
   1079          
   1080          /**
   1081           *  @brief      Read raw gyro data directly from the registers.
   1082           *  @param[out] data        Raw data in hardware units.
   1083           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1084           *  @return     0 if successful.
   1085           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1086          int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_gyro_reg:
   1087          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1088              unsigned char tmp[6];
   1089          
   1090              if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   5470         ANL     A,#0x70
   \   000014   7006         JNZ     ??mpu_get_gyro_reg_0
   1091                  return -1;
   \                     ??mpu_get_gyro_reg_1:
   \   000016   7AFF         MOV     R2,#-0x1
   \   000018   7BFF         MOV     R3,#-0x1
   \   00001A   803A         SJMP    ??CrossCallReturnLabel_31
   1092          
   1093              if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
   \                     ??mpu_get_gyro_reg_0:
   \   00001C                ; Setup parameters for call to function I2C_Read
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   7B06         MOV     R3,#0x6
   \   000028   90....       MOV     DPTR,#st
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   240C         ADD     A,#0xc
   \   00002E   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000031   70E3         JNZ     ??mpu_get_gyro_reg_1
   1094                  return -1;
   1095              data[0] = (tmp[0] << 8) | tmp[1];
   \   000033   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine46 & 0xFFFF
   1096              data[1] = (tmp[2] << 8) | tmp[3];
   \                     ??CrossCallReturnLabel_63:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine39 & 0xFFFF
   1097              data[2] = (tmp[4] << 8) | tmp[5];
   \                     ??CrossCallReturnLabel_47:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine28 & 0xFFFF
   1098          //    if (timestamp)
   1099          //        get_ms(timestamp);
   1100              return 0;
   \                     ??CrossCallReturnLabel_31:
   \   000056   80..         SJMP    ?Subroutine8
   1101          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E9           MOV     A,R1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   7402         MOV     A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E9           MOV     A,R1
   \   000008   F0           MOVX    @DPTR,A
   \   000009   7404         MOV     A,#0x4
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   E9           MOV     A,R1
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   7A00         MOV     R2,#0x0
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   7401         MOV     A,#0x1
   \   00000A   22           RET
   1102          
   1103          /**
   1104           *  @brief      Read raw accel data directly from the registers.
   1105           *  @param[out] data        Raw data in hardware units.
   1106           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1107           *  @return     0 if successful.
   1108           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1109          int mpu_get_accel_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_accel_reg:
   1110          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1111              unsigned char tmp[6];
   1112          
   1113              if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   A2E3         MOV     C,0xE0 /* A   */.3
   \   000014   4006         JC      ??mpu_get_accel_reg_0
   1114                  return -1;
   \                     ??mpu_get_accel_reg_1:
   \   000016   7AFF         MOV     R2,#-0x1
   \   000018   7BFF         MOV     R3,#-0x1
   \   00001A   803A         SJMP    ??CrossCallReturnLabel_32
   1115          
   1116              if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
   \                     ??mpu_get_accel_reg_0:
   \   00001C                ; Setup parameters for call to function I2C_Read
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   7B06         MOV     R3,#0x6
   \   000028   90....       MOV     DPTR,#st
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   240D         ADD     A,#0xd
   \   00002E   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000031   70E3         JNZ     ??mpu_get_accel_reg_1
   1117                  return -1;
   1118              data[0] = (tmp[0] << 8) | tmp[1];
   \   000033   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine46 & 0xFFFF
   1119              data[1] = (tmp[2] << 8) | tmp[3];
   \                     ??CrossCallReturnLabel_64:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine39 & 0xFFFF
   1120              data[2] = (tmp[4] << 8) | tmp[5];
   \                     ??CrossCallReturnLabel_48:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine28 & 0xFFFF
   1121              if (timestamp)
   1122                  get_ms(timestamp);
   1123              return 0;
   \                     ??CrossCallReturnLabel_32:
   \   000056                REQUIRE ?Subroutine8
   \   000056                ; // Fall through to label ?Subroutine8
   1124          }
   1125          
   1126          /**
   1127           *  @brief      Read temperature data directly from the registers.
   1128           *  @param[out] data        Data in q16 format.
   1129           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1130           *  @return     0 if successful.
   1131           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine104_0
   \   000002                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1132          int mpu_get_temperature(long *data, unsigned long *timestamp)
   \                     mpu_get_temperature:
   1133          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1134              unsigned char tmp[2];
   1135              short raw;
   1136          
   1137              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_get_temperature_0
   1138                  return -1;
   \                     ??mpu_get_temperature_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_get_temperature_2 & 0xFFFF
   1139          
   1140              if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
   \                     ??mpu_get_temperature_0:
   \   00001B                ; Setup parameters for call to function I2C_Read
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   AC82         MOV     R4,DPL
   \   000023   AD83         MOV     R5,DPH
   \   000025   7B02         MOV     R3,#0x2
   \   000027   90....       MOV     DPTR,#st
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   240E         ADD     A,#0xe
   \   00002D   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000030   70E2         JNZ     ??mpu_get_temperature_1
   1141                  return -1;
   1142              raw = (tmp[0] << 8) | tmp[1];
   1143              if (timestamp)
   1144                  get_ms(timestamp);
   1145          
   1146              data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
   \   000032   90....       MOV     DPTR,#st + 2
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F8           MOV     R0,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   E8           MOV     A,R0
   \   00003B   FA           MOV     R2,A
   \   00003C   E9           MOV     A,R1
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F5..         MOV     ?V0 + 0,A
   \   000047   E9           MOV     A,R1
   \   000048   F5..         MOV     ?V0 + 1,A
   \   00004A   33           RLC     A
   \   00004B   95E0         SUBB    A,0xE0 /* A   */
   \   00004D   F5..         MOV     ?V0 + 2,A
   \   00004F   F5..         MOV     ?V0 + 3,A
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?L_TO_FLT
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000063   78..         MOV     R0,#?V0 + 4
   \   000065   12....       LCALL   ?L_TO_FLT
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   79..         MOV     R1,#?V0 + 4
   \   00006C   12....       LCALL   ?FLT_SUB
   \   00006F   8A82         MOV     DPL,R2
   \   000071   8B83         MOV     DPH,R3
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   00007A   E4           CLR     A
   \   00007B   F5..         MOV     ?V0 + 6,A
   \   00007D   F5..         MOV     ?V0 + 7,A
   \   00007F   78..         MOV     R0,#?V0 + 4
   \   000081   12....       LCALL   ?UL_TO_FLT
   \   000084   78..         MOV     R0,#?V0 + 0
   \   000086   79..         MOV     R1,#?V0 + 4
   \   000088   12....       LCALL   ?FLT_DIV
   \   00008B   90....       MOV     DPTR,#__Constant_420c0000
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   12....       LCALL   ?L_MOV_X
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   79..         MOV     R1,#?V0 + 4
   \   000097   12....       LCALL   ?FLT_ADD
   \   00009A   90....       MOV     DPTR,#__Constant_47800000
   \   00009D   78..         MOV     R0,#?V0 + 4
   \   00009F   12....       LCALL   ?L_MOV_X
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   79..         MOV     R1,#?V0 + 4
   \   0000A6   12....       LCALL   ?FLT_MUL
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?FLT_TO_L
   \   0000AE   8E82         MOV     DPL,R6
   \   0000B0   8F83         MOV     DPH,R7
   \   0000B2   78..         MOV     R0,#?V0 + 0
   \   0000B4   12....       LCALL   ?L_MOV_TO_X
   1147              return 0;
   \   0000B7   7A00         MOV     R2,#0x0
   \   0000B9   7B00         MOV     R3,#0x0
   \                     ??mpu_get_temperature_2:
   \   0000BB   02....       LJMP    ?Subroutine0 & 0xFFFF
   1148          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000003   33           RLC     A
   \   000004   95E0         SUBB    A,0xE0 /* A   */
   \   000006   F5..         MOV     ?V0 + 6,A
   \   000008   F5..         MOV     ?V0 + 7,A
   \   00000A   22           RET
   1149          
   1150          /**
   1151           *  @brief      Push biases to the accel bias registers.
   1152           *  This function expects biases relative to the current sensor output, and
   1153           *  these biases will be added to the factory-supplied values.
   1154           *  @param[in]  accel_bias  New biases.
   1155           *  @return     0 if successful.
   1156           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1157          int mpu_set_accel_bias(const long *accel_bias)
   \                     mpu_set_accel_bias:
   1158          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1159              unsigned char data[6];
   1160              short accel_hw[3];
   1161              short got_accel[3];
   1162              short fg[3];
   1163          
   1164              if (!accel_bias)
   \   00000E   EE           MOV     A,R6
   \   00000F   4F           ORL     A,R7
   \   000010   700E         JNZ     ??mpu_set_accel_bias_0
   1165                  return -1;
   \                     ??mpu_set_accel_bias_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \                     ??mpu_set_accel_bias_2:
   \   000016   7418         MOV     A,#0x18
   \   000018   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001B   7F0C         MOV     R7,#0xc
   \   00001D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1166              if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
   \                     ??mpu_set_accel_bias_0:
   \   000020   EE           MOV     A,R6
   \   000021   2408         ADD     A,#0x8
   \   000023   F5..         MOV     ?V0 + 2,A
   \   000025   EF           MOV     A,R7
   \   000026   3400         ADDC    A,#0x0
   \   000028   F5..         MOV     ?V0 + 3,A
   \   00002A   EE           MOV     A,R6
   \   00002B   2404         ADD     A,#0x4
   \   00002D   F5..         MOV     ?V0 + 0,A
   \   00002F   EF           MOV     A,R7
   \   000030   3400         ADDC    A,#0x0
   \   000032   F5..         MOV     ?V0 + 1,A
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   78..         MOV     R0,#?V0 + 4
   \   00003A   12....       LCALL   ?L_MOV_X
   \   00003D   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000040   7026         JNZ     ??mpu_set_accel_bias_3
   \   000042   85..82       MOV     DPL,?V0 + 0
   \   000045   85..83       MOV     DPH,?V0 + 1
   \   000048   78..         MOV     R0,#?V0 + 4
   \   00004A   12....       LCALL   ?L_MOV_X
   \   00004D   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000050   7016         JNZ     ??mpu_set_accel_bias_3
   \   000052   85..82       MOV     DPL,?V0 + 2
   \   000055   85..83       MOV     DPH,?V0 + 3
   \   000058   78..         MOV     R0,#?V0 + 4
   \   00005A   12....       LCALL   ?L_MOV_X
   \   00005D   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000060   7006         JNZ     ??mpu_set_accel_bias_3
   1167                  return 0;
   \                     ??mpu_set_accel_bias_4:
   \   000062   7A00         MOV     R2,#0x0
   \   000064   7B00         MOV     R3,#0x0
   \   000066   80AE         SJMP    ??mpu_set_accel_bias_2
   1168          
   1169              if (i2c_read(st.hw->addr, 3, 3, data))
   \                     ??mpu_set_accel_bias_3:
   \   000068                ; Setup parameters for call to function I2C_Read
   \   000068   85..82       MOV     DPL,?XSP + 0
   \   00006B   85..83       MOV     DPH,?XSP + 1
   \   00006E   AC82         MOV     R4,DPL
   \   000070   AD83         MOV     R5,DPH
   \   000072   7B03         MOV     R3,#0x3
   \   000074   7A03         MOV     R2,#0x3
   \   000076   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000079   8B..         MOV     ?V0 + 5,R3
   \   00007B   EA           MOV     A,R2
   \   00007C   45..         ORL     A,?V0 + 5
   \   00007E   7092         JNZ     ??mpu_set_accel_bias_1
   1170                  return -1;
   1171              fg[0] = ((data[0] >> 4) + 8) & 0xf;
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000089   F8           MOV     R0,A
   \   00008A   740C         MOV     A,#0xc
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   E8           MOV     A,R0
   \   000090   F0           MOVX    @DPTR,A
   \   000091   A3           INC     DPTR
   \   000092   E4           CLR     A
   \   000093   F0           MOVX    @DPTR,A
   1172              fg[1] = ((data[1] >> 4) + 8) & 0xf;
   \   000094   04           INC     A
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00009B   FA           MOV     R2,A
   \   00009C   740E         MOV     A,#0xe
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   EA           MOV     A,R2
   \   0000A2   F0           MOVX    @DPTR,A
   \   0000A3   A3           INC     DPTR
   \   0000A4   E4           CLR     A
   \   0000A5   F0           MOVX    @DPTR,A
   1173              fg[2] = ((data[2] >> 4) + 8) & 0xf;
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0000AE   FC           MOV     R4,A
   \   0000AF   7410         MOV     A,#0x10
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   EC           MOV     A,R4
   \   0000B5   F0           MOVX    @DPTR,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E4           CLR     A
   \   0000B8   F0           MOVX    @DPTR,A
   1174          
   1175              accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
   \   0000B9   8E82         MOV     DPL,R6
   \   0000BB   8F83         MOV     DPH,R7
   \   0000BD   78..         MOV     R0,#?V0 + 8
   \   0000BF   12....       LCALL   ?L_MOV_X
   \   0000C2   7401         MOV     A,#0x1
   \   0000C4   78..         MOV     R0,#?V0 + 8
   \   0000C6   12....       LCALL   ?L_SHL
   \   0000C9   740C         MOV     A,#0xc
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   2440         ADD     A,#0x40
   \   0000D1   F5..         MOV     ?V0 + 4,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   3400         ADDC    A,#0x0
   \   0000D7   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   0000DA   78..         MOV     R0,#?V0 + 8
   \   0000DC   79..         MOV     R1,#?V0 + 4
   \   0000DE   12....       LCALL   ?L_DIV_MOD
   \   0000E1   7406         MOV     A,#0x6
   \   0000E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E6   E5..         MOV     A,?V0 + 8
   \   0000E8   F0           MOVX    @DPTR,A
   \   0000E9   A3           INC     DPTR
   \   0000EA   E5..         MOV     A,?V0 + 9
   \   0000EC   F0           MOVX    @DPTR,A
   1176              accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
   \   0000ED   85..82       MOV     DPL,?V0 + 0
   \   0000F0   85..83       MOV     DPH,?V0 + 1
   \   0000F3   78..         MOV     R0,#?V0 + 4
   \   0000F5   12....       LCALL   ?L_MOV_X
   \   0000F8   7401         MOV     A,#0x1
   \   0000FA   78..         MOV     R0,#?V0 + 4
   \   0000FC   12....       LCALL   ?L_SHL
   \   0000FF   EA           MOV     A,R2
   \   000100   2440         ADD     A,#0x40
   \   000102   F5..         MOV     ?V0 + 8,A
   \   000104   E4           CLR     A
   \   000105   F5..         MOV     ?V0 + 9,A
   \   000107   F5..         MOV     ?V0 + 10,A
   \   000109   F5..         MOV     ?V0 + 11,A
   \   00010B   78..         MOV     R0,#?V0 + 4
   \   00010D   79..         MOV     R1,#?V0 + 8
   \   00010F   12....       LCALL   ?L_DIV_MOD
   \   000112   7408         MOV     A,#0x8
   \   000114   12....       LCALL   ?XSTACK_DISP0_8
   \   000117   E5..         MOV     A,?V0 + 4
   \   000119   F0           MOVX    @DPTR,A
   \   00011A   A3           INC     DPTR
   \   00011B   E5..         MOV     A,?V0 + 5
   \   00011D   F0           MOVX    @DPTR,A
   1177              accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
   \   00011E   85..82       MOV     DPL,?V0 + 2
   \   000121   85..83       MOV     DPH,?V0 + 3
   \   000124   78..         MOV     R0,#?V0 + 0
   \   000126   12....       LCALL   ?L_MOV_X
   \   000129   7401         MOV     A,#0x1
   \   00012B   78..         MOV     R0,#?V0 + 0
   \   00012D   12....       LCALL   ?L_SHL
   \   000130   EC           MOV     A,R4
   \   000131   2440         ADD     A,#0x40
   \   000133   F5..         MOV     ?V0 + 4,A
   \   000135   E4           CLR     A
   \   000136   F5..         MOV     ?V0 + 5,A
   \   000138   F5..         MOV     ?V0 + 6,A
   \   00013A   F5..         MOV     ?V0 + 7,A
   \   00013C   78..         MOV     R0,#?V0 + 0
   \   00013E   79..         MOV     R1,#?V0 + 4
   \   000140   12....       LCALL   ?L_DIV_MOD
   \   000143   740A         MOV     A,#0xa
   \   000145   12....       LCALL   ?XSTACK_DISP0_8
   \   000148   E5..         MOV     A,?V0 + 0
   \   00014A   F0           MOVX    @DPTR,A
   \   00014B   A3           INC     DPTR
   \   00014C   E5..         MOV     A,?V0 + 1
   \   00014E   12....       LCALL   ?Subroutine61 & 0xFFFF
   1178          
   1179              if (i2c_read(st.hw->addr, 0x06, 6, data))
   \                     ??CrossCallReturnLabel_96:
   \   000151   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000154   6003         JZ      $+5
   \   000156   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   1180                  return -1;
   1181          
   1182              got_accel[0] = ((short)data[0] << 8) | data[1];
   \   000159   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00015C   12....       LCALL   ?XSTACK_DISP0_8
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   F8           MOV     R0,A
   \   000161   7412         MOV     A,#0x12
   \   000163   12....       LCALL   ?XSTACK_DISP0_8
   \   000166   12....       LCALL   ?Subroutine65 & 0xFFFF
   1183              got_accel[1] = ((short)data[2] << 8) | data[3];
   \                     ??CrossCallReturnLabel_159:
   \   000169   7402         MOV     A,#0x2
   \   00016B   12....       LCALL   ?XSTACK_DISP0_8
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   F9           MOV     R1,A
   \   000170   7403         MOV     A,#0x3
   \   000172   12....       LCALL   ?XSTACK_DISP0_8
   \   000175   E0           MOVX    A,@DPTR
   \   000176   FA           MOV     R2,A
   \   000177   E9           MOV     A,R1
   \   000178   FB           MOV     R3,A
   \   000179   7414         MOV     A,#0x14
   \   00017B   12....       LCALL   ?XSTACK_DISP0_8
   \   00017E   EA           MOV     A,R2
   \   00017F   F0           MOVX    @DPTR,A
   \   000180   A3           INC     DPTR
   \   000181   EB           MOV     A,R3
   \   000182   F0           MOVX    @DPTR,A
   1184              got_accel[2] = ((short)data[4] << 8) | data[5];
   \   000183   7404         MOV     A,#0x4
   \   000185   12....       LCALL   ?XSTACK_DISP0_8
   \   000188   E0           MOVX    A,@DPTR
   \   000189   F9           MOV     R1,A
   \   00018A   7405         MOV     A,#0x5
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   E0           MOVX    A,@DPTR
   \   000190   F8           MOV     R0,A
   \   000191   7416         MOV     A,#0x16
   \   000193   12....       LCALL   ?XSTACK_DISP0_8
   \   000196   12....       LCALL   ?Subroutine65 & 0xFFFF
   1185          
   1186              accel_hw[0] += got_accel[0];
   \                     ??CrossCallReturnLabel_160:
   \   000199   7412         MOV     A,#0x12
   \   00019B   12....       LCALL   ?XSTACK_DISP0_8
   \   00019E   E0           MOVX    A,@DPTR
   \   00019F   FC           MOV     R4,A
   \   0001A0   A3           INC     DPTR
   \   0001A1   E0           MOVX    A,@DPTR
   \   0001A2   FD           MOV     R5,A
   \   0001A3   7406         MOV     A,#0x6
   \   0001A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A8   E0           MOVX    A,@DPTR
   \   0001A9   2C           ADD     A,R4
   \   0001AA   F0           MOVX    @DPTR,A
   \   0001AB   A3           INC     DPTR
   \   0001AC   E0           MOVX    A,@DPTR
   \   0001AD   3D           ADDC    A,R5
   \   0001AE   F0           MOVX    @DPTR,A
   1187              accel_hw[1] += got_accel[1];
   \   0001AF   7408         MOV     A,#0x8
   \   0001B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   2A           ADD     A,R2
   \   0001B6   F0           MOVX    @DPTR,A
   \   0001B7   A3           INC     DPTR
   \   0001B8   E0           MOVX    A,@DPTR
   \   0001B9   3B           ADDC    A,R3
   \   0001BA   F0           MOVX    @DPTR,A
   1188              accel_hw[2] += got_accel[2];
   \   0001BB   740A         MOV     A,#0xa
   \   0001BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C0   E0           MOVX    A,@DPTR
   \   0001C1   28           ADD     A,R0
   \   0001C2   F0           MOVX    @DPTR,A
   \   0001C3   A3           INC     DPTR
   \   0001C4   E0           MOVX    A,@DPTR
   \   0001C5   39           ADDC    A,R1
   \   0001C6   F0           MOVX    @DPTR,A
   1189          
   1190              data[0] = (accel_hw[0] >> 8) & 0xff;
   \   0001C7   7406         MOV     A,#0x6
   \   0001C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CC   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0001CF   7408         MOV     A,#0x8
   \   0001D1   78..         MOV     R0,#?V0 + 0
   \   0001D3   12....       LCALL   ?SS_SHR
   \   0001D6   85..82       MOV     DPL,?XSP + 0
   \   0001D9   85..83       MOV     DPH,?XSP + 1
   \   0001DC   E5..         MOV     A,?V0 + 0
   \   0001DE   F0           MOVX    @DPTR,A
   1191              data[1] = (accel_hw[0]) & 0xff;
   \   0001DF   7406         MOV     A,#0x6
   \   0001E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E4   E0           MOVX    A,@DPTR
   \   0001E5   C0E0         PUSH    A
   \   0001E7   7401         MOV     A,#0x1
   \   0001E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EC   D0E0         POP     A
   \   0001EE   F0           MOVX    @DPTR,A
   1192              data[2] = (accel_hw[1] >> 8) & 0xff;
   \   0001EF   7408         MOV     A,#0x8
   \   0001F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F4   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0001F7   12....       LCALL   ?SS_SHR
   \   0001FA   7402         MOV     A,#0x2
   \   0001FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FF   E5..         MOV     A,?V0 + 0
   \   000201   F0           MOVX    @DPTR,A
   1193              data[3] = (accel_hw[1]) & 0xff;
   \   000202   7403         MOV     A,#0x3
   \   000204   12....       LCALL   ?XSTACK_DISP0_8
   \   000207   EA           MOV     A,R2
   \   000208   F0           MOVX    @DPTR,A
   1194              data[4] = (accel_hw[2] >> 8) & 0xff;
   \   000209   740A         MOV     A,#0xa
   \   00020B   12....       LCALL   ?XSTACK_DISP0_8
   \   00020E   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000211   12....       LCALL   ?SS_SHR
   \   000214   7404         MOV     A,#0x4
   \   000216   12....       LCALL   ?XSTACK_DISP0_8
   \   000219   E5..         MOV     A,?V0 + 0
   \   00021B   F0           MOVX    @DPTR,A
   1195              data[5] = (accel_hw[2]) & 0xff;
   \   00021C   7405         MOV     A,#0x5
   \   00021E   12....       LCALL   ?XSTACK_DISP0_8
   \   000221   EA           MOV     A,R2
   \   000222   12....       LCALL   ?Subroutine61 & 0xFFFF
   1196          
   1197              if (i2c_write(st.hw->addr, 0x06, 6, data))
   \                     ??CrossCallReturnLabel_97:
   \   000225   90....       MOV     DPTR,#st + 2
   \   000228   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   00022B   E0           MOVX    A,@DPTR
   \   00022C   F9           MOV     R1,A
   \   00022D   12....       LCALL   ??I2C_Write?relay
   \   000230   8B..         MOV     ?V0 + 1,R3
   \   000232   EA           MOV     A,R2
   \   000233   45..         ORL     A,?V0 + 1
   \   000235   6003         JZ      $+5
   \   000237   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   \   00023A   02....       LJMP    ??mpu_set_accel_bias_4 & 0xFFFF
   1198                  return -1;
   1199              return 0;
   1200          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   E5..         MOV     A,?V0 + 4
   \   000002   45..         ORL     A,?V0 + 5
   \   000004   45..         ORL     A,?V0 + 6
   \   000006   45..         ORL     A,?V0 + 7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine106_0
   \   000001                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000003   7B06         MOV     R3,#0x6
   \   000005   7A06         MOV     R2,#0x6
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   7408         MOV     A,#0x8
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C4           SWAP    A
   \   000002   540F         ANL     A,#0xf
   \   000004   2408         ADD     A,#0x8
   \   000006   540F         ANL     A,#0xf
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   F5..         MOV     ?V0 + 5,A
   \   000002   33           RLC     A
   \   000003   95E0         SUBB    A,0xE0 /* A   */
   \   000005   F5..         MOV     ?V0 + 6,A
   \   000007   F5..         MOV     ?V0 + 7,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   AC82         MOV     R4,DPL
   \   000005   AD83         MOV     R5,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
   1201          
   1202          /**
   1203           *  @brief  Reset FIFO read/write pointers.
   1204           *  @return 0 if successful.
   1205           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1206          int mpu_reset_fifo(void)
   \                     mpu_reset_fifo:
   1207          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1208              unsigned char data;
   1209          
   1210              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7007         JNZ     ??mpu_reset_fifo_0
   1211                  return -1;
   \                     ??mpu_reset_fifo_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   02....       LJMP    ??mpu_reset_fifo_2 & 0xFFFF
   1212          
   1213              data = 0;
   \                     ??mpu_reset_fifo_0:
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   12....       LCALL   ?Subroutine57 & 0xFFFF
   1214              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_252:
   \   000020   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000023   70EB         JNZ     ??mpu_reset_fifo_1
   1215                  return -1;
   1216              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   \   000025                ; Setup parameters for call to function I2C_Write
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   00002E   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000031   70DD         JNZ     ??mpu_reset_fifo_1
   1217                  return -1;
   1218              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   000033                ; Setup parameters for call to function I2C_Write
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   00003C   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   00003F   70CF         JNZ     ??mpu_reset_fifo_1
   1219                  return -1;
   1220          
   1221              if (st.chip_cfg.dmp_on) {
   \   000041   90....       MOV     DPTR,#st + 29
   \   000044   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000047   6054         JZ      ??mpu_reset_fifo_3
   1222                  data = BIT_FIFO_RST | BIT_DMP_RST;
   \   000049   12....       LCALL   ?Subroutine34 & 0xFFFF
   1223                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_165:
   \   00004C   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   00004F   70BF         JNZ     ??mpu_reset_fifo_1
   1224                      return -1;
   1225                  delay_ms(50);
   \   000051                ; Setup parameters for call to function delay_ms
   \   000051   7A32         MOV     R2,#0x32
   \   000053   12....       LCALL   ?Subroutine66 & 0xFFFF
   1226                  data = BIT_DMP_EN | BIT_FIFO_EN;
   \                     ??CrossCallReturnLabel_104:
   \   000056   74C0         MOV     A,#-0x40
   \   000058   F0           MOVX    @DPTR,A
   1227                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   000059   90....       MOV     DPTR,#st + 6
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005F   5009         JNC     ??mpu_reset_fifo_4
   1228                      data |= BIT_AUX_IF_EN;
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   74E0         MOV     A,#-0x20
   \   000069   F0           MOVX    @DPTR,A
   1229                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??mpu_reset_fifo_4:
   \   00006A                ; Setup parameters for call to function I2C_Write
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000073   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000076   7098         JNZ     ??mpu_reset_fifo_1
   1230                      return -1;
   1231                  if (st.chip_cfg.int_enable)
   \   000078   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   00007B   6004         JZ      ??mpu_reset_fifo_5
   1232                      data = BIT_DMP_INT_EN;
   \   00007D   7402         MOV     A,#0x2
   \   00007F   8001         SJMP    ??mpu_reset_fifo_6
   1233                  else
   1234                      data = 0;
   \                     ??mpu_reset_fifo_5:
   \   000081   E4           CLR     A
   \                     ??mpu_reset_fifo_6:
   \   000082   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   1235                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_256:
   \   000085   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000088   7086         JNZ     ??mpu_reset_fifo_1
   1236                      return -1;
   1237                  data = 0;
   \   00008A   85..82       MOV     DPL,?XSP + 0
   \   00008D   85..83       MOV     DPH,?XSP + 1
   \   000090   12....       LCALL   ?Subroutine33 & 0xFFFF
   1238                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   1239                      return -1;
   1240              } else {
   \                     ??CrossCallReturnLabel_204:
   \   000093   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000096   6003         JZ      $+5
   \   000098   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   \   00009B   8063         SJMP    ??mpu_reset_fifo_7
   1241                  data = BIT_FIFO_RST;
   \                     ??mpu_reset_fifo_3:
   \   00009D   7404         MOV     A,#0x4
   \   00009F   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   1242                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_167:
   \   0000A2   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   0000A5   6003         JZ      $+5
   \   0000A7   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1243                      return -1;
   1244                  if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   \   0000AA   90....       MOV     DPTR,#st + 13
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   7008         JNZ     ??mpu_reset_fifo_8
   \   0000B0   90....       MOV     DPTR,#st + 6
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B6   400A         JC      ??mpu_reset_fifo_9
   1245                      data = BIT_FIFO_EN;
   \                     ??mpu_reset_fifo_8:
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   7440         MOV     A,#0x40
   \   0000C0   8008         SJMP    ??mpu_reset_fifo_10
   1246                  else
   1247                      data = BIT_FIFO_EN | BIT_AUX_IF_EN;
   \                     ??mpu_reset_fifo_9:
   \   0000C2   85..82       MOV     DPL,?XSP + 0
   \   0000C5   85..83       MOV     DPH,?XSP + 1
   \   0000C8   7460         MOV     A,#0x60
   \                     ??mpu_reset_fifo_10:
   \   0000CA   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   1248                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_168:
   \   0000CD   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   0000D0   6003         JZ      $+5
   \   0000D2   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1249                      return -1;
   1250                  delay_ms(50);
   \   0000D5                ; Setup parameters for call to function delay_ms
   \   0000D5   7A32         MOV     R2,#0x32
   \   0000D7   7B00         MOV     R3,#0x0
   \   0000D9   12....       LCALL   ??delay_ms?relay
   1251                  if (st.chip_cfg.int_enable)
   \   0000DC   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   0000DF   6004         JZ      ??mpu_reset_fifo_11
   1252                      data = BIT_DATA_RDY_EN;
   \   0000E1   7401         MOV     A,#0x1
   \   0000E3   8001         SJMP    ??mpu_reset_fifo_12
   1253                  else
   1254                      data = 0;
   \                     ??mpu_reset_fifo_11:
   \   0000E5   E4           CLR     A
   \                     ??mpu_reset_fifo_12:
   \   0000E6   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   1255                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_257:
   \   0000E9   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   0000EC   6003         JZ      $+5
   \   0000EE   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1256                      return -1;
   1257                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
   \   0000F1                ; Setup parameters for call to function I2C_Write
   \   0000F1   7C..         MOV     R4,#(st + 11) & 0xff
   \   0000F3   7D..         MOV     R5,#((st + 11) >> 8) & 0xff
   \   0000F5   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   1258                      return -1;
   1259              }
   \                     ??CrossCallReturnLabel_207:
   \   0000F8   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   0000FB   6003         JZ      $+5
   \   0000FD   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1260              return 0;
   \                     ??mpu_reset_fifo_7:
   \   000100   7A00         MOV     R2,#0x0
   \   000102   7B00         MOV     R3,#0x0
   \                     ??mpu_reset_fifo_2:
   \   000104   02....       LJMP    ?Subroutine3 & 0xFFFF
   1261          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   740C         MOV     A,#0xc
   \   000002                REQUIRE ??Subroutine107_0
   \   000002                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                REQUIRE ??Subroutine108_0
   \   000001                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006                REQUIRE ??Subroutine109_0
   \   000006                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   90....       MOV     DPTR,#st + 12
   \   000003                REQUIRE ??Subroutine116_0
   \   000003                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   E4           CLR     A
   \   000001                REQUIRE ??Subroutine120_0
   \   000001                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                REQUIRE ??Subroutine121_0
   \   000001                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004                REQUIRE ??Subroutine122_0
   \   000004                ; // Fall through to label ??Subroutine122_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   7B01         MOV     R3,#0x1
   \   000002   90....       MOV     DPTR,#st
   \   000005   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   E4           CLR     A
   \   000001                REQUIRE ??Subroutine132_0
   \   000001                ; // Fall through to label ??Subroutine132_0
   1262          
   1263          /**
   1264           *  @brief      Get the gyro full-scale range.
   1265           *  @param[out] fsr Current full-scale range.
   1266           *  @return     0 if successful.
   1267           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1268          int mpu_get_gyro_fsr(unsigned short *fsr)
   \                     mpu_get_gyro_fsr:
   1269          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1270              switch (st.chip_cfg.gyro_fsr) {
   \   000004   90....       MOV     DPTR,#st + 4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_gyro_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6013         JZ      ??mpu_get_gyro_fsr_1
   \   00000D   14           DEC     A
   \   00000E   601C         JZ      ??mpu_get_gyro_fsr_2
   \   000010   14           DEC     A
   \   000011   6025         JZ      ??mpu_get_gyro_fsr_3
   \   000013   802F         SJMP    ??mpu_get_gyro_fsr_4
   1271              case INV_FSR_250DPS:
   1272                  fsr[0] = 250;
   \                     ??mpu_get_gyro_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   74FA         MOV     A,#-0x6
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   E4           CLR     A
   \   00001E   802B         SJMP    ??mpu_get_gyro_fsr_5
   1273                  break;
   1274              case INV_FSR_500DPS:
   1275                  fsr[0] = 500;
   \                     ??mpu_get_gyro_fsr_1:
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   74F4         MOV     A,#-0xc
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   7401         MOV     A,#0x1
   \   00002A   801F         SJMP    ??mpu_get_gyro_fsr_5
   1276                  break;
   1277              case INV_FSR_1000DPS:
   1278                  fsr[0] = 1000;
   \                     ??mpu_get_gyro_fsr_2:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   74E8         MOV     A,#-0x18
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7403         MOV     A,#0x3
   \   000036   8013         SJMP    ??mpu_get_gyro_fsr_5
   1279                  break;
   1280              case INV_FSR_2000DPS:
   1281                  fsr[0] = 2000;
   \                     ??mpu_get_gyro_fsr_3:
   \   000038   8A82         MOV     DPL,R2
   \   00003A   8B83         MOV     DPH,R3
   \   00003C   74D0         MOV     A,#-0x30
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   7407         MOV     A,#0x7
   \   000042   8007         SJMP    ??mpu_get_gyro_fsr_5
   1282                  break;
   1283              default:
   1284                  fsr[0] = 0;
   \                     ??mpu_get_gyro_fsr_4:
   \   000044   8A82         MOV     DPL,R2
   \   000046   8B83         MOV     DPH,R3
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   1285                  break;
   1286              }
   \                     ??mpu_get_gyro_fsr_5:
   \   00004B   02....       LJMP    ??Subroutine111_0 & 0xFFFF
   1287              return 0;
   1288          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7A00         MOV     R2,#0x0
   \   000003                REQUIRE ??Subroutine112_0
   \   000003                ; // Fall through to label ??Subroutine112_0
   1289          
   1290          /**
   1291           *  @brief      Set the gyro full-scale range.
   1292           *  @param[in]  fsr Desired full-scale range.
   1293           *  @return     0 if successful.
   1294           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1295          int mpu_set_gyro_fsr(unsigned short fsr)
   \                     mpu_set_gyro_fsr:
   1296          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1297              unsigned char data;
   1298          
   1299              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7006         JNZ     ??mpu_set_gyro_fsr_0
   1300                  return -1;
   \                     ??mpu_set_gyro_fsr_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   8060         SJMP    ??mpu_set_gyro_fsr_2
   1301          
   1302              switch (fsr) {
   \                     ??mpu_set_gyro_fsr_0:
   \   000016   8A..         MOV     ?V0 + 0,R2
   \   000018   8B..         MOV     ?V0 + 1,R3
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for mpu_set_gyro_fsr>_0`:
   \   00001F   0000         DW        0
   \   000021   0400         DW        4
   \   000023   FA00         DW        250
   \   000025   ....         DW        ??mpu_set_gyro_fsr_3
   \   000027   F401         DW        500
   \   000029   ....         DW        ??mpu_set_gyro_fsr_4
   \   00002B   E803         DW        1000
   \   00002D   ....         DW        ??mpu_set_gyro_fsr_5
   \   00002F   D007         DW        2000
   \   000031   ....         DW        ??mpu_set_gyro_fsr_6
   \   000033   ....         DW        ??mpu_set_gyro_fsr_1
   1303              case 250:
   1304                  data = INV_FSR_250DPS << 3;
   \                     ??mpu_set_gyro_fsr_3:
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   E4           CLR     A
   \   00003C   801C         SJMP    ??mpu_set_gyro_fsr_7
   1305                  break;
   1306              case 500:
   1307                  data = INV_FSR_500DPS << 3;
   \                     ??mpu_set_gyro_fsr_4:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   7408         MOV     A,#0x8
   \   000046   8012         SJMP    ??mpu_set_gyro_fsr_7
   1308                  break;
   1309              case 1000:
   1310                  data = INV_FSR_1000DPS << 3;
   \                     ??mpu_set_gyro_fsr_5:
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   7410         MOV     A,#0x10
   \   000050   8008         SJMP    ??mpu_set_gyro_fsr_7
   1311                  break;
   1312              case 2000:
   1313                  data = INV_FSR_2000DPS << 3;
   \                     ??mpu_set_gyro_fsr_6:
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   7418         MOV     A,#0x18
   \                     ??mpu_set_gyro_fsr_7:
   \   00005A   F0           MOVX    @DPTR,A
   1314                  break;
   1315              default:
   1316                  return -1;
   1317              }
   1318          
   1319              if (st.chip_cfg.gyro_fsr == (data >> 3))
   \   00005B   90....       MOV     DPTR,#st + 4
   \   00005E   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000061   600F         JZ      ??mpu_set_gyro_fsr_8
   1320                  return 0;
   1321              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
   \   000063                ; Setup parameters for call to function I2C_Write
   \   000063   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000066   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000069   70A5         JNZ     ??mpu_set_gyro_fsr_1
   1322                  return -1;
   1323              st.chip_cfg.gyro_fsr = data >> 3;
   \   00006B   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00006E   90....       MOV     DPTR,#st + 4
   \   000071   F0           MOVX    @DPTR,A
   1324              return 0;
   \                     ??mpu_set_gyro_fsr_8:
   \   000072   7A00         MOV     R2,#0x0
   \   000074   7B00         MOV     R3,#0x0
   \                     ??mpu_set_gyro_fsr_2:
   \   000076   02....       LJMP    ?Subroutine3 & 0xFFFF
   1325          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine110_0
   \   000006                ; // Fall through to label ??Subroutine110_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000003   A2E7         MOV     C,0xE0 /* A   */.7
   \   000005   13           RRC     A
   \   000006   A2E7         MOV     C,0xE0 /* A   */.7
   \   000008   13           RRC     A
   \   000009   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000B   13           RRC     A
   \   00000C   68           XRL     A,R0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1326          
   1327          /**
   1328           *  @brief      Get the accel full-scale range.
   1329           *  @param[out] fsr Current full-scale range.
   1330           *  @return     0 if successful.
   1331           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1332          int mpu_get_accel_fsr(unsigned char *fsr)
   \                     mpu_get_accel_fsr:
   1333          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1334              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6024         JZ      ??mpu_get_accel_fsr_1
   \   00000D   14           DEC     A
   \   00000E   6029         JZ      ??mpu_get_accel_fsr_2
   \   000010   14           DEC     A
   \   000011   602E         JZ      ??mpu_get_accel_fsr_3
   \   000013   8034         SJMP    ??mpu_get_accel_fsr_4
   1335              case INV_FSR_2G:
   1336                  fsr[0] = 2;
   \                     ??mpu_get_accel_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   7402         MOV     A,#0x2
   \                     ??mpu_get_accel_fsr_5:
   \   00001B   F0           MOVX    @DPTR,A
   1337                  break;
   1338              case INV_FSR_4G:
   1339                  fsr[0] = 4;
   1340                  break;
   1341              case INV_FSR_8G:
   1342                  fsr[0] = 8;
   1343                  break;
   1344              case INV_FSR_16G:
   1345                  fsr[0] = 16;
   1346                  break;
   1347              default:
   1348                  return -1;
   1349              }
   1350              if (st.chip_cfg.accel_half)
   \   00001C   90....       MOV     DPTR,#st + 14
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6008         JZ      ??mpu_get_accel_fsr_6
   1351                  fsr[0] <<= 1;
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   E0           MOVX    A,@DPTR
   \   000027   C3           CLR     C
   \   000028   33           RLC     A
   \   000029   F0           MOVX    @DPTR,A
   1352              return 0;
   \                     ??mpu_get_accel_fsr_6:
   \   00002A   7A00         MOV     R2,#0x0
   \   00002C   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_fsr_7:
   \   00002E   02....       LJMP    ??Subroutine113_0 & 0xFFFF
   \                     ??mpu_get_accel_fsr_1:
   \   000031   8A82         MOV     DPL,R2
   \   000033   8B83         MOV     DPH,R3
   \   000035   7404         MOV     A,#0x4
   \   000037   80E2         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_2:
   \   000039   8A82         MOV     DPL,R2
   \   00003B   8B83         MOV     DPH,R3
   \   00003D   7408         MOV     A,#0x8
   \   00003F   80DA         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_3:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   7410         MOV     A,#0x10
   \   000047   80D2         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_4:
   \   000049   7AFF         MOV     R2,#-0x1
   \   00004B   7BFF         MOV     R3,#-0x1
   \   00004D   80DF         SJMP    ??mpu_get_accel_fsr_7
   1353          }
   1354          
   1355          /**
   1356           *  @brief      Set the accel full-scale range.
   1357           *  @param[in]  fsr Desired full-scale range.
   1358           *  @return     0 if successful.
   1359           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1360          int mpu_set_accel_fsr(unsigned char fsr)
   \                     mpu_set_accel_fsr:
   1361          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1362              unsigned char data;
   1363          
   1364              if (!(st.chip_cfg.sensors))
   \   00000C   90....       MOV     DPTR,#st + 6
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   7006         JNZ     ??mpu_set_accel_fsr_0
   1365                  return -1;
   \                     ??mpu_set_accel_fsr_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \   000016   8054         SJMP    ??mpu_set_accel_fsr_2
   1366          
   1367              switch (fsr) {
   \                     ??mpu_set_accel_fsr_0:
   \   000018   EE           MOV     A,R6
   \   000019   24FE         ADD     A,#-0x2
   \   00001B   600E         JZ      ??mpu_set_accel_fsr_3
   \   00001D   24FE         ADD     A,#-0x2
   \   00001F   6013         JZ      ??mpu_set_accel_fsr_4
   \   000021   24FC         ADD     A,#-0x4
   \   000023   6019         JZ      ??mpu_set_accel_fsr_5
   \   000025   24F8         ADD     A,#-0x8
   \   000027   601F         JZ      ??mpu_set_accel_fsr_6
   \   000029   80E7         SJMP    ??mpu_set_accel_fsr_1
   1368              case 2:
   1369                  data = INV_FSR_2G << 3;
   \                     ??mpu_set_accel_fsr_3:
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   E4           CLR     A
   \   000032   801C         SJMP    ??mpu_set_accel_fsr_7
   1370                  break;
   1371              case 4:
   1372                  data = INV_FSR_4G << 3;
   \                     ??mpu_set_accel_fsr_4:
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   7408         MOV     A,#0x8
   \   00003C   8012         SJMP    ??mpu_set_accel_fsr_7
   1373                  break;
   1374              case 8:
   1375                  data = INV_FSR_8G << 3;
   \                     ??mpu_set_accel_fsr_5:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   7410         MOV     A,#0x10
   \   000046   8008         SJMP    ??mpu_set_accel_fsr_7
   1376                  break;
   1377              case 16:
   1378                  data = INV_FSR_16G << 3;
   \                     ??mpu_set_accel_fsr_6:
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   7418         MOV     A,#0x18
   \                     ??mpu_set_accel_fsr_7:
   \   000050   F0           MOVX    @DPTR,A
   1379                  break;
   1380              default:
   1381                  return -1;
   1382              }
   1383          
   1384              if (st.chip_cfg.accel_fsr == (data >> 3))
   \   000051   90....       MOV     DPTR,#st + 5
   \   000054   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000057   600F         JZ      ??mpu_set_accel_fsr_8
   1385                  return 0;
   1386              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
   \   000059                ; Setup parameters for call to function I2C_Write
   \   000059   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   00005C   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   00005F   70B1         JNZ     ??mpu_set_accel_fsr_1
   1387                  return -1;
   1388              st.chip_cfg.accel_fsr = data >> 3;
   \   000061   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000064   90....       MOV     DPTR,#st + 5
   \   000067   F0           MOVX    @DPTR,A
   1389              return 0;
   \                     ??mpu_set_accel_fsr_8:
   \   000068   7A00         MOV     R2,#0x0
   \   00006A   7B00         MOV     R3,#0x0
   \                     ??mpu_set_accel_fsr_2:
   \   00006C   02....       LJMP    ?Subroutine3 & 0xFFFF
   1390          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   90....       MOV     DPTR,#st
   \   000009   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET
   1391          
   1392          /**
   1393           *  @brief      Get the current DLPF setting.
   1394           *  @param[out] lpf Current LPF setting.
   1395           *  0 if successful.
   1396           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1397          int mpu_get_lpf(unsigned short *lpf)
   \                     mpu_get_lpf:
   1398          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1399              switch (st.chip_cfg.lpf) {
   \   000004   90....       MOV     DPTR,#st + 7
   \   000007   E0           MOVX    A,@DPTR
   \   000008   14           DEC     A
   \   000009   6011         JZ      ??mpu_get_lpf_0
   \   00000B   14           DEC     A
   \   00000C   6019         JZ      ??mpu_get_lpf_1
   \   00000E   14           DEC     A
   \   00000F   601E         JZ      ??mpu_get_lpf_2
   \   000011   14           DEC     A
   \   000012   6023         JZ      ??mpu_get_lpf_3
   \   000014   14           DEC     A
   \   000015   6028         JZ      ??mpu_get_lpf_4
   \   000017   14           DEC     A
   \   000018   602D         JZ      ??mpu_get_lpf_5
   \   00001A   8033         SJMP    ??mpu_get_lpf_6
   1400              case INV_FILTER_188HZ:
   1401                  lpf[0] = 188;
   \                     ??mpu_get_lpf_0:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   74BC         MOV     A,#-0x44
   \                     ??mpu_get_lpf_7:
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E4           CLR     A
   \   000025   802F         SJMP    ??mpu_get_lpf_8
   1402                  break;
   1403              case INV_FILTER_98HZ:
   1404                  lpf[0] = 98;
   \                     ??mpu_get_lpf_1:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   7462         MOV     A,#0x62
   \   00002D   80F3         SJMP    ??mpu_get_lpf_7
   1405                  break;
   1406              case INV_FILTER_42HZ:
   1407                  lpf[0] = 42;
   \                     ??mpu_get_lpf_2:
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   742A         MOV     A,#0x2a
   \   000035   80EB         SJMP    ??mpu_get_lpf_7
   1408                  break;
   1409              case INV_FILTER_20HZ:
   1410                  lpf[0] = 20;
   \                     ??mpu_get_lpf_3:
   \   000037   8A82         MOV     DPL,R2
   \   000039   8B83         MOV     DPH,R3
   \   00003B   7414         MOV     A,#0x14
   \   00003D   80E3         SJMP    ??mpu_get_lpf_7
   1411                  break;
   1412              case INV_FILTER_10HZ:
   1413                  lpf[0] = 10;
   \                     ??mpu_get_lpf_4:
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   740A         MOV     A,#0xa
   \   000045   80DB         SJMP    ??mpu_get_lpf_7
   1414                  break;
   1415              case INV_FILTER_5HZ:
   1416                  lpf[0] = 5;
   \                     ??mpu_get_lpf_5:
   \   000047   8A82         MOV     DPL,R2
   \   000049   8B83         MOV     DPH,R3
   \   00004B   7405         MOV     A,#0x5
   \   00004D   80D3         SJMP    ??mpu_get_lpf_7
   1417                  break;
   1418              case INV_FILTER_256HZ_NOLPF2:
   1419              case INV_FILTER_2100HZ_NOLPF:
   1420              default:
   1421                  lpf[0] = 0;
   \                     ??mpu_get_lpf_6:
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   1422                  break;
   1423              }
   \                     ??mpu_get_lpf_8:
   \   000056   02....       LJMP    ??Subroutine111_0 & 0xFFFF
   1424              return 0;
   1425          }
   1426          
   1427          /**
   1428           *  @brief      Set digital low pass filter.
   1429           *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
   1430           *  @param[in]  lpf Desired LPF setting.
   1431           *  @return     0 if successful.
   1432           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1433          int mpu_set_lpf(unsigned short lpf)
   \                     mpu_set_lpf:
   1434          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1435              unsigned char data;
   1436          
   1437              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7007         JNZ     ??mpu_set_lpf_0
   1438                  return -1;
   \                     ??mpu_set_lpf_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   02....       LJMP    ??mpu_set_lpf_2 & 0xFFFF
   1439          
   1440              if (lpf >= 188)
   \                     ??mpu_set_lpf_0:
   \   000017   C3           CLR     C
   \   000018   EA           MOV     A,R2
   \   000019   94BC         SUBB    A,#-0x44
   \   00001B   EB           MOV     A,R3
   \   00001C   9400         SUBB    A,#0x0
   \   00001E   400A         JC      ??mpu_set_lpf_3
   1441                  data = INV_FILTER_188HZ;
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   7401         MOV     A,#0x1
   \   000028   804E         SJMP    ??mpu_set_lpf_4
   1442              else if (lpf >= 98)
   \                     ??mpu_set_lpf_3:
   \   00002A   C3           CLR     C
   \   00002B   EA           MOV     A,R2
   \   00002C   9462         SUBB    A,#0x62
   \   00002E   EB           MOV     A,R3
   \   00002F   9400         SUBB    A,#0x0
   \   000031   400A         JC      ??mpu_set_lpf_5
   1443                  data = INV_FILTER_98HZ;
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   7402         MOV     A,#0x2
   \   00003B   803B         SJMP    ??mpu_set_lpf_4
   1444              else if (lpf >= 42)
   \                     ??mpu_set_lpf_5:
   \   00003D   C3           CLR     C
   \   00003E   EA           MOV     A,R2
   \   00003F   942A         SUBB    A,#0x2a
   \   000041   EB           MOV     A,R3
   \   000042   9400         SUBB    A,#0x0
   \   000044   400A         JC      ??mpu_set_lpf_6
   1445                  data = INV_FILTER_42HZ;
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   7403         MOV     A,#0x3
   \   00004E   8028         SJMP    ??mpu_set_lpf_4
   1446              else if (lpf >= 20)
   \                     ??mpu_set_lpf_6:
   \   000050   C3           CLR     C
   \   000051   EA           MOV     A,R2
   \   000052   9414         SUBB    A,#0x14
   \   000054   EB           MOV     A,R3
   \   000055   9400         SUBB    A,#0x0
   \   000057   400A         JC      ??mpu_set_lpf_7
   1447                  data = INV_FILTER_20HZ;
   \   000059   85..82       MOV     DPL,?XSP + 0
   \   00005C   85..83       MOV     DPH,?XSP + 1
   \   00005F   7404         MOV     A,#0x4
   \   000061   8015         SJMP    ??mpu_set_lpf_4
   1448              else if (lpf >= 10)
   \                     ??mpu_set_lpf_7:
   \   000063   C3           CLR     C
   \   000064   EA           MOV     A,R2
   \   000065   940A         SUBB    A,#0xa
   \   000067   EB           MOV     A,R3
   \   000068   9400         SUBB    A,#0x0
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   4004         JC      ??mpu_set_lpf_8
   1449                  data = INV_FILTER_10HZ;
   \   000072   7405         MOV     A,#0x5
   \   000074   8002         SJMP    ??mpu_set_lpf_4
   1450              else
   1451                  data = INV_FILTER_5HZ;
   \                     ??mpu_set_lpf_8:
   \   000076   7406         MOV     A,#0x6
   \                     ??mpu_set_lpf_4:
   \   000078   F0           MOVX    @DPTR,A
   1452          
   1453              if (st.chip_cfg.lpf == data)
   \   000079   90....       MOV     DPTR,#st + 7
   \   00007C   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   00007F   68           XRL     A,R0
   \   000080   6013         JZ      ??mpu_set_lpf_9
   1454                  return 0;
   1455              if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
   \   000082                ; Setup parameters for call to function I2C_Write
   \   000082   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000085   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   000088   7086         JNZ     ??mpu_set_lpf_1
   1456                  return -1;
   1457              st.chip_cfg.lpf = data;
   \   00008A   85..82       MOV     DPL,?XSP + 0
   \   00008D   85..83       MOV     DPH,?XSP + 1
   \   000090   E0           MOVX    A,@DPTR
   \   000091   90....       MOV     DPTR,#st + 7
   \   000094   F0           MOVX    @DPTR,A
   1458              return 0;
   \                     ??mpu_set_lpf_9:
   \   000095   7A00         MOV     R2,#0x0
   \   000097   7B00         MOV     R3,#0x0
   \                     ??mpu_set_lpf_2:
   \   000099   02....       LJMP    ?Subroutine3 & 0xFFFF
   1459          }
   1460          
   1461          /**
   1462           *  @brief      Get sampling rate.
   1463           *  @param[out] rate    Current sampling rate (Hz).
   1464           *  @return     0 if successful.
   1465           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1466          int mpu_get_sample_rate(unsigned short *rate)
   \                     mpu_get_sample_rate:
   1467          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1468              if (st.chip_cfg.dmp_on)
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6006         JZ      ??mpu_get_sample_rate_0
   1469                  return -1;
   \   00000A   7AFF         MOV     R2,#-0x1
   \   00000C   7BFF         MOV     R3,#-0x1
   \   00000E   8010         SJMP    ??CrossCallReturnLabel_247
   1470              else
   1471                  rate[0] = st.chip_cfg.sample_rate;
   \                     ??mpu_get_sample_rate_0:
   \   000010   90....       MOV     DPTR,#st + 9
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   E8           MOV     A,R0
   \   00001D   12....       LCALL   ?Subroutine64 & 0xFFFF
   1472              return 0;
   \                     ??CrossCallReturnLabel_247:
   \   000020   02....       LJMP    ??Subroutine113_0 & 0xFFFF
   1473          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003                REQUIRE ??Subroutine131_0
   \   000003                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7A00         MOV     R2,#0x0
   \   000003   7B00         MOV     R3,#0x0
   \   000005   22           RET
   1474          
   1475          /**
   1476           *  @brief      Set sampling rate.
   1477           *  Sampling rate must be between 4Hz and 1kHz.
   1478           *  @param[in]  rate    Desired sampling rate (Hz).
   1479           *  @return     0 if successful.
   1480           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1481          int mpu_set_sample_rate(unsigned short rate)
   \                     mpu_set_sample_rate:
   1482          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1483              unsigned char data;
   1484          
   1485              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_set_sample_rate_0
   1486                  return -1;
   \                     ??mpu_set_sample_rate_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_set_sample_rate_2 & 0xFFFF
   1487          
   1488              if (st.chip_cfg.dmp_on)
   \                     ??mpu_set_sample_rate_0:
   \   00001B   90....       MOV     DPTR,#st + 29
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   70F3         JNZ     ??mpu_set_sample_rate_1
   1489                  return -1;
   1490              else {
   1491                  if (st.chip_cfg.lp_accel_mode) {
   \   000021   90....       MOV     DPTR,#st + 15
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6019         JZ      ??mpu_set_sample_rate_3
   1492                      if (rate && (rate <= 40)) {
   \   000027   EE           MOV     A,R6
   \   000028   4F           ORL     A,R7
   \   000029   6010         JZ      ??mpu_set_sample_rate_4
   \   00002B   C3           CLR     C
   \   00002C   EE           MOV     A,R6
   \   00002D   9429         SUBB    A,#0x29
   \   00002F   EF           MOV     A,R7
   \   000030   9400         SUBB    A,#0x0
   \   000032   5007         JNC     ??mpu_set_sample_rate_4
   1493                          /* Just stay in low-power accel mode. */
   1494                          mpu_lp_accel_mode(rate);
   \   000034                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000034   EE           MOV     A,R6
   \   000035   F9           MOV     R1,A
   \   000036   12....       LCALL   ??mpu_lp_accel_mode?relay
   1495                          return 0;
   \   000039   8062         SJMP    ??mpu_set_sample_rate_5
   1496                      }
   1497                      /* Requested rate exceeds the allowed frequencies in LP accel mode,
   1498                       * switch back to full-power mode.
   1499                       */
   1500                      mpu_lp_accel_mode(0);
   \                     ??mpu_set_sample_rate_4:
   \   00003B                ; Setup parameters for call to function mpu_lp_accel_mode
   \   00003B   7900         MOV     R1,#0x0
   \   00003D   12....       LCALL   ??mpu_lp_accel_mode?relay
   1501                  }
   1502                  if (rate < 4)
   \                     ??mpu_set_sample_rate_3:
   \   000040   C3           CLR     C
   \   000041   EE           MOV     A,R6
   \   000042   9404         SUBB    A,#0x4
   \   000044   EF           MOV     A,R7
   \   000045   9400         SUBB    A,#0x0
   \   000047   5006         JNC     ??mpu_set_sample_rate_6
   1503                      rate = 4;
   \   000049   7E04         MOV     R6,#0x4
   \   00004B   7F00         MOV     R7,#0x0
   \   00004D   800D         SJMP    ??mpu_set_sample_rate_7
   1504                  else if (rate > 1000)
   \                     ??mpu_set_sample_rate_6:
   \   00004F   C3           CLR     C
   \   000050   EE           MOV     A,R6
   \   000051   94E9         SUBB    A,#-0x17
   \   000053   EF           MOV     A,R7
   \   000054   9403         SUBB    A,#0x3
   \   000056   4004         JC      ??mpu_set_sample_rate_7
   1505                      rate = 1000;
   \   000058   7EE8         MOV     R6,#-0x18
   \   00005A   7F03         MOV     R7,#0x3
   1506          
   1507                  data = 1000 / rate - 1;
   \                     ??mpu_set_sample_rate_7:
   \   00005C   78E8         MOV     R0,#-0x18
   \   00005E   7903         MOV     R1,#0x3
   \   000060   EE           MOV     A,R6
   \   000061   FA           MOV     R2,A
   \   000062   EF           MOV     A,R7
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   ?US_DIV_MOD
   \   000067   E8           MOV     A,R0
   \   000068   14           DEC     A
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   12....       LCALL   ?Subroutine37 & 0xFFFF
   1508                  if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
   \                     ??CrossCallReturnLabel_193:
   \   000072   A3           INC     DPTR
   \   000073   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000076   709C         JNZ     ??mpu_set_sample_rate_1
   1509                      return -1;
   1510          
   1511                  st.chip_cfg.sample_rate = 1000 / (1 + data);
   \   000078   78E8         MOV     R0,#-0x18
   \   00007A   7903         MOV     R1,#0x3
   \   00007C   85..82       MOV     DPL,?XSP + 0
   \   00007F   85..83       MOV     DPH,?XSP + 1
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2401         ADD     A,#0x1
   \   000085   FA           MOV     R2,A
   \   000086   E4           CLR     A
   \   000087   3400         ADDC    A,#0x0
   \   000089   FB           MOV     R3,A
   \   00008A   12....       LCALL   ?S_DIV_MOD
   \   00008D   90....       MOV     DPTR,#st + 9
   \   000090   12....       LCALL   ?Subroutine65 & 0xFFFF
   1512          
   1513          #ifdef AK89xx_SECONDARY
   1514                  mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
   1515          #endif
   1516          
   1517                  /* Automatically set LPF to 1/2 sampling rate. */
   1518                  mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
   \                     ??CrossCallReturnLabel_161:
   \   000093                ; Setup parameters for call to function mpu_set_lpf
   \   000093   90....       MOV     DPTR,#st + 9
   \   000096   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000099   FA           MOV     R2,A
   \   00009A   12....       LCALL   ??mpu_set_lpf?relay
   1519                  return 0;
   \                     ??mpu_set_sample_rate_5:
   \   00009D   7A00         MOV     R2,#0x0
   \   00009F   7B00         MOV     R3,#0x0
   1520              }
   \                     ??mpu_set_sample_rate_2:
   \   0000A1   02....       LJMP    ?Subroutine3 & 0xFFFF
   1521          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C3           CLR     C
   \   000005   13           RRC     A
   \   000006   FB           MOV     R3,A
   \   000007   EA           MOV     A,R2
   \   000008   13           RRC     A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000003                REQUIRE ??Subroutine118_0
   \   000003                ; // Fall through to label ??Subroutine118_0
   1522          
   1523          /**
   1524           *  @brief      Get compass sampling rate.
   1525           *  @param[out] rate    Current compass sampling rate (Hz).
   1526           *  @return     0 if successful.
   1527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1528          int mpu_get_compass_sample_rate(unsigned short *rate)
   \                     mpu_get_compass_sample_rate:
   1529          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1530          #ifdef AK89xx_SECONDARY
   1531              rate[0] = st.chip_cfg.compass_sample_rate;
   1532              return 0;
   1533          #else
   1534              rate[0] = 0;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   F0           MOVX    @DPTR,A
   1535              return -1;
   \   00000C   7AFF         MOV     R2,#-0x1
   \   00000E   7BFF         MOV     R3,#-0x1
   \   000010   02....       LJMP    ??Subroutine113_0 & 0xFFFF
   1536          #endif
   1537          }
   1538          
   1539          /**
   1540           *  @brief      Set compass sampling rate.
   1541           *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
   1542           *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
   1543           *  sampling rate.
   1544           *
   1545           *  \n WARNING: The new rate may be different than what was requested. Call
   1546           *  mpu_get_compass_sample_rate to check the actual setting.
   1547           *  @param[in]  rate    Desired compass sampling rate (Hz).
   1548           *  @return     0 if successful.
   1549           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1550          int mpu_set_compass_sample_rate(unsigned short rate)
   \                     mpu_set_compass_sample_rate:
   1551          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1552          #ifdef AK89xx_SECONDARY
   1553              unsigned char div;
   1554              if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
   1555                  return -1;
   1556          
   1557              div = st.chip_cfg.sample_rate / rate - 1;
   1558              if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
   1559                  return -1;
   1560              st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
   1561              return 0;
   1562          #else
   1563              return -1;
   \   000000                REQUIRE ?Subroutine2
   \   000000                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7AFF         MOV     R2,#-0x1
   \   000002   7BFF         MOV     R3,#-0x1
   \   000004   02....       LJMP    ?BRET
   1564          #endif
   1565          }
   1566          
   1567          /**
   1568           *  @brief      Get gyro sensitivity scale factor.
   1569           *  @param[out] sens    Conversion from hardware units to dps.
   1570           *  @return     0 if successful.
   1571           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1572          int mpu_get_gyro_sens(float *sens)
   \                     mpu_get_gyro_sens:
   1573          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   1574              switch (st.chip_cfg.gyro_fsr) {
   \   000009   90....       MOV     DPTR,#st + 4
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   600B         JZ      ??mpu_get_gyro_sens_0
   \   00000F   14           DEC     A
   \   000010   601C         JZ      ??mpu_get_gyro_sens_1
   \   000012   14           DEC     A
   \   000013   601E         JZ      ??mpu_get_gyro_sens_2
   \   000015   14           DEC     A
   \   000016   6020         JZ      ??mpu_get_gyro_sens_3
   \   000018   8023         SJMP    ??mpu_get_gyro_sens_4
   1575              case INV_FSR_250DPS:
   1576                  sens[0] = 131.f;
   \                     ??mpu_get_gyro_sens_0:
   \   00001A   90....       MOV     DPTR,#__Constant_43030000
   \                     ??mpu_get_gyro_sens_5:
   \   00001D   12....       LCALL   ?XLOAD_R2345
   \   000020   8882         MOV     DPL,R0
   \   000022   8983         MOV     DPH,R1
   \   000024   12....       LCALL   ?XSTORE_R2345
   1577                  break;
   1578              case INV_FSR_500DPS:
   1579                  sens[0] = 65.5f;
   1580                  break;
   1581              case INV_FSR_1000DPS:
   1582                  sens[0] = 32.8f;
   1583                  break;
   1584              case INV_FSR_2000DPS:
   1585                  sens[0] = 16.4f;
   1586                  break;
   1587              default:
   1588                  return -1;
   1589              }
   1590              return 0;
   \   000027   7A00         MOV     R2,#0x0
   \   000029   7B00         MOV     R3,#0x0
   \                     ??mpu_get_gyro_sens_6:
   \   00002B   02....       LJMP    ?Subroutine4 & 0xFFFF
   \                     ??mpu_get_gyro_sens_1:
   \   00002E   90....       MOV     DPTR,#__Constant_42830000
   \   000031   80EA         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_2:
   \   000033   90....       MOV     DPTR,#__Constant_42033333
   \   000036   80E5         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_3:
   \   000038   90....       MOV     DPTR,#__Constant_41833333
   \   00003B   80E0         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_4:
   \   00003D   7AFF         MOV     R2,#-0x1
   \   00003F   7BFF         MOV     R3,#-0x1
   \   000041   80E8         SJMP    ??mpu_get_gyro_sens_6
   1591          }
   1592          
   1593          /**
   1594           *  @brief      Get accel sensitivity scale factor.
   1595           *  @param[out] sens    Conversion from hardware units to g's.
   1596           *  @return     0 if successful.
   1597           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1598          int mpu_get_accel_sens(unsigned short *sens)
   \                     mpu_get_accel_sens:
   1599          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1600              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_sens_0
   \   00000A   14           DEC     A
   \   00000B   6033         JZ      ??mpu_get_accel_sens_1
   \   00000D   14           DEC     A
   \   00000E   603C         JZ      ??mpu_get_accel_sens_2
   \   000010   14           DEC     A
   \   000011   6044         JZ      ??mpu_get_accel_sens_3
   \   000013   804D         SJMP    ??mpu_get_accel_sens_4
   1601              case INV_FSR_2G:
   1602                  sens[0] = 16384;
   \                     ??mpu_get_accel_sens_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7440         MOV     A,#0x40
   \                     ??mpu_get_accel_sens_5:
   \   00001E   F0           MOVX    @DPTR,A
   1603                  break;
   1604              case INV_FSR_4G:
   1605                  sens[0] = 8092;
   1606                  break;
   1607              case INV_FSR_8G:
   1608                  sens[0] = 4096;
   1609                  break;
   1610              case INV_FSR_16G:
   1611                  sens[0] = 2048;
   1612                  break;
   1613              default:
   1614                  return -1;
   1615              }
   1616              if (st.chip_cfg.accel_half)
   \   00001F   90....       MOV     DPTR,#st + 14
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6014         JZ      ??CrossCallReturnLabel_156
   1617                  sens[0] >>= 1;
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   C3           CLR     C
   \   00002E   13           RRC     A
   \   00002F   F9           MOV     R1,A
   \   000030   E8           MOV     A,R0
   \   000031   13           RRC     A
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1618              return 0;
   \                     ??CrossCallReturnLabel_156:
   \   000039   7A00         MOV     R2,#0x0
   \   00003B   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_sens_6:
   \   00003D   02....       LJMP    ??Subroutine113_0 & 0xFFFF
   \                     ??mpu_get_accel_sens_1:
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   749C         MOV     A,#-0x64
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   741F         MOV     A,#0x1f
   \   00004A   80D2         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_2:
   \   00004C   8A82         MOV     DPL,R2
   \   00004E   8B83         MOV     DPH,R3
   \   000050   E4           CLR     A
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   7410         MOV     A,#0x10
   \   000055   80C7         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_3:
   \   000057   8A82         MOV     DPL,R2
   \   000059   8B83         MOV     DPH,R3
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   7408         MOV     A,#0x8
   \   000060   80BC         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_4:
   \   000062   7AFF         MOV     R2,#-0x1
   \   000064   7BFF         MOV     R3,#-0x1
   \   000066   80D5         SJMP    ??mpu_get_accel_sens_6
   1619          }
   1620          
   1621          /**
   1622           *  @brief      Get current FIFO configuration.
   1623           *  @e sensors can contain a combination of the following flags:
   1624           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1625           *  \n INV_XYZ_GYRO
   1626           *  \n INV_XYZ_ACCEL
   1627           *  @param[out] sensors Mask of sensors in FIFO.
   1628           *  @return     0 if successful.
   1629           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1630          int mpu_get_fifo_config(unsigned char *sensors)
   \                     mpu_get_fifo_config:
   1631          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1632              sensors[0] = st.chip_cfg.fifo_enable;
   \   000004   90....       MOV     DPTR,#st + 11
   \   000007   02....       LJMP    ?Subroutine1 & 0xFFFF
   1633              return 0;
   1634          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005                REQUIRE ??Subroutine111_0
   \   000005                ; // Fall through to label ??Subroutine111_0
   1635          
   1636          /**
   1637           *  @brief      Select which sensors are pushed to FIFO.
   1638           *  @e sensors can contain a combination of the following flags:
   1639           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1640           *  \n INV_XYZ_GYRO
   1641           *  \n INV_XYZ_ACCEL
   1642           *  @param[in]  sensors Mask of sensors to push to FIFO.
   1643           *  @return     0 if successful.
   1644           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1645          int mpu_configure_fifo(unsigned char sensors)
   \                     mpu_configure_fifo:
   1646          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1647              unsigned char prev;
   1648              int result = 0;
   1649          
   1650              /* Compass data isn't going into the FIFO. Stop trying. */
   1651              sensors &= ~INV_XYZ_COMPASS;
   \   000005   E9           MOV     A,R1
   \   000006   C2E0         CLR     0xE0 /* A   */.0
   \   000008   F5..         MOV     ?V0 + 0,A
   1652          
   1653              if (st.chip_cfg.dmp_on)
   \   00000A   90....       MOV     DPTR,#st + 29
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6006         JZ      ??mpu_configure_fifo_0
   1654                  return 0;
   \   000010   7A00         MOV     R2,#0x0
   \   000012   7B00         MOV     R3,#0x0
   \   000014   803E         SJMP    ??mpu_configure_fifo_1
   1655              else {
   1656                  if (!(st.chip_cfg.sensors))
   \                     ??mpu_configure_fifo_0:
   \   000016   90....       MOV     DPTR,#st + 6
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F8           MOV     R0,A
   \   00001B   7006         JNZ     ??mpu_configure_fifo_2
   1657                      return -1;
   \                     ??mpu_configure_fifo_3:
   \   00001D   7AFF         MOV     R2,#-0x1
   \   00001F   7BFF         MOV     R3,#-0x1
   \   000021   8031         SJMP    ??mpu_configure_fifo_1
   1658                  prev = st.chip_cfg.fifo_enable;
   \                     ??mpu_configure_fifo_2:
   \   000023   90....       MOV     DPTR,#st + 11
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F5..         MOV     ?V0 + 1,A
   1659                  st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
   \   000029   E5..         MOV     A,?V0 + 0
   \   00002B   58           ANL     A,R0
   \   00002C   F8           MOV     R0,A
   \   00002D   F0           MOVX    @DPTR,A
   1660                  if (st.chip_cfg.fifo_enable != sensors)
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   68           XRL     A,R0
   \   000031   6006         JZ      ??mpu_configure_fifo_4
   1661                      /* You're not getting what you asked for. Some sensors are
   1662                       * asleep.
   1663                       */
   1664                      result = -1;
   \   000033   7EFF         MOV     R6,#-0x1
   \   000035   7FFF         MOV     R7,#-0x1
   \   000037   8004         SJMP    ??mpu_configure_fifo_5
   1665                  else
   1666                      result = 0;
   \                     ??mpu_configure_fifo_4:
   \   000039   7E00         MOV     R6,#0x0
   \   00003B   7F00         MOV     R7,#0x0
   1667                  if (sensors || st.chip_cfg.lp_accel_mode)
   \                     ??mpu_configure_fifo_5:
   \   00003D   E5..         MOV     A,?V0 + 0
   \   00003F   7006         JNZ     ??mpu_configure_fifo_6
   \   000041   90....       MOV     DPTR,#st + 15
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6010         JZ      ??mpu_configure_fifo_7
   1668                      set_int_enable(1);
   \                     ??mpu_configure_fifo_6:
   \   000047                ; Setup parameters for call to function set_int_enable
   \   000047   7901         MOV     R1,#0x1
   \   000049   12....       LCALL   ??set_int_enable?relay
   1669                  else
   1670                      set_int_enable(0);
   1671                  if (sensors) {
   \   00004C   E5..         MOV     A,?V0 + 0
   \   00004E   700E         JNZ     ??mpu_configure_fifo_8
   1672                      if (mpu_reset_fifo()) {
   1673                          st.chip_cfg.fifo_enable = prev;
   1674                          return -1;
   1675                      }
   1676                  }
   1677              }
   1678          
   1679              return result;
   \                     ??mpu_configure_fifo_9:
   \   000050   EE           MOV     A,R6
   \   000051   FA           MOV     R2,A
   \   000052   EF           MOV     A,R7
   \   000053   FB           MOV     R3,A
   \                     ??mpu_configure_fifo_1:
   \   000054   02....       LJMP    ??Subroutine130_0 & 0xFFFF
   \                     ??mpu_configure_fifo_7:
   \   000057                ; Setup parameters for call to function set_int_enable
   \   000057   7900         MOV     R1,#0x0
   \   000059   12....       LCALL   ??set_int_enable?relay
   \   00005C   80F2         SJMP    ??mpu_configure_fifo_9
   \                     ??mpu_configure_fifo_8:
   \   00005E                ; Setup parameters for call to function mpu_reset_fifo
   \   00005E   12....       LCALL   ??mpu_reset_fifo?relay
   \   000061   8B..         MOV     ?V0 + 3,R3
   \   000063   EA           MOV     A,R2
   \   000064   45..         ORL     A,?V0 + 3
   \   000066   60E8         JZ      ??mpu_configure_fifo_9
   \   000068   E5..         MOV     A,?V0 + 1
   \   00006A   90....       MOV     DPTR,#st + 11
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   80AD         SJMP    ??mpu_configure_fifo_3
   1680          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1681          
   1682          /**
   1683           *  @brief      Get current power state.
   1684           *  @param[in]  power_on    1 if turned on, 0 if suspended.
   1685           *  @return     0 if successful.
   1686           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1687          int mpu_get_power_state(unsigned char *power_on)
   \                     mpu_get_power_state:
   1688          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1689              if (st.chip_cfg.sensors)
   \   000004   90....       MOV     DPTR,#st + 6
   \   000007   E0           MOVX    A,@DPTR
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   6004         JZ      ??mpu_get_power_state_0
   1690                  power_on[0] = 1;
   \   00000E   7401         MOV     A,#0x1
   \   000010   8001         SJMP    ??mpu_get_power_state_1
   1691              else
   1692                  power_on[0] = 0;
   \                     ??mpu_get_power_state_0:
   \   000012   E4           CLR     A
   \                     ??mpu_get_power_state_1:
   \   000013   80..         SJMP    ??Subroutine111_0
   1693              return 0;
   1694          }
   1695          
   1696          /**
   1697           *  @brief      Turn specific sensors on/off.
   1698           *  @e sensors can contain a combination of the following flags:
   1699           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1700           *  \n INV_XYZ_GYRO
   1701           *  \n INV_XYZ_ACCEL
   1702           *  \n INV_XYZ_COMPASS
   1703           *  @param[in]  sensors    Mask of sensors to wake.
   1704           *  @return     0 if successful.
   1705           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1706          int mpu_set_sensors(unsigned char sensors)
   \                     mpu_set_sensors:
   1707          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1708              unsigned char data;
   1709          #ifdef AK89xx_SECONDARY
   1710              unsigned char user_ctrl;
   1711          #endif
   1712          
   1713              if (sensors & INV_XYZ_GYRO)
   \   00000C   7470         MOV     A,#0x70
   \   00000E   5E           ANL     A,R6
   \   00000F   600A         JZ      ??mpu_set_sensors_0
   1714                  data = INV_CLK_PLL;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7401         MOV     A,#0x1
   \   000019   800E         SJMP    ??mpu_set_sensors_1
   1715              else if (sensors)
   \                     ??mpu_set_sensors_0:
   \   00001B   EE           MOV     A,R6
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   6003         JZ      ??mpu_set_sensors_2
   1716                  data = 0;
   \   000024   E4           CLR     A
   \   000025   8002         SJMP    ??mpu_set_sensors_1
   1717              else
   1718                  data = BIT_SLEEP;
   \                     ??mpu_set_sensors_2:
   \   000027   7440         MOV     A,#0x40
   \                     ??mpu_set_sensors_1:
   \   000029   12....       LCALL   ?Subroutine63 & 0xFFFF
   1719              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
   \                     ??CrossCallReturnLabel_102:
   \   00002C   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   00002F   600B         JZ      ??mpu_set_sensors_3
   1720                  st.chip_cfg.sensors = 0;
   \                     ??mpu_set_sensors_4:
   \   000031   90....       MOV     DPTR,#st + 6
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   1721                  return -1;
   \   000036   7AFF         MOV     R2,#-0x1
   \   000038   7BFF         MOV     R3,#-0x1
   \   00003A   8066         SJMP    ??mpu_set_sensors_5
   1722              }
   1723              st.chip_cfg.clk_src = data & ~BIT_SLEEP;
   \                     ??mpu_set_sensors_3:
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   E0           MOVX    A,@DPTR
   \   000043   54BF         ANL     A,#0xbf
   \   000045   90....       MOV     DPTR,#st + 8
   \   000048   12....       LCALL   ?Subroutine101 & 0xFFFF
   1724          
   1725              data = 0;
   \                     ??CrossCallReturnLabel_264:
   \   00004B   E4           CLR     A
   \   00004C   F0           MOVX    @DPTR,A
   1726              if (!(sensors & INV_X_GYRO))
   \   00004D   EE           MOV     A,R6
   \   00004E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000050   4003         JC      ??mpu_set_sensors_6
   1727                  data |= BIT_STBY_XG;
   \   000052   7404         MOV     A,#0x4
   \   000054   F0           MOVX    @DPTR,A
   1728              if (!(sensors & INV_Y_GYRO))
   \                     ??mpu_set_sensors_6:
   \   000055   EE           MOV     A,R6
   \   000056   A2E5         MOV     C,0xE0 /* A   */.5
   \   000058   4004         JC      ??mpu_set_sensors_7
   1729                  data |= BIT_STBY_YG;
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   D2E1         SETB    0xE0 /* A   */.1
   \   00005D   F0           MOVX    @DPTR,A
   1730              if (!(sensors & INV_Z_GYRO))
   \                     ??mpu_set_sensors_7:
   \   00005E   EE           MOV     A,R6
   \   00005F   A2E4         MOV     C,0xE0 /* A   */.4
   \   000061   4004         JC      ??mpu_set_sensors_8
   1731                  data |= BIT_STBY_ZG;
   \   000063   E0           MOVX    A,@DPTR
   \   000064   D2E0         SETB    0xE0 /* A   */.0
   \   000066   F0           MOVX    @DPTR,A
   1732              if (!(sensors & INV_XYZ_ACCEL))
   \                     ??mpu_set_sensors_8:
   \   000067   EE           MOV     A,R6
   \   000068   A2E3         MOV     C,0xE0 /* A   */.3
   \   00006A   4004         JC      ??mpu_set_sensors_9
   1733                  data |= BIT_STBY_XYZA;
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   4438         ORL     A,#0x38
   \   00006F   F0           MOVX    @DPTR,A
   1734              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
   \                     ??mpu_set_sensors_9:
   \   000070                ; Setup parameters for call to function I2C_Write
   \   000070   AC82         MOV     R4,DPL
   \   000072   AD83         MOV     R5,DPH
   \   000074   7B01         MOV     R3,#0x1
   \   000076   90....       MOV     DPTR,#st
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   2413         ADD     A,#0x13
   \   00007C   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   00007F   70B0         JNZ     ??mpu_set_sensors_4
   1735                  st.chip_cfg.sensors = 0;
   1736                  return -1;
   1737              }
   1738          
   1739              if (sensors && (sensors != INV_XYZ_ACCEL))
   \   000081   EE           MOV     A,R6
   \   000082   600A         JZ      ??mpu_set_sensors_10
   \   000084   7408         MOV     A,#0x8
   \   000086   6E           XRL     A,R6
   \   000087   6005         JZ      ??mpu_set_sensors_10
   1740                  /* Latched interrupts only used in LP accel mode. */
   1741                  mpu_set_int_latched(0);
   \   000089                ; Setup parameters for call to function mpu_set_int_latched
   \   000089   7900         MOV     R1,#0x0
   \   00008B   12....       LCALL   ??mpu_set_int_latched?relay
   1742          
   1743          #ifdef AK89xx_SECONDARY
   1744          #ifdef AK89xx_BYPASS
   1745              if (sensors & INV_XYZ_COMPASS)
   1746                  mpu_set_bypass(1);
   1747              else
   1748                  mpu_set_bypass(0);
   1749          #else
   1750              if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1751                  return -1;
   1752              /* Handle AKM power management. */
   1753              if (sensors & INV_XYZ_COMPASS) {
   1754                  data = AKM_SINGLE_MEASUREMENT;
   1755                  user_ctrl |= BIT_AUX_IF_EN;
   1756              } else {
   1757                  data = AKM_POWER_DOWN;
   1758                  user_ctrl &= ~BIT_AUX_IF_EN;
   1759              }
   1760              if (st.chip_cfg.dmp_on)
   1761                  user_ctrl |= BIT_DMP_EN;
   1762              else
   1763                  user_ctrl &= ~BIT_DMP_EN;
   1764              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
   1765                  return -1;
   1766              /* Enable/disable I2C master mode. */
   1767              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1768                  return -1;
   1769          #endif
   1770          #endif
   1771          
   1772              st.chip_cfg.sensors = sensors;
   \                     ??mpu_set_sensors_10:
   \   00008E   EE           MOV     A,R6
   \   00008F   90....       MOV     DPTR,#st + 6
   \   000092   F0           MOVX    @DPTR,A
   1773              st.chip_cfg.lp_accel_mode = 0;
   \   000093   90....       MOV     DPTR,#st + 15
   \   000096   E4           CLR     A
   \   000097   F0           MOVX    @DPTR,A
   1774              delay_ms(50);
   \   000098                ; Setup parameters for call to function delay_ms
   \   000098   7A32         MOV     R2,#0x32
   \   00009A   FB           MOV     R3,A
   \   00009B   12....       LCALL   ??delay_ms?relay
   1775              return 0;
   \   00009E   7A00         MOV     R2,#0x0
   \   0000A0   7B00         MOV     R3,#0x0
   \                     ??mpu_set_sensors_5:
   \   0000A2                REQUIRE ?Subroutine3
   \   0000A2                ; // Fall through to label ?Subroutine3
   1776          }
   1777          
   1778          /**
   1779           *  @brief      Read the MPU interrupt status registers.
   1780           *  @param[out] status  Mask of interrupt bits.
   1781           *  @return     0 if successful.
   1782           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1783          int mpu_get_int_status(short *status)
   \                     mpu_get_int_status:
   1784          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1785              unsigned char tmp[2];
   1786              if (!st.chip_cfg.sensors)
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7006         JNZ     ??mpu_get_int_status_0
   1787                  return -1;
   \                     ??mpu_get_int_status_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   8023         SJMP    ??CrossCallReturnLabel_248
   1788              if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
   \                     ??mpu_get_int_status_0:
   \   00001A                ; Setup parameters for call to function I2C_Read
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   AC82         MOV     R4,DPL
   \   000022   AD83         MOV     R5,DPH
   \   000024   7B02         MOV     R3,#0x2
   \   000026   90....       MOV     DPTR,#st
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   2410         ADD     A,#0x10
   \   00002C   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   00002F   70E3         JNZ     ??mpu_get_int_status_1
   1789                  return -1;
   1790              status[0] = (tmp[0] << 8) | tmp[1];
   \   000031   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   00003A   12....       LCALL   ?Subroutine64 & 0xFFFF
   1791              return 0;
   \                     ??CrossCallReturnLabel_248:
   \   00003D   02....       LJMP    ?Subroutine9 & 0xFFFF
   1792          }
   1793          
   1794          /**
   1795           *  @brief      Get one packet from the FIFO.
   1796           *  If @e sensors does not contain a particular sensor, disregard the data
   1797           *  returned to that pointer.
   1798           *  \n @e sensors can contain a combination of the following flags:
   1799           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1800           *  \n INV_XYZ_GYRO
   1801           *  \n INV_XYZ_ACCEL
   1802           *  \n If the FIFO has no new data, @e sensors will be zero.
   1803           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
   1804           *  return a non-zero error code.
   1805           *  @param[out] gyro        Gyro data in hardware units.
   1806           *  @param[out] accel       Accel data in hardware units.
   1807           *  @param[out] timestamp   Timestamp in milliseconds.
   1808           *  @param[out] sensors     Mask of sensors read from FIFO.
   1809           *  @param[out] more        Number of remaining packets.
   1810           *  @return     0 if successful.
   1811           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1812          int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
   \                     mpu_read_fifo:
   1813                  unsigned char *sensors, unsigned char *more)
   1814          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 10,R2
   \   00000C   8B..         MOV     ?V0 + 11,R3
   \   00000E   8C..         MOV     ?V0 + 8,R4
   \   000010   8D..         MOV     ?V0 + 9,R5
   \   000012   7426         MOV     A,#0x26
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   00001A   7428         MOV     A,#0x28
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 14,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 15,A
   1815              /* Assumes maximum packet size is gyro (6) + accel (6). */
   1816              unsigned char data[MAX_PACKET_LENGTH];
   1817              unsigned char packet_size = 0;
   \   000026   75..00       MOV     ?V0 + 2,#0x0
   1818              unsigned short fifo_count, index = 0;
   \   000029   7E00         MOV     R6,#0x0
   \   00002B   7F00         MOV     R7,#0x0
   1819          
   1820              if (st.chip_cfg.dmp_on)
   \   00002D   90....       MOV     DPTR,#st + 29
   \   000030   E0           MOVX    A,@DPTR
   \   000031   6009         JZ      ??mpu_read_fifo_0
   1821                  return -1;
   \                     ??mpu_read_fifo_1:
   \   000033   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_2:
   \   000035   7BFF         MOV     R3,#-0x1
   \                     ??mpu_read_fifo_3:
   \   000037   740C         MOV     A,#0xc
   \   000039   02....       LJMP    ?Subroutine6 & 0xFFFF
   1822          
   1823              sensors[0] = 0;
   \                     ??mpu_read_fifo_0:
   \   00003C   85..82       MOV     DPL,?V0 + 4
   \   00003F   85..83       MOV     DPH,?V0 + 5
   \   000042   E4           CLR     A
   \   000043   F0           MOVX    @DPTR,A
   1824              if (!st.chip_cfg.sensors)
   \   000044   90....       MOV     DPTR,#st + 6
   \   000047   E0           MOVX    A,@DPTR
   \   000048   60E9         JZ      ??mpu_read_fifo_1
   1825                  return -1;
   1826              if (!st.chip_cfg.fifo_enable)
   \   00004A   90....       MOV     DPTR,#st + 11
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   60E3         JZ      ??mpu_read_fifo_1
   1827                  return -1;
   1828          
   1829              if (st.chip_cfg.fifo_enable & INV_X_GYRO)
   \   000050   A2E6         MOV     C,0xE0 /* A   */.6
   \   000052   5003         JNC     ??mpu_read_fifo_4
   1830                  packet_size += 2;
   \   000054   75..02       MOV     ?V0 + 2,#0x2
   1831              if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
   \                     ??mpu_read_fifo_4:
   \   000057   A2E5         MOV     C,0xE0 /* A   */.5
   \   000059   5004         JNC     ??mpu_read_fifo_5
   1832                  packet_size += 2;
   \   00005B   05..         INC     ?V0 + 2
   \   00005D   05..         INC     ?V0 + 2
   1833              if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
   \                     ??mpu_read_fifo_5:
   \   00005F   A2E4         MOV     C,0xE0 /* A   */.4
   \   000061   5004         JNC     ??mpu_read_fifo_6
   1834                  packet_size += 2;
   \   000063   05..         INC     ?V0 + 2
   \   000065   05..         INC     ?V0 + 2
   1835              if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
   \                     ??mpu_read_fifo_6:
   \   000067   A2E3         MOV     C,0xE0 /* A   */.3
   \   000069   5006         JNC     ??mpu_read_fifo_7
   1836                  packet_size += 6;
   \   00006B   7406         MOV     A,#0x6
   \   00006D   25..         ADD     A,?V0 + 2
   \   00006F   F5..         MOV     ?V0 + 2,A
   1837          
   1838              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \                     ??mpu_read_fifo_7:
   \   000071                ; Setup parameters for call to function I2C_Read
   \   000071   85..82       MOV     DPL,?XSP + 0
   \   000074   85..83       MOV     DPH,?XSP + 1
   \   000077   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00007A   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   00007D   70B4         JNZ     ??mpu_read_fifo_1
   1839                  return -1;
   1840              fifo_count = (data[0] << 8) | data[1];
   \   00007F   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   E0           MOVX    A,@DPTR
   \   000086   FA           MOV     R2,A
   \   000087   F5..         MOV     ?V0 + 0,A
   \   000089   E9           MOV     A,R1
   \   00008A   F5..         MOV     ?V0 + 1,A
   1841              if (fifo_count < packet_size)
   \   00008C   85..82       MOV     DPL,?V0 + 2
   \   00008F   8582..       MOV     ?V0 + 6,DPL
   \   000092   C3           CLR     C
   \   000093   EA           MOV     A,R2
   \   000094   95..         SUBB    A,?V0 + 6
   \   000096   E9           MOV     A,R1
   \   000097   9400         SUBB    A,#0x0
   \   000099   5006         JNC     ??mpu_read_fifo_8
   1842                  return 0;
   \                     ??mpu_read_fifo_9:
   \   00009B   7A00         MOV     R2,#0x0
   \   00009D   7B00         MOV     R3,#0x0
   \   00009F   8096         SJMP    ??mpu_read_fifo_3
   1843          //    log_i("FIFO count: %hd\n", fifo_count);
   1844              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_8:
   \   0000A1   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   0000A4   95..         SUBB    A,?V0 + 0
   \   0000A6   EB           MOV     A,R3
   \   0000A7   95..         SUBB    A,?V0 + 1
   \   0000A9   503B         JNC     ??mpu_read_fifo_10
   1845                  /* FIFO is 50% full, better check overflow bit. */
   1846                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
   \   0000AB                ; Setup parameters for call to function I2C_Read
   \   0000AB   85..82       MOV     DPL,?XSP + 0
   \   0000AE   85..83       MOV     DPH,?XSP + 1
   \   0000B1   AC82         MOV     R4,DPL
   \   0000B3   AD83         MOV     R5,DPH
   \   0000B5   7B01         MOV     R3,#0x1
   \   0000B7   90....       MOV     DPTR,#st
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   2411         ADD     A,#0x11
   \   0000BD   F5..         MOV     ?V0 + 12,A
   \   0000BF   A3           INC     DPTR
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   3400         ADDC    A,#0x0
   \   0000C3   85..82       MOV     DPL,?V0 + 12
   \   0000C6   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0000C9   8B..         MOV     ?V0 + 13,R3
   \   0000CB   EA           MOV     A,R2
   \   0000CC   45..         ORL     A,?V0 + 13
   \   0000CE   6003         JZ      $+5
   \   0000D0   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1847                      return -1;
   1848                  if (data[0] & BIT_FIFO_OVERFLOW) {
   \   0000D3   85..82       MOV     DPL,?XSP + 0
   \   0000D6   85..83       MOV     DPH,?XSP + 1
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000DC   5008         JNC     ??mpu_read_fifo_10
   1849                      mpu_reset_fifo();
   \   0000DE                ; Setup parameters for call to function mpu_reset_fifo
   \   0000DE   12....       LCALL   ??mpu_reset_fifo?relay
   1850                      return -2;
   \   0000E1   7AFE         MOV     R2,#-0x2
   \   0000E3   02....       LJMP    ??mpu_read_fifo_2 & 0xFFFF
   1851                  }
   1852              }
   1853              get_ms((unsigned long*)timestamp);
   1854          
   1855              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
   \                     ??mpu_read_fifo_10:
   \   0000E6                ; Setup parameters for call to function I2C_Read
   \   0000E6   85..82       MOV     DPL,?XSP + 0
   \   0000E9   85..83       MOV     DPH,?XSP + 1
   \   0000EC   AC82         MOV     R4,DPL
   \   0000EE   AD83         MOV     R5,DPH
   \   0000F0   AB..         MOV     R3,?V0 + 2
   \   0000F2   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   0000F5   8B..         MOV     ?V0 + 13,R3
   \   0000F7   EA           MOV     A,R2
   \   0000F8   45..         ORL     A,?V0 + 13
   \   0000FA   6003         JZ      $+5
   \   0000FC   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1856                  return -1;
   1857              more[0] = fifo_count / packet_size - 1;
   \   0000FF   A8..         MOV     R0,?V0 + 0
   \   000101   A9..         MOV     R1,?V0 + 1
   \   000103   AA..         MOV     R2,?V0 + 6
   \   000105   7B00         MOV     R3,#0x0
   \   000107   12....       LCALL   ?US_DIV_MOD
   \   00010A   E8           MOV     A,R0
   \   00010B   14           DEC     A
   \   00010C   85..82       MOV     DPL,?V0 + 14
   \   00010F   85..83       MOV     DPH,?V0 + 15
   \   000112   F0           MOVX    @DPTR,A
   1858              sensors[0] = 0;
   \   000113   85..82       MOV     DPL,?V0 + 4
   \   000116   85..83       MOV     DPH,?V0 + 5
   \   000119   E4           CLR     A
   \   00011A   F0           MOVX    @DPTR,A
   1859          
   1860              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
   \   00011B   E5..         MOV     A,?V0 + 2
   \   00011D   7003         JNZ     $+5
   \   00011F   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \   000122   90....       MOV     DPTR,#st + 11
   \   000125   E0           MOVX    A,@DPTR
   \   000126   A2E3         MOV     C,0xE0 /* A   */.3
   \   000128   5041         JNC     ??mpu_read_fifo_11
   1861                  accel[0] = (data[index+0] << 8) | data[index+1];
   \   00012A   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   00012D   12....       LCALL   ?XSTACK_DISP0_8
   \   000130   E0           MOVX    A,@DPTR
   \   000131   85..82       MOV     DPL,?V0 + 8
   \   000134   85..83       MOV     DPH,?V0 + 9
   \   000137   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1862                  accel[1] = (data[index+2] << 8) | data[index+3];
   \                     ??CrossCallReturnLabel_157:
   \   00013A   7402         MOV     A,#0x2
   \   00013C   12....       LCALL   ?XSTACK_DISP0_8
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   F9           MOV     R1,A
   \   000141   7403         MOV     A,#0x3
   \   000143   12....       LCALL   ?XSTACK_DISP0_8
   \   000146   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000149   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   1863                  accel[2] = (data[index+4] << 8) | data[index+5];
   \                     ??CrossCallReturnLabel_158:
   \   00014C   7404         MOV     A,#0x4
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   E0           MOVX    A,@DPTR
   \   000152   F9           MOV     R1,A
   \   000153   7405         MOV     A,#0x5
   \   000155   12....       LCALL   ?XSTACK_DISP0_8
   \   000158   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   00015B   12....       LCALL   ?Subroutine59 & 0xFFFF
   1864                  sensors[0] |= INV_XYZ_ACCEL;
   \                     ??CrossCallReturnLabel_179:
   \   00015E   D2E3         SETB    0xE0 /* A   */.3
   \   000160   F0           MOVX    @DPTR,A
   1865                  index += 6;
   \   000161   7E06         MOV     R6,#0x6
   1866              }
   1867              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
   \   000163   EE           MOV     A,R6
   \   000164   65..         XRL     A,?V0 + 2
   \   000166   7003         JNZ     $+5
   \   000168   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \                     ??mpu_read_fifo_11:
   \   00016B   90....       MOV     DPTR,#st + 11
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   A2E6         MOV     C,0xE0 /* A   */.6
   \   000171   5021         JNC     ??mpu_read_fifo_12
   1868                  gyro[0] = (data[index+0] << 8) | data[index+1];
   \   000173   85..82       MOV     DPL,?XSP + 0
   \   000176   85..83       MOV     DPH,?XSP + 1
   \   000179   E582         MOV     A,DPL
   \   00017B   2E           ADD     A,R6
   \   00017C   F582         MOV     DPL,A
   \   00017E   E583         MOV     A,DPH
   \   000180   3400         ADDC    A,#0x0
   \   000182   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000185   12....       LCALL   ??Subroutine115_0 & 0xFFFF
   1869                  sensors[0] |= INV_X_GYRO;
   \                     ??CrossCallReturnLabel_181:
   \   000188   D2E6         SETB    0xE0 /* A   */.6
   \   00018A   F0           MOVX    @DPTR,A
   1870                  index += 2;
   \   00018B   EE           MOV     A,R6
   \   00018C   2402         ADD     A,#0x2
   \   00018E   0E           INC     R6
   \   00018F   0E           INC     R6
   \   000190   E4           CLR     A
   \   000191   3400         ADDC    A,#0x0
   \   000193   FF           MOV     R7,A
   1871              }
   1872              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
   \                     ??mpu_read_fifo_12:
   \   000194   EE           MOV     A,R6
   \   000195   65..         XRL     A,?V0 + 2
   \   000197   601A         JZ      ??mpu_read_fifo_13
   \   000199   90....       MOV     DPTR,#st + 11
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   A2E5         MOV     C,0xE0 /* A   */.5
   \   00019F   5012         JNC     ??mpu_read_fifo_13
   1873                  gyro[1] = (data[index+0] << 8) | data[index+1];
   \   0001A1   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0001A4   12....       LCALL   ??Subroutine115_0 & 0xFFFF
   1874                  sensors[0] |= INV_Y_GYRO;
   \                     ??CrossCallReturnLabel_182:
   \   0001A7   D2E5         SETB    0xE0 /* A   */.5
   \   0001A9   F0           MOVX    @DPTR,A
   1875                  index += 2;
   \   0001AA   EE           MOV     A,R6
   \   0001AB   2402         ADD     A,#0x2
   \   0001AD   0E           INC     R6
   \   0001AE   0E           INC     R6
   \   0001AF   EF           MOV     A,R7
   \   0001B0   3400         ADDC    A,#0x0
   \   0001B2   FF           MOV     R7,A
   1876              }
   1877              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
   \                     ??mpu_read_fifo_13:
   \   0001B3   EE           MOV     A,R6
   \   0001B4   65..         XRL     A,?V0 + 2
   \   0001B6   7003         JNZ     $+5
   \   0001B8   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \   0001BB   90....       MOV     DPTR,#st + 11
   \   0001BE   E0           MOVX    A,@DPTR
   \   0001BF   A2E4         MOV     C,0xE0 /* A   */.4
   \   0001C1   4003         JC      $+5
   \   0001C3   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1878                  gyro[2] = (data[index+0] << 8) | data[index+1];
   \   0001C6   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0001C9   12....       LCALL   ?Subroutine59 & 0xFFFF
   1879                  sensors[0] |= INV_Z_GYRO;
   \                     ??CrossCallReturnLabel_180:
   \   0001CC   D2E4         SETB    0xE0 /* A   */.4
   \   0001CE   F0           MOVX    @DPTR,A
   1880                  index += 2;
   \   0001CF   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1881              }
   1882          
   1883              return 0;
   1884          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine115_0
   \   000002                ; // Fall through to label ??Subroutine115_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   85..82       MOV     DPL,?V0 + 4
   \   000007   85..83       MOV     DPH,?V0 + 5
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0 + 8
   \   000004   85..83       MOV     DPH,?V0 + 9
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   2E           ADD     A,R6
   \   000009   F582         MOV     DPL,A
   \   00000B   E583         MOV     A,DPH
   \   00000D   3F           ADDC    A,R7
   \   00000E   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   F583         MOV     DPH,A
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   85..82       MOV     DPL,?V0 + 10
   \   000009   85..83       MOV     DPH,?V0 + 11
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000003   12....       LCALL   ??I2C_Read?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000003   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000006   C3           CLR     C
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   90....       MOV     DPTR,#st
   \   000003   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000006   FA           MOV     R2,A
   \   000007   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B02         MOV     R3,#0x2
   \   000006   90....       MOV     DPTR,#st
   \   000009   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   F583         MOV     DPH,A
   \   000002   E0           MOVX    A,@DPTR
   \   000003   FA           MOV     R2,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F9           MOV     R1,A
   \   00000A   22           RET
   1885          
   1886          /**
   1887           *  @brief      Get one unparsed packet from the FIFO.
   1888           *  This function should be used if the packet is to be parsed elsewhere.
   1889           *  @param[in]  length  Length of one FIFO packet.
   1890           *  @param[in]  data    FIFO packet.
   1891           *  @param[in]  more    Number of remaining packets.
   1892           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1893          int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
   \                     mpu_read_fifo_stream:
   1894              unsigned char *more)
   1895          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 3,A
   1896              unsigned char tmp[2];
   1897              unsigned short fifo_count;
   1898              if (!st.chip_cfg.dmp_on)
   \   00001E   90....       MOV     DPTR,#st + 29
   \   000021   E0           MOVX    A,@DPTR
   \   000022   7007         JNZ     ??mpu_read_fifo_stream_0
   1899                  return -1;
   \                     ??mpu_read_fifo_stream_1:
   \   000024   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_stream_2:
   \   000026   7BFF         MOV     R3,#-0x1
   \   000028   02....       LJMP    ??CrossCallReturnLabel_249 & 0xFFFF
   1900              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_fifo_stream_0:
   \   00002B   90....       MOV     DPTR,#st + 6
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   60F3         JZ      ??mpu_read_fifo_stream_1
   1901                  return -1;
   1902          
   1903              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
   \   000031                ; Setup parameters for call to function I2C_Read
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   AC82         MOV     R4,DPL
   \   000039   AD83         MOV     R5,DPH
   \   00003B   7B02         MOV     R3,#0x2
   \   00003D   90....       MOV     DPTR,#st
   \   000040   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000043   FA           MOV     R2,A
   \   000044   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000047   8B..         MOV     ?V0 + 7,R3
   \   000049   EA           MOV     A,R2
   \   00004A   45..         ORL     A,?V0 + 7
   \   00004C   70D6         JNZ     ??mpu_read_fifo_stream_1
   1904                  return -1;
   1905              fifo_count = (tmp[0] << 8) | tmp[1];
   \   00004E   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FE           MOV     R6,A
   \   000056   E9           MOV     A,R1
   \   000057   FF           MOV     R7,A
   1906              if (fifo_count < length) {
   \   000058   C3           CLR     C
   \   000059   EE           MOV     A,R6
   \   00005A   95..         SUBB    A,?V0 + 0
   \   00005C   EF           MOV     A,R7
   \   00005D   95..         SUBB    A,?V0 + 1
   \   00005F   500A         JNC     ??mpu_read_fifo_stream_3
   1907                  more[0] = 0;
   \   000061   85..82       MOV     DPL,?V0 + 2
   \   000064   85..83       MOV     DPH,?V0 + 3
   \   000067   E4           CLR     A
   \   000068   F0           MOVX    @DPTR,A
   \   000069   80B9         SJMP    ??mpu_read_fifo_stream_1
   1908                  return -1;
   1909              }
   1910              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_stream_3:
   \   00006B   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   00006E   9E           SUBB    A,R6
   \   00006F   EB           MOV     A,R3
   \   000070   9F           SUBB    A,R7
   \   000071   5038         JNC     ??mpu_read_fifo_stream_4
   1911                  /* FIFO is 50% full, better check overflow bit. */
   1912                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
   \   000073                ; Setup parameters for call to function I2C_Read
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   AC82         MOV     R4,DPL
   \   00007B   AD83         MOV     R5,DPH
   \   00007D   7B01         MOV     R3,#0x1
   \   00007F   90....       MOV     DPTR,#st
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2411         ADD     A,#0x11
   \   000085   F5..         MOV     ?V0 + 6,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   3400         ADDC    A,#0x0
   \   00008B   85..82       MOV     DPL,?V0 + 6
   \   00008E   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000091   8B..         MOV     ?V0 + 7,R3
   \   000093   EA           MOV     A,R2
   \   000094   45..         ORL     A,?V0 + 7
   \   000096   708C         JNZ     ??mpu_read_fifo_stream_1
   1913                      return -1;
   1914                  if (tmp[0] & BIT_FIFO_OVERFLOW) {
   \   000098   85..82       MOV     DPL,?XSP + 0
   \   00009B   85..83       MOV     DPH,?XSP + 1
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000A1   5008         JNC     ??mpu_read_fifo_stream_4
   1915                      mpu_reset_fifo();
   \   0000A3                ; Setup parameters for call to function mpu_reset_fifo
   \   0000A3   12....       LCALL   ??mpu_reset_fifo?relay
   1916                      return -2;
   \   0000A6   7AFE         MOV     R2,#-0x2
   \   0000A8   02....       LJMP    ??mpu_read_fifo_stream_2 & 0xFFFF
   1917                  }
   1918              }
   1919          
   1920              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
   \                     ??mpu_read_fifo_stream_4:
   \   0000AB                ; Setup parameters for call to function I2C_Read
   \   0000AB   AC..         MOV     R4,?V0 + 4
   \   0000AD   AD..         MOV     R5,?V0 + 5
   \   0000AF   AB..         MOV     R3,?V0 + 0
   \   0000B1   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000B4   8B..         MOV     ?V0 + 5,R3
   \   0000B6   EA           MOV     A,R2
   \   0000B7   45..         ORL     A,?V0 + 5
   \   0000B9   6003         JZ      $+5
   \   0000BB   02....       LJMP    ??mpu_read_fifo_stream_1 & 0xFFFF
   1921                  return -1;
   1922              more[0] = fifo_count / length - 1;
   \   0000BE   EE           MOV     A,R6
   \   0000BF   F8           MOV     R0,A
   \   0000C0   EF           MOV     A,R7
   \   0000C1   F9           MOV     R1,A
   \   0000C2   AA..         MOV     R2,?V0 + 0
   \   0000C4   AB..         MOV     R3,?V0 + 1
   \   0000C6   12....       LCALL   ?US_DIV_MOD
   \   0000C9   E8           MOV     A,R0
   \   0000CA   14           DEC     A
   \   0000CB   85..82       MOV     DPL,?V0 + 2
   \   0000CE   85..83       MOV     DPH,?V0 + 3
   \   0000D1   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   1923              return 0;
   \                     ??CrossCallReturnLabel_249:
   \   0000D4   02....       LJMP    ?Subroutine0 & 0xFFFF
   1924          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET
   1925          
   1926          /**
   1927           *  @brief      Set device to bypass mode.
   1928           *  @param[in]  bypass_on   1 to enable bypass mode.
   1929           *  @return     0 if successful.
   1930           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1931          int mpu_set_bypass(unsigned char bypass_on)
   \                     mpu_set_bypass:
   1932          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1933              unsigned char tmp;
   1934          
   1935              if (st.chip_cfg.bypass_mode == bypass_on)
   \   00000C   90....       MOV     DPTR,#st + 13
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   7003         JNZ     $+5
   \   000013   02....       LJMP    ??mpu_set_bypass_0 & 0xFFFF
   1936                  return 0;
   1937          
   1938              if (bypass_on) {
   \   000016   90....       MOV     DPTR,#st + 2
   \   000019   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F9           MOV     R1,A
   \   00001E   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FA           MOV     R2,A
   \   000023   EE           MOV     A,R6
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   AC82         MOV     R4,DPL
   \   00002C   AD83         MOV     R5,DPH
   \   00002E   7B01         MOV     R3,#0x1
   \   000030   605D         JZ      ??mpu_set_bypass_1
   1939                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   000032                ; Setup parameters for call to function I2C_Read
   \   000032   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000035   6007         JZ      ??mpu_set_bypass_2
   1940                      return -1;
   \                     ??mpu_set_bypass_3:
   \   000037   7AFF         MOV     R2,#-0x1
   \   000039   7BFF         MOV     R3,#-0x1
   \   00003B   02....       LJMP    ??mpu_set_bypass_4 & 0xFFFF
   1941                  tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_2:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E0           MOVX    A,@DPTR
   \   000045   C2E5         CLR     0xE0 /* A   */.5
   \   000047   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   1942                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??CrossCallReturnLabel_169:
   \   00004A   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   00004D   70E8         JNZ     ??mpu_set_bypass_3
   1943                      return -1;
   1944                  delay_ms(3);
   \   00004F                ; Setup parameters for call to function delay_ms
   \   00004F   7A03         MOV     R2,#0x3
   \   000051   12....       LCALL   ?Subroutine66 & 0xFFFF
   1945                  tmp = BIT_BYPASS_EN;
   \                     ??CrossCallReturnLabel_105:
   \   000054   7402         MOV     A,#0x2
   \   000056   F0           MOVX    @DPTR,A
   1946                  if (st.chip_cfg.active_low_int)
   \   000057   90....       MOV     DPTR,#st + 27
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6009         JZ      ??mpu_set_bypass_5
   1947                      tmp |= BIT_ACTL;
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   7482         MOV     A,#-0x7e
   \   000065   F0           MOVX    @DPTR,A
   1948                  if (st.chip_cfg.latched_int)
   \                     ??mpu_set_bypass_5:
   \   000066   90....       MOV     DPTR,#st + 28
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   600A         JZ      ??mpu_set_bypass_6
   1949                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00006C   85..82       MOV     DPL,?XSP + 0
   \   00006F   85..83       MOV     DPH,?XSP + 1
   \   000072   E0           MOVX    A,@DPTR
   \   000073   4430         ORL     A,#0x30
   \   000075   F0           MOVX    @DPTR,A
   1950                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_6:
   \   000076                ; Setup parameters for call to function I2C_Write
   \   000076   85..82       MOV     DPL,?XSP + 0
   \   000079   85..83       MOV     DPH,?XSP + 1
   \   00007C   AC82         MOV     R4,DPL
   \   00007E   AD83         MOV     R5,DPH
   \   000080   7B01         MOV     R3,#0x1
   \   000082   90....       MOV     DPTR,#st
   \   000085   E0           MOVX    A,@DPTR
   \   000086   2414         ADD     A,#0x14
   \   000088   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   1951                      return -1;
   1952              } else {
   \                     ??CrossCallReturnLabel_286:
   \   00008B   70AA         JNZ     ??mpu_set_bypass_3
   \   00008D   8061         SJMP    ??mpu_set_bypass_7
   1953                  /* Enable I2C master mode if compass is being used. */
   1954                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??mpu_set_bypass_1:
   \   00008F                ; Setup parameters for call to function I2C_Read
   \   00008F   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000092   70A3         JNZ     ??mpu_set_bypass_3
   1955                      return -1;
   1956                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   000094   90....       MOV     DPTR,#st + 6
   \   000097   E0           MOVX    A,@DPTR
   \   000098   A2E0         MOV     C,0xE0 /* A   */.0
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   5004         JNC     ??mpu_set_bypass_8
   1957                      tmp |= BIT_AUX_IF_EN;
   \   0000A3   D2E5         SETB    0xE0 /* A   */.5
   \   0000A5   8002         SJMP    ??mpu_set_bypass_9
   1958                  else
   1959                      tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_8:
   \   0000A7   C2E5         CLR     0xE0 /* A   */.5
   \                     ??mpu_set_bypass_9:
   \   0000A9   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   1960                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??CrossCallReturnLabel_170:
   \   0000AC   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   0000AF   7086         JNZ     ??mpu_set_bypass_3
   1961                      return -1;
   1962                  delay_ms(3);
   \   0000B1                ; Setup parameters for call to function delay_ms
   \   0000B1   7A03         MOV     R2,#0x3
   \   0000B3   7B00         MOV     R3,#0x0
   \   0000B5   12....       LCALL   ??delay_ms?relay
   1963                  if (st.chip_cfg.active_low_int)
   \   0000B8   90....       MOV     DPTR,#st + 27
   \   0000BB   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   0000BE   6004         JZ      ??mpu_set_bypass_10
   1964                      tmp = BIT_ACTL;
   \   0000C0   7480         MOV     A,#-0x80
   \   0000C2   8001         SJMP    ??mpu_set_bypass_11
   1965                  else
   1966                      tmp = 0;
   \                     ??mpu_set_bypass_10:
   \   0000C4   E4           CLR     A
   \                     ??mpu_set_bypass_11:
   \   0000C5   F0           MOVX    @DPTR,A
   1967                  if (st.chip_cfg.latched_int)
   \   0000C6   90....       MOV     DPTR,#st + 28
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   600A         JZ      ??mpu_set_bypass_12
   1968                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   0000CC   85..82       MOV     DPL,?XSP + 0
   \   0000CF   85..83       MOV     DPH,?XSP + 1
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   4430         ORL     A,#0x30
   \   0000D5   F0           MOVX    @DPTR,A
   1969                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_12:
   \   0000D6                ; Setup parameters for call to function I2C_Write
   \   0000D6   85..82       MOV     DPL,?XSP + 0
   \   0000D9   85..83       MOV     DPH,?XSP + 1
   \   0000DC   AC82         MOV     R4,DPL
   \   0000DE   AD83         MOV     R5,DPH
   \   0000E0   7B01         MOV     R3,#0x1
   \   0000E2   90....       MOV     DPTR,#st
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   2414         ADD     A,#0x14
   \   0000E8   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   1970                      return -1;
   1971              }
   \                     ??CrossCallReturnLabel_287:
   \   0000EB   6003         JZ      $+5
   \   0000ED   02....       LJMP    ??mpu_set_bypass_3 & 0xFFFF
   1972              st.chip_cfg.bypass_mode = bypass_on;
   \                     ??mpu_set_bypass_7:
   \   0000F0   EE           MOV     A,R6
   \   0000F1   90....       MOV     DPTR,#st + 13
   \   0000F4   F0           MOVX    @DPTR,A
   1973              return 0;
   \                     ??mpu_set_bypass_0:
   \   0000F5   7A00         MOV     R2,#0x0
   \   0000F7   7B00         MOV     R3,#0x0
   \                     ??mpu_set_bypass_4:
   \   0000F9   02....       LJMP    ?Subroutine3 & 0xFFFF
   1974          }
   1975          
   1976          /**
   1977           *  @brief      Set interrupt level.
   1978           *  @param[in]  active_low  1 for active low, 0 for active high.
   1979           *  @return     0 if successful.
   1980           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1981          int mpu_set_int_level(unsigned char active_low)
   \                     mpu_set_int_level:
   1982          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1983              st.chip_cfg.active_low_int = active_low;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#st + 27
   \   000008   02....       LJMP    ??Subroutine111_0 & 0xFFFF
   1984              return 0;
   1985          }
   1986          
   1987          /**
   1988           *  @brief      Enable latched interrupts.
   1989           *  Any MPU register will clear the interrupt.
   1990           *  @param[in]  enable  1 to enable, 0 to disable.
   1991           *  @return     0 if successful.
   1992           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1993          int mpu_set_int_latched(unsigned char enable)
   \                     mpu_set_int_latched:
   1994          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1995              unsigned char tmp;
   1996              if (st.chip_cfg.latched_int == enable)
   \   00000C   90....       MOV     DPTR,#st + 28
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   6051         JZ      ??mpu_set_int_latched_0
   1997                  return 0;
   1998          
   1999              if (enable)
   \   000013   EE           MOV     A,R6
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   6004         JZ      ??mpu_set_int_latched_1
   2000                  tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00001C   7430         MOV     A,#0x30
   \   00001E   8001         SJMP    ??mpu_set_int_latched_2
   2001              else
   2002                  tmp = 0;
   \                     ??mpu_set_int_latched_1:
   \   000020   E4           CLR     A
   \                     ??mpu_set_int_latched_2:
   \   000021   F0           MOVX    @DPTR,A
   2003              if (st.chip_cfg.bypass_mode)
   \   000022   90....       MOV     DPTR,#st + 13
   \   000025   E0           MOVX    A,@DPTR
   \   000026   600A         JZ      ??mpu_set_int_latched_3
   2004                  tmp |= BIT_BYPASS_EN;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   D2E1         SETB    0xE0 /* A   */.1
   \   000031   F0           MOVX    @DPTR,A
   2005              if (st.chip_cfg.active_low_int)
   \                     ??mpu_set_int_latched_3:
   \   000032   90....       MOV     DPTR,#st + 27
   \   000035   E0           MOVX    A,@DPTR
   \   000036   600A         JZ      ??mpu_set_int_latched_4
   2006                  tmp |= BIT_ACTL;
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   D2E7         SETB    0xE0 /* A   */.7
   \   000041   F0           MOVX    @DPTR,A
   2007              if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_int_latched_4:
   \   000042                ; Setup parameters for call to function I2C_Write
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   AC82         MOV     R4,DPL
   \   00004A   AD83         MOV     R5,DPH
   \   00004C   7B01         MOV     R3,#0x1
   \   00004E   90....       MOV     DPTR,#st
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2414         ADD     A,#0x14
   \   000054   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   000057   6006         JZ      ??mpu_set_int_latched_5
   2008                  return -1;
   \   000059   7AFF         MOV     R2,#-0x1
   \   00005B   7BFF         MOV     R3,#-0x1
   \   00005D   8009         SJMP    ??mpu_set_int_latched_6
   2009              st.chip_cfg.latched_int = enable;
   \                     ??mpu_set_int_latched_5:
   \   00005F   EE           MOV     A,R6
   \   000060   90....       MOV     DPTR,#st + 28
   \   000063   F0           MOVX    @DPTR,A
   2010              return 0;
   \                     ??mpu_set_int_latched_0:
   \   000064   7A00         MOV     R2,#0x0
   \   000066   7B00         MOV     R3,#0x0
   \                     ??mpu_set_int_latched_6:
   \   000068   02....       LJMP    ?Subroutine3 & 0xFFFF
   2011          }
   2012          
   2013          #ifdef MPU6050

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2014          static int get_accel_prod_shift(float *st_shift)
   \                     get_accel_prod_shift:
   2015          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 12,R2
   \   00000C   8B..         MOV     ?V0 + 13,R3
   2016              unsigned char tmp[4], shift_code[3], ii;
   2017          
   2018              if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
   \   00000E                ; Setup parameters for call to function I2C_Read
   \   00000E   7403         MOV     A,#0x3
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   7B04         MOV     R3,#0x4
   \   000019   7A0D         MOV     R2,#0xd
   \   00001B   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   00001E   6005         JZ      ??get_accel_prod_shift_0
   2019                  return 0x07;
   \   000020   7A07         MOV     R2,#0x7
   \   000022   02....       LJMP    ??get_accel_prod_shift_1 & 0xFFFF
   2020          
   2021              shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
   \                     ??get_accel_prod_shift_0:
   \   000025   7406         MOV     A,#0x6
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   C4           SWAP    A
   \   00002D   540F         ANL     A,#0xf
   \   00002F   5403         ANL     A,#0x3
   \   000031   F8           MOV     R0,A
   \   000032   7403         MOV     A,#0x3
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   F0           MOVX    @DPTR,A
   2022              shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
   \   000041   E9           MOV     A,R1
   \   000042   13           RRC     A
   \   000043   13           RRC     A
   \   000044   543F         ANL     A,#0x3f
   \   000046   5403         ANL     A,#0x3
   \   000048   F8           MOV     R0,A
   \   000049   7404         MOV     A,#0x4
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000051   C0E0         PUSH    A
   \   000053   7401         MOV     A,#0x1
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   D0E0         POP     A
   \   00005A   F0           MOVX    @DPTR,A
   2023              shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
   \   00005B   7403         MOV     A,#0x3
   \   00005D   59           ANL     A,R1
   \   00005E   F8           MOV     R0,A
   \   00005F   7405         MOV     A,#0x5
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000067   C0E0         PUSH    A
   \   000069   7402         MOV     A,#0x2
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   D0E0         POP     A
   \   000070   F0           MOVX    @DPTR,A
   2024              for (ii = 0; ii < 3; ii++) {
   \   000071   7E00         MOV     R6,#0x0
   2025                  if (!shift_code[ii]) {
   \                     ??get_accel_prod_shift_2:
   \   000073   8E82         MOV     DPL,R6
   \   000075   AA82         MOV     R2,DPL
   \   000077   8A..         MOV     ?V0 + 0,R2
   \   000079   75..00       MOV     ?V0 + 1,#0x0
   \   00007C   7402         MOV     A,#0x2
   \   00007E   78..         MOV     R0,#?V0 + 0
   \   000080   12....       LCALL   ?S_SHL
   \   000083   E5..         MOV     A,?V0 + 12
   \   000085   25..         ADD     A,?V0 + 0
   \   000087   F5..         MOV     ?V0 + 4,A
   \   000089   E5..         MOV     A,?V0 + 13
   \   00008B   35..         ADDC    A,?V0 + 1
   \   00008D   F5..         MOV     ?V0 + 5,A
   \   00008F   85..82       MOV     DPL,?XSP + 0
   \   000092   85..83       MOV     DPH,?XSP + 1
   \   000095   E582         MOV     A,DPL
   \   000097   2A           ADD     A,R2
   \   000098   F5..         MOV     ?V0 + 6,A
   \   00009A   E583         MOV     A,DPH
   \   00009C   3400         ADDC    A,#0x0
   \   00009E   F5..         MOV     ?V0 + 7,A
   \   0000A0   85..82       MOV     DPL,?V0 + 6
   \   0000A3   F583         MOV     DPH,A
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   7011         JNZ     ??get_accel_prod_shift_3
   2026                      st_shift[ii] = 0.f;
   \   0000A8   90....       MOV     DPTR,#__Constant_0
   \   0000AB   12....       LCALL   ?XLOAD_R2345
   \   0000AE   85..82       MOV     DPL,?V0 + 4
   \   0000B1   85..83       MOV     DPH,?V0 + 5
   \   0000B4   12....       LCALL   ?XSTORE_R2345
   2027                      continue;
   \   0000B7   8041         SJMP    ??get_accel_prod_shift_4
   2028                  }
   2029                  /* Equivalent to..
   2030                   * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
   2031                   */
   2032                  st_shift[ii] = 0.34f;
   \                     ??get_accel_prod_shift_3:
   \   0000B9   90....       MOV     DPTR,#__Constant_3eae147b
   \   0000BC   12....       LCALL   ?XLOAD_R2345
   \   0000BF   85..82       MOV     DPL,?V0 + 4
   \   0000C2   85..83       MOV     DPH,?V0 + 5
   \   0000C5   12....       LCALL   ?XSTORE_R2345
   \   0000C8   8025         SJMP    ??get_accel_prod_shift_5
   2033                  while (--shift_code[ii])
   2034                      st_shift[ii] *= 1.034f;
   \                     ??get_accel_prod_shift_6:
   \   0000CA   85..82       MOV     DPL,?V0 + 4
   \   0000CD   85..83       MOV     DPH,?V0 + 5
   \   0000D0   78..         MOV     R0,#?V0 + 0
   \   0000D2   12....       LCALL   ?L_MOV_X
   \   0000D5   90....       MOV     DPTR,#__Constant_3f845a1d
   \   0000D8   78..         MOV     R0,#?V0 + 8
   \   0000DA   12....       LCALL   ?L_MOV_X
   \   0000DD   78..         MOV     R0,#?V0 + 0
   \   0000DF   79..         MOV     R1,#?V0 + 8
   \   0000E1   12....       LCALL   ?FLT_MUL
   \   0000E4   85..82       MOV     DPL,?V0 + 4
   \   0000E7   85..83       MOV     DPH,?V0 + 5
   \   0000EA   78..         MOV     R0,#?V0 + 0
   \   0000EC   12....       LCALL   ?L_MOV_TO_X
   \                     ??get_accel_prod_shift_5:
   \   0000EF   85..82       MOV     DPL,?V0 + 6
   \   0000F2   85..83       MOV     DPH,?V0 + 7
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   14           DEC     A
   \   0000F7   F0           MOVX    @DPTR,A
   \   0000F8   70D0         JNZ     ??get_accel_prod_shift_6
   2035              }
   \                     ??get_accel_prod_shift_4:
   \   0000FA   0E           INC     R6
   \   0000FB   EE           MOV     A,R6
   \   0000FC   C3           CLR     C
   \   0000FD   9403         SUBB    A,#0x3
   \   0000FF   5003         JNC     $+5
   \   000101   02....       LJMP    ??get_accel_prod_shift_2 & 0xFFFF
   2036              return 0;
   \   000104   7A00         MOV     R2,#0x0
   \                     ??get_accel_prod_shift_1:
   \   000106   7B00         MOV     R3,#0x0
   \   000108   7407         MOV     A,#0x7
   \   00010A                REQUIRE ?Subroutine7
   \   00010A                ; // Fall through to label ?Subroutine7
   2037          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F0E         MOV     R7,#0xe
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000003   541C         ANL     A,#0x1c
   \   000005   48           ORL     A,R0
   \   000006   22           RET
   2038          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2039          static int accel_self_test(long *bias_regular, long *bias_st)
   \                     accel_self_test:
   2040          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   12....       LCALL   ?Subroutine62 & 0xFFFF
   2041              int jj, result = 0;
   2042              float st_shift[3], st_shift_cust, st_shift_var;
   2043          
   2044              get_accel_prod_shift(st_shift);
   \                     ??CrossCallReturnLabel_98:
   \   000013                ; Setup parameters for call to function get_accel_prod_shift
   \   000013   7402         MOV     A,#0x2
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??get_accel_prod_shift?relay
   2045              for(jj = 0; jj < 3; jj++) {
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   2046                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \                     ??accel_self_test_0:
   \   000023   8E..         MOV     ?V0 + 2,R6
   \   000025   8F..         MOV     ?V0 + 3,R7
   \   000027   7402         MOV     A,#0x2
   \   000029   78..         MOV     R0,#?V0 + 2
   \   00002B   12....       LCALL   ?S_SHL
   \   00002E   85....       MOV     ?V0 + 0,?V0 + 2
   \   000031   85....       MOV     ?V0 + 1,?V0 + 3
   \   000034                ; Setup parameters for call to function labs
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   25..         ADD     A,?V0 + 0
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   35..         ADDC    A,?V0 + 1
   \   000042   8882         MOV     DPL,R0
   \   000044   F583         MOV     DPH,A
   \   000046   78..         MOV     R0,#?V0 + 4
   \   000048   12....       LCALL   ?L_MOV_X
   \   00004B   E5..         MOV     A,?V0 + 14
   \   00004D   25..         ADD     A,?V0 + 0
   \   00004F   F582         MOV     DPL,A
   \   000051   E5..         MOV     A,?V0 + 15
   \   000053   35..         ADDC    A,?V0 + 1
   \   000055   F583         MOV     DPH,A
   \   000057   78..         MOV     R0,#?V0 + 4
   \   000059   12....       LCALL   ?L_SUB_X
   \   00005C   AA..         MOV     R2,?V0 + 4
   \   00005E   AB..         MOV     R3,?V0 + 5
   \   000060   AC..         MOV     R4,?V0 + 6
   \   000062   AD..         MOV     R5,?V0 + 7
   \   000064   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000067   12....       LCALL   ?L_TO_FLT
   \   00006A   90....       MOV     DPTR,#__Constant_37800000
   \   00006D   78..         MOV     R0,#?V0 + 8
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 4
   \   000074   79..         MOV     R1,#?V0 + 8
   \   000076   12....       LCALL   ?FLT_MUL
   2047                  if (st_shift[jj]) {
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   E582         MOV     A,DPL
   \   000080   25..         ADD     A,?V0 + 0
   \   000082   F582         MOV     DPL,A
   \   000084   E583         MOV     A,DPH
   \   000086   35..         ADDC    A,?V0 + 1
   \   000088   F583         MOV     DPH,A
   \   00008A   78..         MOV     R0,#?V0 + 0
   \   00008C   12....       LCALL   ?L_MOV_X
   \   00008F   90....       MOV     DPTR,#__Constant_0
   \   000092   78..         MOV     R0,#?V0 + 8
   \   000094   12....       LCALL   ?L_MOV_X
   \   000097   78..         MOV     R0,#?V0 + 0
   \   000099   79..         MOV     R1,#?V0 + 8
   \   00009B   12....       LCALL   ?FLT_EQ
   \   00009E   6066         JZ      ??accel_self_test_1
   2048                      st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
   \   0000A0   78..         MOV     R0,#?V0 + 4
   \   0000A2   79..         MOV     R1,#?V0 + 0
   \   0000A4   12....       LCALL   ?FLT_DIV
   \   0000A7   90....       MOV     DPTR,#__Constant_bf800000
   \   0000AA   78..         MOV     R0,#?V0 + 0
   \   0000AC   12....       LCALL   ?L_MOV_X
   \   0000AF   78..         MOV     R0,#?V0 + 4
   \   0000B1   79..         MOV     R1,#?V0 + 0
   \   0000B3   12....       LCALL   ?FLT_ADD
   2049                      if (fabs(st_shift_var) > test.max_accel_var)
   \   0000B6   90....       MOV     DPTR,#__Constant_1
   \   0000B9   78..         MOV     R0,#?V0 + 0
   \   0000BB   12....       LCALL   ?L_MOV_X
   \   0000BE   78..         MOV     R0,#?V0 + 4
   \   0000C0   79..         MOV     R1,#?V0 + 0
   \   0000C2   12....       LCALL   ?FLT_GE
   \   0000C5   500E         JNC     ??accel_self_test_2
   \   0000C7   85....       MOV     ?V0 + 0,?V0 + 4
   \   0000CA   85....       MOV     ?V0 + 1,?V0 + 5
   \   0000CD   85....       MOV     ?V0 + 2,?V0 + 6
   \   0000D0   85....       MOV     ?V0 + 3,?V0 + 7
   \   0000D3   800F         SJMP    ??accel_self_test_3
   \                     ??accel_self_test_2:
   \   0000D5   E5..         MOV     A,?V0 + 7
   \   0000D7   B2E7         CPL     0xE0 /* A   */.7
   \   0000D9   85....       MOV     ?V0 + 0,?V0 + 4
   \   0000DC   85....       MOV     ?V0 + 1,?V0 + 5
   \   0000DF   85....       MOV     ?V0 + 2,?V0 + 6
   \   0000E2   F5..         MOV     ?V0 + 3,A
   \                     ??accel_self_test_3:
   \   0000E4   90....       MOV     DPTR,#__Constant_3e0f5c2a
   \   0000E7   78..         MOV     R0,#?V0 + 4
   \   0000E9   12....       LCALL   ?L_MOV_X
   \   0000EC   78..         MOV     R0,#?V0 + 0
   \   0000EE   79..         MOV     R1,#?V0 + 4
   \   0000F0   12....       LCALL   ?FLT_GE
   \   0000F3   5033         JNC     ??accel_self_test_4
   2050                          result |= 1 << jj;
   \                     ??accel_self_test_5:
   \   0000F5   75..01       MOV     ?V0 + 0,#0x1
   \   0000F8   75..00       MOV     ?V0 + 1,#0x0
   \   0000FB   EE           MOV     A,R6
   \   0000FC   78..         MOV     R0,#?V0 + 0
   \   0000FE   12....       LCALL   ?S_SHL
   \   000101   12....       LCALL   ?Subroutine72 & 0xFFFF
   2051                  } else if ((st_shift_cust < test.min_g) ||
   \                     ??CrossCallReturnLabel_116:
   \   000104   8022         SJMP    ??accel_self_test_4
   2052                      (st_shift_cust > test.max_g))
   \                     ??accel_self_test_1:
   \   000106   90....       MOV     DPTR,#__Constant_3e99999a
   \   000109   78..         MOV     R0,#?V0 + 0
   \   00010B   12....       LCALL   ?L_MOV_X
   \   00010E   78..         MOV     R0,#?V0 + 4
   \   000110   79..         MOV     R1,#?V0 + 0
   \   000112   12....       LCALL   ?FLT_LT
   \   000115   40DE         JC      ??accel_self_test_5
   \   000117   90....       MOV     DPTR,#__Constant_3f733334
   \   00011A   78..         MOV     R0,#?V0 + 0
   \   00011C   12....       LCALL   ?L_MOV_X
   \   00011F   78..         MOV     R0,#?V0 + 4
   \   000121   79..         MOV     R1,#?V0 + 0
   \   000123   12....       LCALL   ?FLT_GE
   \   000126   40CD         JC      ??accel_self_test_5
   2053                      result |= 1 << jj;
   2054              }
   \                     ??accel_self_test_4:
   \   000128   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00012B   5003         JNC     $+5
   \   00012D   02....       LJMP    ??accel_self_test_0 & 0xFFFF
   2055          
   2056              return result;
   \   000130   AA..         MOV     R2,?V0 + 12
   \   000132   AB..         MOV     R3,?V0 + 13
   \   000134   740E         MOV     A,#0xe
   \   000136   02....       LJMP    ?Subroutine6 & 0xFFFF
   2057          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   45..         ORL     A,?V0 + 12
   \   000004   F5..         MOV     ?V0 + 12,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   45..         ORL     A,?V0 + 13
   \   00000A   F5..         MOV     ?V0 + 13,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   12....       LCALL   ??labs?relay
   \   000003   8A..         MOV     ?V0 + 4,R2
   \   000005   8B..         MOV     ?V0 + 5,R3
   \   000007   8C..         MOV     ?V0 + 6,R4
   \   000009   8D..         MOV     ?V0 + 7,R5
   \   00000B   78..         MOV     R0,#?V0 + 4
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   8C..         MOV     ?V0 + 14,R4
   \   000007   8D..         MOV     ?V0 + 15,R5
   \   000009   75..00       MOV     ?V0 + 12,#0x0
   \   00000C   75..00       MOV     ?V0 + 13,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000003   9403         SUBB    A,#0x3
   \   000005   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   EF           MOV     A,R7
   \   000001                REQUIRE ??Subroutine128_0
   \   000001                ; // Fall through to label ??Subroutine128_0
   2058          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2059          static int gyro_self_test(long *bias_regular, long *bias_st)
   \                     gyro_self_test:
   2060          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7403         MOV     A,#0x3
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine62 & 0xFFFF
   2061              int jj, result = 0;
   2062              unsigned char tmp[3];
   2063              float st_shift, st_shift_cust, st_shift_var;
   2064          
   2065              if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
   \                     ??CrossCallReturnLabel_99:
   \   000012                ; Setup parameters for call to function I2C_Read
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   7B03         MOV     R3,#0x3
   \   00001E   7A0D         MOV     R2,#0xd
   \   000020   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000023   6007         JZ      ??gyro_self_test_0
   2066                  return 0x07;
   \   000025   7A07         MOV     R2,#0x7
   \   000027   7B00         MOV     R3,#0x0
   \   000029   02....       LJMP    ??gyro_self_test_1 & 0xFFFF
   2067          
   2068              tmp[0] &= 0x1F;
   \                     ??gyro_self_test_0:
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   541F         ANL     A,#0x1f
   \   000035   F0           MOVX    @DPTR,A
   2069              tmp[1] &= 0x1F;
   \   000036   7401         MOV     A,#0x1
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   541F         ANL     A,#0x1f
   \   00003E   F0           MOVX    @DPTR,A
   2070              tmp[2] &= 0x1F;
   \   00003F   7402         MOV     A,#0x2
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E0           MOVX    A,@DPTR
   \   000045   541F         ANL     A,#0x1f
   \   000047   F0           MOVX    @DPTR,A
   2071          
   2072              for (jj = 0; jj < 3; jj++) {
   \   000048   7E00         MOV     R6,#0x0
   \   00004A   7F00         MOV     R7,#0x0
   2073                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \                     ??gyro_self_test_2:
   \   00004C   8E..         MOV     ?V0 + 0,R6
   \   00004E   8F..         MOV     ?V0 + 1,R7
   \   000050   7402         MOV     A,#0x2
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?S_SHL
   \   000057   AA..         MOV     R2,?V0 + 0
   \   000059   AB..         MOV     R3,?V0 + 1
   \   00005B                ; Setup parameters for call to function labs
   \   00005B   7403         MOV     A,#0x3
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   2A           ADD     A,R2
   \   000062   F8           MOV     R0,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   3B           ADDC    A,R3
   \   000066   8882         MOV     DPL,R0
   \   000068   F583         MOV     DPH,A
   \   00006A   78..         MOV     R0,#?V0 + 0
   \   00006C   12....       LCALL   ?L_MOV_X
   \   00006F   E5..         MOV     A,?V0 + 14
   \   000071   2A           ADD     A,R2
   \   000072   F582         MOV     DPL,A
   \   000074   E5..         MOV     A,?V0 + 15
   \   000076   3B           ADDC    A,R3
   \   000077   F583         MOV     DPH,A
   \   000079   78..         MOV     R0,#?V0 + 0
   \   00007B   12....       LCALL   ?L_SUB_X
   \   00007E   AA..         MOV     R2,?V0 + 0
   \   000080   AB..         MOV     R3,?V0 + 1
   \   000082   AC..         MOV     R4,?V0 + 2
   \   000084   AD..         MOV     R5,?V0 + 3
   \   000086   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000089   12....       LCALL   ?L_TO_FLT
   \   00008C   90....       MOV     DPTR,#__Constant_37800000
   \   00008F   78..         MOV     R0,#?V0 + 0
   \   000091   12....       LCALL   ?L_MOV_X
   \   000094   78..         MOV     R0,#?V0 + 4
   \   000096   79..         MOV     R1,#?V0 + 0
   \   000098   12....       LCALL   ?FLT_MUL
   2074                  if (tmp[jj]) {
   \   00009B   85..82       MOV     DPL,?XSP + 0
   \   00009E   85..83       MOV     DPH,?XSP + 1
   \   0000A1   E582         MOV     A,DPL
   \   0000A3   2E           ADD     A,R6
   \   0000A4   FA           MOV     R2,A
   \   0000A5   E583         MOV     A,DPH
   \   0000A7   3F           ADDC    A,R7
   \   0000A8   FB           MOV     R3,A
   \   0000A9   8A82         MOV     DPL,R2
   \   0000AB   8B83         MOV     DPH,R3
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   7003         JNZ     $+5
   \   0000B0   02....       LJMP    ??gyro_self_test_3 & 0xFFFF
   2075                      st_shift = 3275.f / test.gyro_sens;
   \   0000B3   90....       MOV     DPTR,#__Constant_41c80000
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?L_MOV_X
   \   0000BB   800F         SJMP    ??gyro_self_test_4
   2076                      while (--tmp[jj])
   2077                          st_shift *= 1.046f;
   \                     ??gyro_self_test_5:
   \   0000BD   90....       MOV     DPTR,#__Constant_3f85e354
   \   0000C0   78..         MOV     R0,#?V0 + 8
   \   0000C2   12....       LCALL   ?L_MOV_X
   \   0000C5   78..         MOV     R0,#?V0 + 0
   \   0000C7   79..         MOV     R1,#?V0 + 8
   \   0000C9   12....       LCALL   ?FLT_MUL
   \                     ??gyro_self_test_4:
   \   0000CC   8A82         MOV     DPL,R2
   \   0000CE   8B83         MOV     DPH,R3
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   14           DEC     A
   \   0000D2   F0           MOVX    @DPTR,A
   \   0000D3   70E8         JNZ     ??gyro_self_test_5
   2078                      st_shift_var = st_shift_cust / st_shift - 1.f;
   \   0000D5   78..         MOV     R0,#?V0 + 4
   \   0000D7   79..         MOV     R1,#?V0 + 0
   \   0000D9   12....       LCALL   ?FLT_DIV
   \   0000DC   90....       MOV     DPTR,#__Constant_bf800000
   \   0000DF   78..         MOV     R0,#?V0 + 0
   \   0000E1   12....       LCALL   ?L_MOV_X
   \   0000E4   78..         MOV     R0,#?V0 + 4
   \   0000E6   79..         MOV     R1,#?V0 + 0
   \   0000E8   12....       LCALL   ?FLT_ADD
   2079                      if (fabs(st_shift_var) > test.max_gyro_var)
   \   0000EB   90....       MOV     DPTR,#__Constant_1
   \   0000EE   78..         MOV     R0,#?V0 + 0
   \   0000F0   12....       LCALL   ?L_MOV_X
   \   0000F3   78..         MOV     R0,#?V0 + 4
   \   0000F5   79..         MOV     R1,#?V0 + 0
   \   0000F7   12....       LCALL   ?FLT_GE
   \   0000FA   500E         JNC     ??gyro_self_test_6
   \   0000FC   85....       MOV     ?V0 + 0,?V0 + 4
   \   0000FF   85....       MOV     ?V0 + 1,?V0 + 5
   \   000102   85....       MOV     ?V0 + 2,?V0 + 6
   \   000105   85....       MOV     ?V0 + 3,?V0 + 7
   \   000108   800F         SJMP    ??gyro_self_test_7
   \                     ??gyro_self_test_6:
   \   00010A   E5..         MOV     A,?V0 + 7
   \   00010C   B2E7         CPL     0xE0 /* A   */.7
   \   00010E   85....       MOV     ?V0 + 0,?V0 + 4
   \   000111   85....       MOV     ?V0 + 1,?V0 + 5
   \   000114   85....       MOV     ?V0 + 2,?V0 + 6
   \   000117   F5..         MOV     ?V0 + 3,A
   \                     ??gyro_self_test_7:
   \   000119   90....       MOV     DPTR,#__Constant_3e0f5c2a
   \   00011C   78..         MOV     R0,#?V0 + 4
   \   00011E   12....       LCALL   ?L_MOV_X
   \   000121   78..         MOV     R0,#?V0 + 0
   \   000123   79..         MOV     R1,#?V0 + 4
   \   000125   12....       LCALL   ?FLT_GE
   \   000128   5033         JNC     ??gyro_self_test_8
   2080                          result |= 1 << jj;
   \                     ??gyro_self_test_9:
   \   00012A   75..01       MOV     ?V0 + 0,#0x1
   \   00012D   75..00       MOV     ?V0 + 1,#0x0
   \   000130   EE           MOV     A,R6
   \   000131   78..         MOV     R0,#?V0 + 0
   \   000133   12....       LCALL   ?S_SHL
   \   000136   12....       LCALL   ?Subroutine72 & 0xFFFF
   2081                  } else if ((st_shift_cust < test.min_dps) ||
   \                     ??CrossCallReturnLabel_117:
   \   000139   8022         SJMP    ??gyro_self_test_8
   2082                      (st_shift_cust > test.max_dps))
   \                     ??gyro_self_test_3:
   \   00013B   90....       MOV     DPTR,#__Constant_41200000
   \   00013E   78..         MOV     R0,#?V0 + 0
   \   000140   12....       LCALL   ?L_MOV_X
   \   000143   78..         MOV     R0,#?V0 + 4
   \   000145   79..         MOV     R1,#?V0 + 0
   \   000147   12....       LCALL   ?FLT_LT
   \   00014A   40DE         JC      ??gyro_self_test_9
   \   00014C   90....       MOV     DPTR,#__Constant_42d20001
   \   00014F   78..         MOV     R0,#?V0 + 0
   \   000151   12....       LCALL   ?L_MOV_X
   \   000154   78..         MOV     R0,#?V0 + 4
   \   000156   79..         MOV     R1,#?V0 + 0
   \   000158   12....       LCALL   ?FLT_GE
   \   00015B   40CD         JC      ??gyro_self_test_9
   2083                      result |= 1 << jj;
   2084              }
   \                     ??gyro_self_test_8:
   \   00015D   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000160   5003         JNC     $+5
   \   000162   02....       LJMP    ??gyro_self_test_2 & 0xFFFF
   2085              return result;
   \   000165   AA..         MOV     R2,?V0 + 12
   \   000167   AB..         MOV     R3,?V0 + 13
   \                     ??gyro_self_test_1:
   \   000169   7405         MOV     A,#0x5
   \   00016B                REQUIRE ?Subroutine6
   \   00016B                ; // Fall through to label ?Subroutine6
   2086          }
   2087          
   2088          #ifdef AK89xx_SECONDARY
   2089          static int compass_self_test(void)
   2090          {
   2091              unsigned char tmp[6];
   2092              unsigned char tries = 10;
   2093              int result = 0x07;
   2094              short data;
   2095          
   2096              mpu_set_bypass(1);
   2097          
   2098              tmp[0] = AKM_POWER_DOWN;
   2099              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2100                  return 0x07;
   2101              tmp[0] = AKM_BIT_SELF_TEST;
   2102              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
   2103                  goto AKM_restore;
   2104              tmp[0] = AKM_MODE_SELF_TEST;
   2105              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2106                  goto AKM_restore;
   2107          
   2108              do {
   2109                  delay_ms(10);
   2110                  if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
   2111                      goto AKM_restore;
   2112                  if (tmp[0] & AKM_DATA_READY)
   2113                      break;
   2114              } while (tries--);
   2115              if (!(tmp[0] & AKM_DATA_READY))
   2116                  goto AKM_restore;
   2117          
   2118              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
   2119                  goto AKM_restore;
   2120          
   2121              result = 0;
   2122              data = (short)(tmp[1] << 8) | tmp[0];
   2123              if ((data > 100) || (data < -100))
   2124                  result |= 0x01;
   2125              data = (short)(tmp[3] << 8) | tmp[2];
   2126              if ((data > 100) || (data < -100))
   2127                  result |= 0x02;
   2128              data = (short)(tmp[5] << 8) | tmp[4];
   2129              if ((data > -300) || (data < -1000))
   2130                  result |= 0x04;
   2131          
   2132          AKM_restore:
   2133              tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
   2134              i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
   2135              tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
   2136              i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
   2137              mpu_set_bypass(0);
   2138              return result;
   2139          }
   2140          #endif
   2141          #endif
   2142          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2143          static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
   \                     get_st_biases:
   2144          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV     A,#-0x1f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740F         MOV     A,#0xf
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   740D         MOV     A,#0xd
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   EC           MOV     A,R4
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   ED           MOV     A,R5
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   E9           MOV     A,R1
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   F0           MOVX    @DPTR,A
   2145              unsigned char data[MAX_PACKET_LENGTH];
   2146              unsigned char packet_count, ii;
   2147              unsigned short fifo_count;
   2148              
   2149          
   2150              data[0] = 0x01;
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   7401         MOV     A,#0x1
   \   00002D   F0           MOVX    @DPTR,A
   2151              data[1] = 0;
   \   00002E   04           INC     A
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E4           CLR     A
   \   000033   F0           MOVX    @DPTR,A
   2152              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \   000034                ; Setup parameters for call to function I2C_Write
   \   000034   04           INC     A
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   00003B   6007         JZ      ??get_st_biases_0
   2153                  return -1;
   \                     ??get_st_biases_1:
   \   00003D   7AFF         MOV     R2,#-0x1
   \   00003F   7BFF         MOV     R3,#-0x1
   \   000041   02....       LJMP    ??get_st_biases_2 & 0xFFFF
   2154              delay_ms(200);
   \                     ??get_st_biases_0:
   \   000044                ; Setup parameters for call to function delay_ms
   \   000044   7AC8         MOV     R2,#-0x38
   \   000046   7B00         MOV     R3,#0x0
   \   000048   12....       LCALL   ??delay_ms?relay
   2155              data[0] = 0;
   \   00004B   7401         MOV     A,#0x1
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   12....       LCALL   ?Subroutine57 & 0xFFFF
   2156              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \                     ??CrossCallReturnLabel_253:
   \   000053   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   000056   70E5         JNZ     ??get_st_biases_1
   2157                  return -1;
   2158              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   000058                ; Setup parameters for call to function I2C_Write
   \   000058   7401         MOV     A,#0x1
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000060   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000063   70D8         JNZ     ??get_st_biases_1
   2159                  return -1;
   2160              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \   000065                ; Setup parameters for call to function I2C_Write
   \   000065   7401         MOV     A,#0x1
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   AC82         MOV     R4,DPL
   \   00006C   AD83         MOV     R5,DPH
   \   00006E   7B01         MOV     R3,#0x1
   \   000070   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000073   70C8         JNZ     ??get_st_biases_1
   2161                  return -1;
   2162              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   \   000075                ; Setup parameters for call to function I2C_Write
   \   000075   7401         MOV     A,#0x1
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   AC82         MOV     R4,DPL
   \   00007C   AD83         MOV     R5,DPH
   \   00007E   7B01         MOV     R3,#0x1
   \   000080   90....       MOV     DPTR,#st
   \   000083   E0           MOVX    A,@DPTR
   \   000084   2417         ADD     A,#0x17
   \   000086   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000089   70B2         JNZ     ??get_st_biases_1
   2163                  return -1;
   2164              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   00008B                ; Setup parameters for call to function I2C_Write
   \   00008B   7401         MOV     A,#0x1
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000093   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   000096   70A5         JNZ     ??get_st_biases_1
   2165                  return -1;
   2166              data[0] = BIT_FIFO_RST | BIT_DMP_RST;
   \   000098   7401         MOV     A,#0x1
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   12....       LCALL   ?Subroutine34 & 0xFFFF
   2167              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \                     ??CrossCallReturnLabel_166:
   \   0000A0   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   0000A3   7098         JNZ     ??get_st_biases_1
   2168                  return -1;
   2169              delay_ms(15);
   \   0000A5                ; Setup parameters for call to function delay_ms
   \   0000A5   7A0F         MOV     R2,#0xf
   \   0000A7   7B00         MOV     R3,#0x0
   \   0000A9   12....       LCALL   ??delay_ms?relay
   2170              data[0] = st.test->reg_lpf;
   \   0000AC   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   C0E0         PUSH    A
   \   0000B3   7401         MOV     A,#0x1
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   D0E0         POP     A
   \   0000BA   12....       LCALL   ?Subroutine35 & 0xFFFF
   2171              if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \                     ??CrossCallReturnLabel_200:
   \   0000BD   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   0000C0   6003         JZ      $+5
   \   0000C2   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2172                  return -1;
   2173              data[0] = st.test->reg_rate_div;
   \   0000C5   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   C0E0         PUSH    A
   \   0000CB   7401         MOV     A,#0x1
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   D0E0         POP     A
   \   0000D2   12....       LCALL   ?Subroutine37 & 0xFFFF
   2174              if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
   \                     ??CrossCallReturnLabel_194:
   \   0000D5   A3           INC     DPTR
   \   0000D6   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   0000D9   6003         JZ      $+5
   \   0000DB   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   \   0000DE   90....       MOV     DPTR,#st + 33
   \   0000E1   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   0000E4   F8           MOV     R0,A
   \   0000E5   85..82       MOV     DPL,?XSP + 0
   \   0000E8   85..83       MOV     DPH,?XSP + 1
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   600E         JZ      ??get_st_biases_3
   2175                  return -1;
   2176              if (hw_test)
   2177                  data[0] = st.test->reg_gyro_fsr | 0xE0;
   \   0000EE   74E0         MOV     A,#-0x20
   \   0000F0   48           ORL     A,R0
   \   0000F1   C0E0         PUSH    A
   \   0000F3   7401         MOV     A,#0x1
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   D0E0         POP     A
   \   0000FA   8006         SJMP    ??get_st_biases_4
   2178              else
   2179                  data[0] = st.test->reg_gyro_fsr;
   \                     ??get_st_biases_3:
   \   0000FC   7401         MOV     A,#0x1
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   E8           MOV     A,R0
   \                     ??get_st_biases_4:
   \   000102   F0           MOVX    @DPTR,A
   2180              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
   \   000103                ; Setup parameters for call to function I2C_Write
   \   000103   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000106   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   000109   6003         JZ      $+5
   \   00010B   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2181                  return -1;
   2182          
   2183              if (hw_test)
   \   00010E   85..82       MOV     DPL,?XSP + 0
   \   000111   85..83       MOV     DPH,?XSP + 1
   \   000114   E0           MOVX    A,@DPTR
   \   000115   6013         JZ      ??get_st_biases_5
   2184                  data[0] = st.test->reg_accel_fsr | 0xE0;
   \   000117   90....       MOV     DPTR,#st + 33
   \   00011A   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00011D   44E0         ORL     A,#0xe0
   \   00011F   C0E0         PUSH    A
   \   000121   7401         MOV     A,#0x1
   \   000123   12....       LCALL   ?XSTACK_DISP0_8
   \   000126   D0E0         POP     A
   \   000128   8007         SJMP    ??get_st_biases_6
   2185              else
   2186                  data[0] = test.reg_accel_fsr;
   \                     ??get_st_biases_5:
   \   00012A   7401         MOV     A,#0x1
   \   00012C   12....       LCALL   ?XSTACK_DISP0_8
   \   00012F   7418         MOV     A,#0x18
   \                     ??get_st_biases_6:
   \   000131   12....       LCALL   ?Subroutine23 & 0xFFFF
   2187              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??CrossCallReturnLabel_212:
   \   000134   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   000137   6003         JZ      $+5
   \   000139   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2188                  return -1;
   2189              if (hw_test)
   \   00013C   85..82       MOV     DPL,?XSP + 0
   \   00013F   85..83       MOV     DPH,?XSP + 1
   \   000142   E0           MOVX    A,@DPTR
   \   000143   6007         JZ      ??get_st_biases_7
   2190                  delay_ms(200);
   \   000145                ; Setup parameters for call to function delay_ms
   \   000145   7AC8         MOV     R2,#-0x38
   \   000147   7B00         MOV     R3,#0x0
   \   000149   12....       LCALL   ??delay_ms?relay
   2191          
   2192              /* Fill FIFO for test.wait_ms milliseconds. */
   2193              data[0] = BIT_FIFO_EN;
   \                     ??get_st_biases_7:
   \   00014C   7401         MOV     A,#0x1
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   7440         MOV     A,#0x40
   \   000153   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   2194              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \                     ??CrossCallReturnLabel_171:
   \   000156   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   000159   6003         JZ      $+5
   \   00015B   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2195                  return -1;
   2196          
   2197              data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
   \   00015E   7401         MOV     A,#0x1
   \   000160   12....       LCALL   ?XSTACK_DISP0_8
   \   000163   7478         MOV     A,#0x78
   \   000165   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   2198              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??CrossCallReturnLabel_206:
   \   000168   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   00016B   6003         JZ      $+5
   \   00016D   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2199                  return -1;
   2200              delay_ms(test.wait_ms);
   \   000170                ; Setup parameters for call to function delay_ms
   \   000170   7A32         MOV     R2,#0x32
   \   000172   7B00         MOV     R3,#0x0
   \   000174   12....       LCALL   ??delay_ms?relay
   2201              data[0] = 0;
   \   000177   7401         MOV     A,#0x1
   \   000179   12....       LCALL   ?XSTACK_DISP0_8
   \   00017C   12....       LCALL   ?Subroutine33 & 0xFFFF
   2202              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??CrossCallReturnLabel_205:
   \   00017F   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   000182   6003         JZ      $+5
   \   000184   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2203                  return -1;
   2204          
   2205              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \   000187                ; Setup parameters for call to function I2C_Read
   \   000187   7401         MOV     A,#0x1
   \   000189   12....       LCALL   ?XSTACK_DISP0_8
   \   00018C   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00018F   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   000192   6003         JZ      $+5
   \   000194   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2206                  return -1;
   2207          
   2208              fifo_count = (data[0] << 8) | data[1];
   2209              packet_count = fifo_count / MAX_PACKET_LENGTH;
   \   000197   7401         MOV     A,#0x1
   \   000199   12....       LCALL   ?XSTACK_DISP0_8
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   F9           MOV     R1,A
   \   00019E   7402         MOV     A,#0x2
   \   0001A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   F8           MOV     R0,A
   \   0001A5   7A0C         MOV     R2,#0xc
   \   0001A7   7B00         MOV     R3,#0x0
   \   0001A9   12....       LCALL   ?US_DIV_MOD
   \   0001AC   E8           MOV     A,R0
   \   0001AD   F5..         MOV     ?V0 + 0,A
   2210              gyro[0] = gyro[1] = gyro[2] = 0;
   \   0001AF   740F         MOV     A,#0xf
   \   0001B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   2408         ADD     A,#0x8
   \   0001B7   F5..         MOV     ?V0 + 14,A
   \   0001B9   A3           INC     DPTR
   \   0001BA   E0           MOVX    A,@DPTR
   \   0001BB   3400         ADDC    A,#0x0
   \   0001BD   F5..         MOV     ?V0 + 15,A
   \   0001BF   90....       MOV     DPTR,#__Constant_0
   \   0001C2   12....       LCALL   ?XLOAD_R2345
   \   0001C5   85..82       MOV     DPL,?V0 + 14
   \   0001C8   85..83       MOV     DPH,?V0 + 15
   \   0001CB   12....       LCALL   ?XSTORE_R2345
   \   0001CE   740F         MOV     A,#0xf
   \   0001D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   2404         ADD     A,#0x4
   \   0001D6   F5..         MOV     ?V0 + 12,A
   \   0001D8   A3           INC     DPTR
   \   0001D9   E0           MOVX    A,@DPTR
   \   0001DA   3400         ADDC    A,#0x0
   \   0001DC   F5..         MOV     ?V0 + 13,A
   \   0001DE   90....       MOV     DPTR,#__Constant_0
   \   0001E1   12....       LCALL   ?XLOAD_R2345
   \   0001E4   85..82       MOV     DPL,?V0 + 12
   \   0001E7   85..83       MOV     DPH,?V0 + 13
   \   0001EA   12....       LCALL   ?XSTORE_R2345
   \   0001ED   90....       MOV     DPTR,#__Constant_0
   \   0001F0   12....       LCALL   ?XLOAD_R2345
   \   0001F3   740F         MOV     A,#0xf
   \   0001F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F8   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   0001FB   12....       LCALL   ?XSTORE_R2345
   2211              accel[0] = accel[1] = accel[2] = 0;
   \   0001FE   740D         MOV     A,#0xd
   \   000200   12....       LCALL   ?XSTACK_DISP0_8
   \   000203   E0           MOVX    A,@DPTR
   \   000204   2408         ADD     A,#0x8
   \   000206   F8           MOV     R0,A
   \   000207   A3           INC     DPTR
   \   000208   E0           MOVX    A,@DPTR
   \   000209   3400         ADDC    A,#0x0
   \   00020B   F9           MOV     R1,A
   \   00020C   7411         MOV     A,#0x11
   \   00020E   12....       LCALL   ?XSTACK_DISP0_8
   \   000211   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000214   90....       MOV     DPTR,#__Constant_0
   \   000217   12....       LCALL   ?XLOAD_R2345
   \   00021A   7411         MOV     A,#0x11
   \   00021C   12....       LCALL   ?XSTACK_DISP0_8
   \   00021F   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000222   12....       LCALL   ?XSTORE_R2345
   \   000225   740D         MOV     A,#0xd
   \   000227   12....       LCALL   ?XSTACK_DISP0_8
   \   00022A   E0           MOVX    A,@DPTR
   \   00022B   2404         ADD     A,#0x4
   \   00022D   FE           MOV     R6,A
   \   00022E   A3           INC     DPTR
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   3400         ADDC    A,#0x0
   \   000232   FF           MOV     R7,A
   \   000233   90....       MOV     DPTR,#__Constant_0
   \   000236   12....       LCALL   ?XLOAD_R2345
   \   000239   8E82         MOV     DPL,R6
   \   00023B   8F83         MOV     DPH,R7
   \   00023D   12....       LCALL   ?XSTORE_R2345
   \   000240   90....       MOV     DPTR,#__Constant_0
   \   000243   12....       LCALL   ?XLOAD_R2345
   \   000246   740D         MOV     A,#0xd
   \   000248   12....       LCALL   ?XSTACK_DISP0_8
   \   00024B   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   00024E   12....       LCALL   ?XSTORE_R2345
   2212          
   2213              for (ii = 0; ii < packet_count; ii++) {
   \   000251   75..00       MOV     ?V0 + 1,#0x0
   \   000254   02....       LJMP    ??get_st_biases_8 & 0xFFFF
   2214                  short accel_cur[3], gyro_cur[3];
   2215                  if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
   \                     ??get_st_biases_9:
   \   000257                ; Setup parameters for call to function I2C_Read
   \   000257   7401         MOV     A,#0x1
   \   000259   12....       LCALL   ?XSTACK_DISP0_8
   \   00025C   AC82         MOV     R4,DPL
   \   00025E   AD83         MOV     R5,DPH
   \   000260   7B0C         MOV     R3,#0xc
   \   000262   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000265   8B..         MOV     ?V0 + 3,R3
   \   000267   EA           MOV     A,R2
   \   000268   45..         ORL     A,?V0 + 3
   \   00026A   6003         JZ      $+5
   \   00026C   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2216                      return -1;
   2217                  accel_cur[0] = ((short)data[0] << 8) | data[1];
   \   00026F   7401         MOV     A,#0x1
   \   000271   12....       LCALL   ?XSTACK_DISP0_8
   \   000274   E0           MOVX    A,@DPTR
   \   000275   F9           MOV     R1,A
   \   000276   7402         MOV     A,#0x2
   \   000278   12....       LCALL   ?XSTACK_DISP0_8
   \   00027B   E0           MOVX    A,@DPTR
   \   00027C   F8           MOV     R0,A
   \   00027D   7419         MOV     A,#0x19
   \   00027F   12....       LCALL   ?XSTACK_DISP0_8
   \   000282   12....       LCALL   ?Subroutine65 & 0xFFFF
   2218                  accel_cur[1] = ((short)data[2] << 8) | data[3];
   \                     ??CrossCallReturnLabel_163:
   \   000285   7403         MOV     A,#0x3
   \   000287   12....       LCALL   ?XSTACK_DISP0_8
   \   00028A   E0           MOVX    A,@DPTR
   \   00028B   F9           MOV     R1,A
   \   00028C   7404         MOV     A,#0x4
   \   00028E   12....       LCALL   ?XSTACK_DISP0_8
   \   000291   E0           MOVX    A,@DPTR
   \   000292   FC           MOV     R4,A
   \   000293   E9           MOV     A,R1
   \   000294   FD           MOV     R5,A
   \   000295   741B         MOV     A,#0x1b
   \   000297   12....       LCALL   ?XSTACK_DISP0_8
   \   00029A   EC           MOV     A,R4
   \   00029B   F0           MOVX    @DPTR,A
   \   00029C   A3           INC     DPTR
   \   00029D   ED           MOV     A,R5
   \   00029E   F0           MOVX    @DPTR,A
   2219                  accel_cur[2] = ((short)data[4] << 8) | data[5];
   \   00029F   7405         MOV     A,#0x5
   \   0002A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A4   E0           MOVX    A,@DPTR
   \   0002A5   F9           MOV     R1,A
   \   0002A6   7406         MOV     A,#0x6
   \   0002A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AB   E0           MOVX    A,@DPTR
   \   0002AC   FA           MOV     R2,A
   \   0002AD   E9           MOV     A,R1
   \   0002AE   FB           MOV     R3,A
   \   0002AF   741D         MOV     A,#0x1d
   \   0002B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B4   EA           MOV     A,R2
   \   0002B5   F0           MOVX    @DPTR,A
   \   0002B6   A3           INC     DPTR
   \   0002B7   EB           MOV     A,R3
   \   0002B8   F0           MOVX    @DPTR,A
   2220                  accel[0] += (long)accel_cur[0];
   \   0002B9   7419         MOV     A,#0x19
   \   0002BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BE   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0002C1   740D         MOV     A,#0xd
   \   0002C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C6   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0002C9   12....       LCALL   ?L_ADD_TO_X
   2221                  accel[1] += (long)accel_cur[1];
   \   0002CC   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   0002CF   8E82         MOV     DPL,R6
   \   0002D1   8F83         MOV     DPH,R7
   \   0002D3   78..         MOV     R0,#?V0 + 4
   \   0002D5   12....       LCALL   ?L_ADD_TO_X
   2222                  accel[2] += (long)accel_cur[2];
   \   0002D8   8A..         MOV     ?V0 + 4,R2
   \   0002DA   EB           MOV     A,R3
   \   0002DB   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   0002DE   7411         MOV     A,#0x11
   \   0002E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E3   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   0002E6   12....       LCALL   ?L_ADD_TO_X
   2223                  gyro_cur[0] = (((short)data[6] << 8) | data[7]);
   \   0002E9   7407         MOV     A,#0x7
   \   0002EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002EE   E0           MOVX    A,@DPTR
   \   0002EF   F9           MOV     R1,A
   \   0002F0   7408         MOV     A,#0x8
   \   0002F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F5   E0           MOVX    A,@DPTR
   \   0002F6   F8           MOV     R0,A
   \   0002F7   7413         MOV     A,#0x13
   \   0002F9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002FC   12....       LCALL   ?Subroutine65 & 0xFFFF
   2224                  gyro_cur[1] = (((short)data[8] << 8) | data[9]);
   \                     ??CrossCallReturnLabel_164:
   \   0002FF   7409         MOV     A,#0x9
   \   000301   12....       LCALL   ?XSTACK_DISP0_8
   \   000304   E0           MOVX    A,@DPTR
   \   000305   F9           MOV     R1,A
   \   000306   740A         MOV     A,#0xa
   \   000308   12....       LCALL   ?XSTACK_DISP0_8
   \   00030B   E0           MOVX    A,@DPTR
   \   00030C   FC           MOV     R4,A
   \   00030D   E9           MOV     A,R1
   \   00030E   FD           MOV     R5,A
   \   00030F   7415         MOV     A,#0x15
   \   000311   12....       LCALL   ?XSTACK_DISP0_8
   \   000314   EC           MOV     A,R4
   \   000315   F0           MOVX    @DPTR,A
   \   000316   A3           INC     DPTR
   \   000317   ED           MOV     A,R5
   \   000318   F0           MOVX    @DPTR,A
   2225                  gyro_cur[2] = (((short)data[10] << 8) | data[11]);
   \   000319   740B         MOV     A,#0xb
   \   00031B   12....       LCALL   ?XSTACK_DISP0_8
   \   00031E   E0           MOVX    A,@DPTR
   \   00031F   F9           MOV     R1,A
   \   000320   740C         MOV     A,#0xc
   \   000322   12....       LCALL   ?XSTACK_DISP0_8
   \   000325   E0           MOVX    A,@DPTR
   \   000326   FA           MOV     R2,A
   \   000327   E9           MOV     A,R1
   \   000328   FB           MOV     R3,A
   \   000329   7417         MOV     A,#0x17
   \   00032B   12....       LCALL   ?XSTACK_DISP0_8
   \   00032E   EA           MOV     A,R2
   \   00032F   F0           MOVX    @DPTR,A
   \   000330   A3           INC     DPTR
   \   000331   EB           MOV     A,R3
   \   000332   F0           MOVX    @DPTR,A
   2226                  gyro[0] += (long)gyro_cur[0];
   \   000333   7413         MOV     A,#0x13
   \   000335   12....       LCALL   ?XSTACK_DISP0_8
   \   000338   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   00033B   740F         MOV     A,#0xf
   \   00033D   12....       LCALL   ?XSTACK_DISP0_8
   \   000340   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000343   12....       LCALL   ?L_ADD_TO_X
   2227                  gyro[1] += (long)gyro_cur[1];
   \   000346   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000349   85..82       MOV     DPL,?V0 + 12
   \   00034C   85..83       MOV     DPH,?V0 + 13
   \   00034F   78..         MOV     R0,#?V0 + 4
   \   000351   12....       LCALL   ?L_ADD_TO_X
   2228                  gyro[2] += (long)gyro_cur[2];
   \   000354   8A..         MOV     ?V0 + 4,R2
   \   000356   EB           MOV     A,R3
   \   000357   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   2229              }
   \                     ??CrossCallReturnLabel_190:
   \   00035A   85..82       MOV     DPL,?V0 + 14
   \   00035D   85..83       MOV     DPH,?V0 + 15
   \   000360   78..         MOV     R0,#?V0 + 4
   \   000362   12....       LCALL   ?L_ADD_TO_X
   \   000365   05..         INC     ?V0 + 1
   \                     ??get_st_biases_8:
   \   000367   E5..         MOV     A,?V0 + 1
   \   000369   C3           CLR     C
   \   00036A   95..         SUBB    A,?V0 + 0
   \   00036C   5003         JNC     $+5
   \   00036E   02....       LJMP    ??get_st_biases_9 & 0xFFFF
   2230          ///////////////∂Œ–°—Û///////////////
   2231              unsigned char has_accel=1;
   2232          #define EMPL_NO_64BIT
   2233              ////////////////////////////
   2234          #ifdef EMPL_NO_64BIT
   2235              gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
   \   000371   85....       MOV     ?V0 + 4,?V0 + 0
   \   000374   E4           CLR     A
   \   000375   F5..         MOV     ?V0 + 5,A
   \   000377   F5..         MOV     ?V0 + 6,A
   \   000379   F5..         MOV     ?V0 + 7,A
   \   00037B   78..         MOV     R0,#?V0 + 4
   \   00037D   12....       LCALL   ?UL_TO_FLT
   \   000380   740F         MOV     A,#0xf
   \   000382   12....       LCALL   ?XSTACK_DISP0_8
   \   000385   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000388   12....       LCALL   ?L_MOV_X
   \   00038B   78..         MOV     R0,#?V0 + 0
   \   00038D   12....       LCALL   ?L_TO_FLT
   \   000390   90....       MOV     DPTR,#__Constant_47800000
   \   000393   78..         MOV     R0,#?V0 + 8
   \   000395   12....       LCALL   ?L_MOV_X
   \   000398   78..         MOV     R0,#?V0 + 0
   \   00039A   79..         MOV     R1,#?V0 + 8
   \   00039C   12....       LCALL   ?FLT_MUL
   \   00039F   90....       MOV     DPTR,#__Constant_43030000
   \   0003A2   78..         MOV     R0,#?V0 + 8
   \   0003A4   12....       LCALL   ?L_MOV_X
   \   0003A7   78..         MOV     R0,#?V0 + 0
   \   0003A9   79..         MOV     R1,#?V0 + 8
   \   0003AB   12....       LCALL   ?FLT_DIV
   \   0003AE   78..         MOV     R0,#?V0 + 0
   \   0003B0   79..         MOV     R1,#?V0 + 4
   \   0003B2   12....       LCALL   ?FLT_DIV
   \   0003B5   78..         MOV     R0,#?V0 + 0
   \   0003B7   12....       LCALL   ?FLT_TO_L
   \   0003BA   740F         MOV     A,#0xf
   \   0003BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BF   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0003C2   12....       LCALL   ?L_MOV_TO_X
   2236              gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
   \   0003C5   85..82       MOV     DPL,?V0 + 12
   \   0003C8   85..83       MOV     DPH,?V0 + 13
   \   0003CB   78..         MOV     R0,#?V0 + 0
   \   0003CD   12....       LCALL   ?L_MOV_X
   \   0003D0   78..         MOV     R0,#?V0 + 0
   \   0003D2   12....       LCALL   ?L_TO_FLT
   \   0003D5   90....       MOV     DPTR,#__Constant_47800000
   \   0003D8   78..         MOV     R0,#?V0 + 8
   \   0003DA   12....       LCALL   ?L_MOV_X
   \   0003DD   78..         MOV     R0,#?V0 + 0
   \   0003DF   79..         MOV     R1,#?V0 + 8
   \   0003E1   12....       LCALL   ?FLT_MUL
   \   0003E4   90....       MOV     DPTR,#__Constant_43030000
   \   0003E7   78..         MOV     R0,#?V0 + 8
   \   0003E9   12....       LCALL   ?L_MOV_X
   \   0003EC   78..         MOV     R0,#?V0 + 0
   \   0003EE   79..         MOV     R1,#?V0 + 8
   \   0003F0   12....       LCALL   ?FLT_DIV
   \   0003F3   78..         MOV     R0,#?V0 + 0
   \   0003F5   79..         MOV     R1,#?V0 + 4
   \   0003F7   12....       LCALL   ?FLT_DIV
   \   0003FA   78..         MOV     R0,#?V0 + 0
   \   0003FC   12....       LCALL   ?FLT_TO_L
   \   0003FF   85..82       MOV     DPL,?V0 + 12
   \   000402   85..83       MOV     DPH,?V0 + 13
   \   000405   78..         MOV     R0,#?V0 + 0
   \   000407   12....       LCALL   ?L_MOV_TO_X
   2237              gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
   \   00040A   85..82       MOV     DPL,?V0 + 14
   \   00040D   85..83       MOV     DPH,?V0 + 15
   \   000410   78..         MOV     R0,#?V0 + 0
   \   000412   12....       LCALL   ?L_MOV_X
   \   000415   78..         MOV     R0,#?V0 + 0
   \   000417   12....       LCALL   ?L_TO_FLT
   \   00041A   90....       MOV     DPTR,#__Constant_47800000
   \   00041D   78..         MOV     R0,#?V0 + 8
   \   00041F   12....       LCALL   ?L_MOV_X
   \   000422   78..         MOV     R0,#?V0 + 0
   \   000424   79..         MOV     R1,#?V0 + 8
   \   000426   12....       LCALL   ?FLT_MUL
   \   000429   90....       MOV     DPTR,#__Constant_43030000
   \   00042C   78..         MOV     R0,#?V0 + 8
   \   00042E   12....       LCALL   ?L_MOV_X
   \   000431   78..         MOV     R0,#?V0 + 0
   \   000433   79..         MOV     R1,#?V0 + 8
   \   000435   12....       LCALL   ?FLT_DIV
   \   000438   78..         MOV     R0,#?V0 + 0
   \   00043A   79..         MOV     R1,#?V0 + 4
   \   00043C   12....       LCALL   ?FLT_DIV
   \   00043F   78..         MOV     R0,#?V0 + 0
   \   000441   12....       LCALL   ?FLT_TO_L
   \   000444   85..82       MOV     DPL,?V0 + 14
   \   000447   85..83       MOV     DPH,?V0 + 15
   \   00044A   78..         MOV     R0,#?V0 + 0
   \   00044C   12....       LCALL   ?L_MOV_TO_X
   2238              if (has_accel) {
   2239                  accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
   2240                      packet_count);
   \   00044F   740D         MOV     A,#0xd
   \   000451   12....       LCALL   ?XSTACK_DISP0_8
   \   000454   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000457   12....       LCALL   ?L_MOV_X
   \   00045A   78..         MOV     R0,#?V0 + 0
   \   00045C   12....       LCALL   ?L_TO_FLT
   \   00045F   90....       MOV     DPTR,#__Constant_47800000
   \   000462   78..         MOV     R0,#?V0 + 8
   \   000464   12....       LCALL   ?L_MOV_X
   \   000467   78..         MOV     R0,#?V0 + 0
   \   000469   79..         MOV     R1,#?V0 + 8
   \   00046B   12....       LCALL   ?FLT_MUL
   \   00046E   90....       MOV     DPTR,#__Constant_45000000
   \   000471   78..         MOV     R0,#?V0 + 8
   \   000473   12....       LCALL   ?L_MOV_X
   \   000476   78..         MOV     R0,#?V0 + 0
   \   000478   79..         MOV     R1,#?V0 + 8
   \   00047A   12....       LCALL   ?FLT_DIV
   \   00047D   78..         MOV     R0,#?V0 + 0
   \   00047F   79..         MOV     R1,#?V0 + 4
   \   000481   12....       LCALL   ?FLT_DIV
   \   000484   78..         MOV     R0,#?V0 + 0
   \   000486   12....       LCALL   ?FLT_TO_L
   \   000489   740D         MOV     A,#0xd
   \   00048B   12....       LCALL   ?XSTACK_DISP0_8
   \   00048E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000491   12....       LCALL   ?L_MOV_TO_X
   2241                  accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
   2242                      packet_count);
   \   000494   8E82         MOV     DPL,R6
   \   000496   8F83         MOV     DPH,R7
   \   000498   78..         MOV     R0,#?V0 + 0
   \   00049A   12....       LCALL   ?L_MOV_X
   \   00049D   78..         MOV     R0,#?V0 + 0
   \   00049F   12....       LCALL   ?L_TO_FLT
   \   0004A2   90....       MOV     DPTR,#__Constant_47800000
   \   0004A5   78..         MOV     R0,#?V0 + 8
   \   0004A7   12....       LCALL   ?L_MOV_X
   \   0004AA   78..         MOV     R0,#?V0 + 0
   \   0004AC   79..         MOV     R1,#?V0 + 8
   \   0004AE   12....       LCALL   ?FLT_MUL
   \   0004B1   90....       MOV     DPTR,#__Constant_45000000
   \   0004B4   78..         MOV     R0,#?V0 + 8
   \   0004B6   12....       LCALL   ?L_MOV_X
   \   0004B9   78..         MOV     R0,#?V0 + 0
   \   0004BB   79..         MOV     R1,#?V0 + 8
   \   0004BD   12....       LCALL   ?FLT_DIV
   \   0004C0   78..         MOV     R0,#?V0 + 0
   \   0004C2   79..         MOV     R1,#?V0 + 4
   \   0004C4   12....       LCALL   ?FLT_DIV
   \   0004C7   78..         MOV     R0,#?V0 + 0
   \   0004C9   12....       LCALL   ?FLT_TO_L
   \   0004CC   8E82         MOV     DPL,R6
   \   0004CE   8F83         MOV     DPH,R7
   \   0004D0   78..         MOV     R0,#?V0 + 0
   \   0004D2   12....       LCALL   ?L_MOV_TO_X
   2243                  accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
   2244                      packet_count);
   2245                  /* Don't remove gravity! */
   2246                  accel[2] -= 65536L;
   \   0004D5   7411         MOV     A,#0x11
   \   0004D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0004DA   12....       LCALL   ?Subroutine13 & 0xFFFF
   2247              }
   \                     ??CrossCallReturnLabel_7:
   \   0004DD   12....       LCALL   ?L_MOV_X
   \   0004E0   78..         MOV     R0,#?V0 + 0
   \   0004E2   12....       LCALL   ?L_TO_FLT
   \   0004E5   90....       MOV     DPTR,#__Constant_47800000
   \   0004E8   78..         MOV     R0,#?V0 + 8
   \   0004EA   12....       LCALL   ?L_MOV_X
   \   0004ED   78..         MOV     R0,#?V0 + 0
   \   0004EF   79..         MOV     R1,#?V0 + 8
   \   0004F1   12....       LCALL   ?FLT_MUL
   \   0004F4   90....       MOV     DPTR,#__Constant_45000000
   \   0004F7   78..         MOV     R0,#?V0 + 8
   \   0004F9   12....       LCALL   ?L_MOV_X
   \   0004FC   78..         MOV     R0,#?V0 + 0
   \   0004FE   79..         MOV     R1,#?V0 + 8
   \   000500   12....       LCALL   ?FLT_DIV
   \   000503   78..         MOV     R0,#?V0 + 0
   \   000505   79..         MOV     R1,#?V0 + 4
   \   000507   12....       LCALL   ?FLT_DIV
   \   00050A   78..         MOV     R0,#?V0 + 0
   \   00050C   12....       LCALL   ?FLT_TO_L
   \   00050F   90....       MOV     DPTR,#__Constant_ffff0000
   \   000512   78..         MOV     R0,#?V0 + 0
   \   000514   12....       LCALL   ?L_ADD_X
   \   000517   7411         MOV     A,#0x11
   \   000519   12....       LCALL   ?XSTACK_DISP0_8
   \   00051C   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00051F   12....       LCALL   ?L_MOV_TO_X
   2248          #else
   2249              //printf("hello");
   2250              gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
   2251              gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
   2252              gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
   2253              accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
   2254                  packet_count);
   2255              accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
   2256                  packet_count);
   2257              accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
   2258                  packet_count);
   2259              /* Don't remove gravity! */
   2260              if (accel[2] > 0L)
   2261                  accel[2] -= 65536L;
   2262              else
   2263                  accel[2] += 65536L;
   2264          #endif
   2265          
   2266              return 0;
   \   000522   7A00         MOV     R2,#0x0
   \   000524   7B00         MOV     R3,#0x0
   \                     ??get_st_biases_2:
   \   000526   741F         MOV     A,#0x1f
   \   000528   02....       LJMP    ?Subroutine6 & 0xFFFF
   2267          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   8C..         MOV     ?V0 + 4,R4
   \   000002   ED           MOV     A,R5
   \   000003                REQUIRE ??Subroutine117_0
   \   000003                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                REQUIRE ??Subroutine119_0
   \   000001                ; // Fall through to label ??Subroutine119_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                ; Setup parameters for call to function I2C_Write
   \   000001                REQUIRE ??Subroutine123_0
   \   000001                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   90....       MOV     DPTR,#st + 33
   \   000003                REQUIRE ??Subroutine124_0
   \   000003                ; // Fall through to label ??Subroutine124_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000003   78..         MOV     R0,#?V0 + 0
   \   000005   22           RET
   2268          
   2269          /**
   2270           *  @brief      Trigger gyro/accel/compass self-test.
   2271           *  On success/error, the self-test returns a mask representing the sensor(s)
   2272           *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
   2273           *  a zero (0) indicates a failure.
   2274           *
   2275           *  \n The mask is defined as follows:
   2276           *  \n Bit 0:   Gyro.
   2277           *  \n Bit 1:   Accel.
   2278           *  \n Bit 2:   Compass.
   2279           *
   2280           *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
   2281           *  this function can still be used to obtain the accel and gyro biases.
   2282           *
   2283           *  \n This function must be called with the device either face-up or face-down
   2284           *  (z-axis is parallel to gravity).
   2285           *  @param[out] gyro        Gyro biases in q16 format.
   2286           *  @param[out] accel       Accel biases (if applicable) in q16 format.
   2287           *  @return     Result mask (see above).
   2288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2289          int mpu_run_self_test(long *gyro, long *accel)
   \                     mpu_run_self_test:
   2290          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   2291          #ifdef MPU6050
   2292              const unsigned char tries = 2;
   2293              long gyro_st[3], accel_st[3];
   2294              unsigned char accel_result, gyro_result;
   2295          #ifdef AK89xx_SECONDARY
   2296              unsigned char compass_result;
   2297          #endif
   2298              int ii;
   2299          #endif
   2300              int result;
   2301              unsigned char accel_fsr, fifo_sensors, sensors_on;
   2302              unsigned short gyro_fsr, sample_rate, lpf;
   2303              unsigned char dmp_was_on;
   2304          
   2305              if (st.chip_cfg.dmp_on) {
   \   000012   90....       MOV     DPTR,#st + 29
   \   000015   E0           MOVX    A,@DPTR
   \   000016   600A         JZ      ??mpu_run_self_test_0
   2306                  mpu_set_dmp_state(0);
   \   000018                ; Setup parameters for call to function mpu_set_dmp_state
   \   000018   7900         MOV     R1,#0x0
   \   00001A   12....       LCALL   ??mpu_set_dmp_state?relay
   2307                  dmp_was_on = 1;
   \   00001D   75..01       MOV     ?V0 + 0,#0x1
   \   000020   8003         SJMP    ??mpu_run_self_test_1
   2308              } else
   2309                  dmp_was_on = 0;
   \                     ??mpu_run_self_test_0:
   \   000022   75..00       MOV     ?V0 + 0,#0x0
   2310          
   2311              /* Get initial settings. */
   2312              mpu_get_gyro_fsr(&gyro_fsr);
   \                     ??mpu_run_self_test_1:
   \   000025                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000025   7406         MOV     A,#0x6
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   AA82         MOV     R2,DPL
   \   00002C   AB83         MOV     R3,DPH
   \   00002E   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2313              mpu_get_accel_fsr(&accel_fsr);
   \   000031                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000031   7401         MOV     A,#0x1
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   12....       LCALL   ??mpu_get_accel_fsr?relay
   2314              mpu_get_lpf(&lpf);
   \   00003D                ; Setup parameters for call to function mpu_get_lpf
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   AA82         MOV     R2,DPL
   \   000044   AB83         MOV     R3,DPH
   \   000046   12....       LCALL   ??mpu_get_lpf?relay
   2315              mpu_get_sample_rate(&sample_rate);
   \   000049                ; Setup parameters for call to function mpu_get_sample_rate
   \   000049   7404         MOV     A,#0x4
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   AA82         MOV     R2,DPL
   \   000050   AB83         MOV     R3,DPH
   \   000052   12....       LCALL   ??mpu_get_sample_rate?relay
   2316              sensors_on = st.chip_cfg.sensors;
   \   000055   90....       MOV     DPTR,#st + 6
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5..         MOV     ?V0 + 1,A
   2317              mpu_get_fifo_config(&fifo_sensors);
   \   00005B                ; Setup parameters for call to function mpu_get_fifo_config
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   ??mpu_get_fifo_config?relay
   2318          
   2319              /* For older chips, the self-test will be different. */
   2320          #if defined MPU6050
   2321              for (ii = 0; ii < tries; ii++)
   \   000068   7E00         MOV     R6,#0x0
   \   00006A   7F00         MOV     R7,#0x0
   2322                  if (!get_st_biases(gyro, accel, 0))
   \                     ??mpu_run_self_test_2:
   \   00006C                ; Setup parameters for call to function get_st_biases
   \   00006C   7900         MOV     R1,#0x0
   \   00006E   AC..         MOV     R4,?V0 + 2
   \   000070   AD..         MOV     R5,?V0 + 3
   \   000072   AA..         MOV     R2,?V0 + 4
   \   000074   AB..         MOV     R3,?V0 + 5
   \   000076   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000079   6005         JZ      ??mpu_run_self_test_3
   \   00007B   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00007E   40EC         JC      ??mpu_run_self_test_2
   2323                      break;
   2324              if (ii == tries) {
   \                     ??mpu_run_self_test_3:
   \   000080   7402         MOV     A,#0x2
   \   000082   6E           XRL     A,R6
   \   000083   7001         JNZ     ??mpu_run_self_test_4
   \   000085   EF           MOV     A,R7
   \                     ??mpu_run_self_test_4:
   \   000086   7004         JNZ     ??mpu_run_self_test_5
   2325                  /* If we reach this point, we most likely encountered an I2C error.
   2326                   * We'll just report an error for all three sensors.
   2327                   */
   2328                  result = 0;
   \                     ??mpu_run_self_test_6:
   \   000088   7E00         MOV     R6,#0x0
   2329                  goto restore;
   \   00008A   805B         SJMP    ??mpu_run_self_test_7
   2330              }
   2331              for (ii = 0; ii < tries; ii++)
   \                     ??mpu_run_self_test_5:
   \   00008C   7E00         MOV     R6,#0x0
   \   00008E   7F00         MOV     R7,#0x0
   2332                  if (!get_st_biases(gyro_st, accel_st, 1))
   \                     ??mpu_run_self_test_8:
   \   000090                ; Setup parameters for call to function get_st_biases
   \   000090   7901         MOV     R1,#0x1
   \   000092   7408         MOV     A,#0x8
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   AC82         MOV     R4,DPL
   \   000099   AD83         MOV     R5,DPH
   \   00009B   7414         MOV     A,#0x14
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   0000A7   6005         JZ      ??mpu_run_self_test_9
   \   0000A9   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0000AC   40E2         JC      ??mpu_run_self_test_8
   2333                      break;
   2334              if (ii == tries) {
   \                     ??mpu_run_self_test_9:
   \   0000AE   7402         MOV     A,#0x2
   \   0000B0   6E           XRL     A,R6
   \   0000B1   7001         JNZ     ??mpu_run_self_test_10
   \   0000B3   EF           MOV     A,R7
   \                     ??mpu_run_self_test_10:
   \   0000B4   60D2         JZ      ??mpu_run_self_test_6
   2335                  /* Again, probably an I2C error. */
   2336                  result = 0;
   2337                  goto restore;
   2338              }
   2339              accel_result = accel_self_test(accel, accel_st);
   \   0000B6                ; Setup parameters for call to function accel_self_test
   \   0000B6   7408         MOV     A,#0x8
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   AC82         MOV     R4,DPL
   \   0000BD   AD83         MOV     R5,DPH
   \   0000BF   AA..         MOV     R2,?V0 + 2
   \   0000C1   AB..         MOV     R3,?V0 + 3
   \   0000C3   12....       LCALL   ??accel_self_test?relay
   \   0000C6   EA           MOV     A,R2
   \   0000C7   F5..         MOV     ?V0 + 2,A
   2340              gyro_result = gyro_self_test(gyro, gyro_st);
   \   0000C9                ; Setup parameters for call to function gyro_self_test
   \   0000C9   7414         MOV     A,#0x14
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   AC82         MOV     R4,DPL
   \   0000D0   AD83         MOV     R5,DPH
   \   0000D2   AA..         MOV     R2,?V0 + 4
   \   0000D4   AB..         MOV     R3,?V0 + 5
   \   0000D6   12....       LCALL   ??gyro_self_test?relay
   2341          
   2342              result = 0;
   \   0000D9   7E00         MOV     R6,#0x0
   2343              if (!gyro_result)
   \   0000DB   EA           MOV     A,R2
   \   0000DC   7001         JNZ     ??mpu_run_self_test_11
   2344                  result |= 0x01;
   \   0000DE   0E           INC     R6
   2345              if (!accel_result)
   \                     ??mpu_run_self_test_11:
   \   0000DF   E5..         MOV     A,?V0 + 2
   \   0000E1   7004         JNZ     ??mpu_run_self_test_7
   2346                  result |= 0x02;
   \   0000E3   7402         MOV     A,#0x2
   \   0000E5   4E           ORL     A,R6
   \   0000E6   FE           MOV     R6,A
   2347          
   2348          #ifdef AK89xx_SECONDARY
   2349              compass_result = compass_self_test();
   2350              if (!compass_result)
   2351                  result |= 0x04;
   2352          #endif
   2353          restore:
   2354          #elif defined MPU6500
   2355              /* For now, this function will return a "pass" result for all three sensors
   2356               * for compatibility with current test applications.
   2357               */
   2358              get_st_biases(gyro, accel, 0);
   2359              result = 0x7;
   2360          #endif
   2361              /* Set to invalid values to ensure no I2C writes are skipped. */
   2362              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_run_self_test_7:
   \   0000E7   12....       LCALL   ?Subroutine58 & 0xFFFF
   2363              st.chip_cfg.accel_fsr = 0xFF;
   2364              st.chip_cfg.lpf = 0xFF;
   2365              st.chip_cfg.sample_rate = 0xFFFF;
   2366              st.chip_cfg.sensors = 0xFF;
   2367              st.chip_cfg.fifo_enable = 0xFF;
   2368              st.chip_cfg.clk_src = INV_CLK_PLL;
   2369              mpu_set_gyro_fsr(gyro_fsr);
   \                     ??CrossCallReturnLabel_92:
   \   0000EA                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   0000EA   7406         MOV     A,#0x6
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   12....       LCALL   ?Subroutine49 & 0xFFFF
   2370              mpu_set_accel_fsr(accel_fsr);
   \                     ??CrossCallReturnLabel_75:
   \   0000F2                ; Setup parameters for call to function mpu_set_accel_fsr
   \   0000F2   7401         MOV     A,#0x1
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   F9           MOV     R1,A
   \   0000F9   12....       LCALL   ??mpu_set_accel_fsr?relay
   2371              mpu_set_lpf(lpf);
   \   0000FC                ; Setup parameters for call to function mpu_set_lpf
   \   0000FC   7402         MOV     A,#0x2
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   12....       LCALL   ?Subroutine50 & 0xFFFF
   2372              mpu_set_sample_rate(sample_rate);
   \                     ??CrossCallReturnLabel_77:
   \   000104                ; Setup parameters for call to function mpu_set_sample_rate
   \   000104   7404         MOV     A,#0x4
   \   000106   12....       LCALL   ?XSTACK_DISP0_8
   \   000109   12....       LCALL   ?Subroutine38 & 0xFFFF
   2373              mpu_set_sensors(sensors_on);
   \                     ??CrossCallReturnLabel_44:
   \   00010C                ; Setup parameters for call to function mpu_set_sensors
   \   00010C   A9..         MOV     R1,?V0 + 1
   \   00010E   12....       LCALL   ??mpu_set_sensors?relay
   2374              mpu_configure_fifo(fifo_sensors);
   \   000111                ; Setup parameters for call to function mpu_configure_fifo
   \   000111   85..82       MOV     DPL,?XSP + 0
   \   000114   85..83       MOV     DPH,?XSP + 1
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F9           MOV     R1,A
   \   000119   12....       LCALL   ??mpu_configure_fifo?relay
   2375          
   2376              if (dmp_was_on)
   \   00011C   E5..         MOV     A,?V0 + 0
   \   00011E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000120   5005         JNC     ??mpu_run_self_test_12
   2377                  mpu_set_dmp_state(1);
   \   000122                ; Setup parameters for call to function mpu_set_dmp_state
   \   000122   7901         MOV     R1,#0x1
   \   000124   12....       LCALL   ??mpu_set_dmp_state?relay
   2378          
   2379              return result;
   \                     ??mpu_run_self_test_12:
   \   000127   EE           MOV     A,R6
   \   000128   FA           MOV     R2,A
   \   000129   7B00         MOV     R3,#0x0
   \   00012B   7420         MOV     A,#0x20
   \   00012D   02....       LJMP    ??Subroutine104_0 & 0xFFFF
   2380          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   12....       LCALL   ??get_st_biases?relay
   \   000003   8B..         MOV     ?V0 + 7,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003   9402         SUBB    A,#0x2
   \   000005   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000003   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   90....       MOV     DPTR,#st + 4
   \   000003   74FF         MOV     A,#-0x1
   \   000005   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000008   90....       MOV     DPTR,#st + 6
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   90....       MOV     DPTR,#st + 11
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   90....       MOV     DPTR,#st + 8
   \   000013   7401         MOV     A,#0x1
   \   000015   F0           MOVX    @DPTR,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000003   12....       LCALL   ??mpu_set_lpf?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000003   12....       LCALL   ??mpu_set_gyro_fsr?relay
   \   000006   22           RET
   2381          
   2382          /**
   2383           *  @brief      Write to the DMP memory.
   2384           *  This function prevents I2C writes past the bank boundaries. The DMP memory
   2385           *  is only accessible when the chip is awake.
   2386           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2387           *  @param[in]  length      Number of bytes to write.
   2388           *  @param[in]  data        Bytes to write to memory.
   2389           *  @return     0 if successful.
   2390           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2391          int mpu_write_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_write_mem:
   2392                  unsigned char *data)
   2393          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740E         MOV     A,#0xe
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   12....       LCALL   ?Subroutine44 & 0xFFFF
   2394              unsigned char tmp[2];
   2395          
   2396              if (!data)
   \                     ??CrossCallReturnLabel_58:
   \   000016   7006         JNZ     ??mpu_write_mem_0
   2397                  return -1;
   \                     ??mpu_write_mem_1:
   \   000018   7AFF         MOV     R2,#-0x1
   \   00001A   7BFF         MOV     R3,#-0x1
   \   00001C   804B         SJMP    ??mpu_write_mem_2
   2398              if (!st.chip_cfg.sensors)
   \                     ??mpu_write_mem_0:
   \   00001E   90....       MOV     DPTR,#st + 6
   \   000021   E0           MOVX    A,@DPTR
   \   000022   60F4         JZ      ??mpu_write_mem_1
   2399                  return -1;
   2400          
   2401              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   000024   EB           MOV     A,R3
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   F0           MOVX    @DPTR,A
   2402              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   00002C   7401         MOV     A,#0x1
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine27 & 0xFFFF
   2403          
   2404              /* Check bank boundaries. */
   2405              if (tmp[1] + length > st.hw->bank_size)
   \                     ??CrossCallReturnLabel_29:
   \   000034   C082         PUSH    DPL
   \   000036   C083         PUSH    DPH
   \   000038   7401         MOV     A,#0x1
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   2E           ADD     A,R6
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   3F           ADDC    A,R7
   \   000042   FB           MOV     R3,A
   \   000043   D083         POP     DPH
   \   000045   D082         POP     DPL
   \   000047   C3           CLR     C
   \   000048   E0           MOVX    A,@DPTR
   \   000049   9A           SUBB    A,R2
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   9B           SUBB    A,R3
   \   00004D   40C9         JC      ??mpu_write_mem_1
   2406                  return -1;
   2407          
   2408              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   00004F                ; Setup parameters for call to function I2C_Write
   \   00004F   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000052   70C4         JNZ     ??mpu_write_mem_1
   2409                  return -1;
   2410              if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
   \   000054                ; Setup parameters for call to function I2C_Write
   \   000054   AC..         MOV     R4,?V0 + 0
   \   000056   AD..         MOV     R5,?V0 + 1
   \   000058   EE           MOV     A,R6
   \   000059   FB           MOV     R3,A
   \   00005A   90....       MOV     DPTR,#st
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2415         ADD     A,#0x15
   \   000060   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000063   70B3         JNZ     ??mpu_write_mem_1
   2411                  return -1;
   2412              return 0;
   \   000065   7A00         MOV     R2,#0x0
   \   000067   7B00         MOV     R3,#0x0
   \                     ??mpu_write_mem_2:
   \   000069                REQUIRE ?Subroutine5
   \   000069                ; // Fall through to label ?Subroutine5
   2413          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine129_0
   \   000002                ; // Fall through to label ??Subroutine129_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine130_0
   \   000003                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   E5..         MOV     A,?V0 + 0
   \   000009   45..         ORL     A,?V0 + 1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   7B02         MOV     R3,#0x2
   \   00000C   90....       MOV     DPTR,#st
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   2418         ADD     A,#0x18
   \   000012   F5..         MOV     ?V0 + 2,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   3400         ADDC    A,#0x0
   \   000018   85..82       MOV     DPL,?V0 + 2
   \   00001B   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00001E   12....       LCALL   ??I2C_Write?relay
   \   000021   8B..         MOV     ?V0 + 3,R3
   \   000023   EA           MOV     A,R2
   \   000024   45..         ORL     A,?V0 + 3
   \   000026   22           RET
   2414          
   2415          /**
   2416           *  @brief      Read from the DMP memory.
   2417           *  This function prevents I2C reads past the bank boundaries. The DMP memory
   2418           *  is only accessible when the chip is awake.
   2419           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2420           *  @param[in]  length      Number of bytes to read.
   2421           *  @param[out] data        Bytes read from memory.
   2422           *  @return     0 if successful.
   2423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2424          int mpu_read_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_read_mem:
   2425                  unsigned char *data)
   2426          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740E         MOV     A,#0xe
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   12....       LCALL   ?Subroutine44 & 0xFFFF
   2427              unsigned char tmp[2];
   2428          
   2429              if (!data)
   \                     ??CrossCallReturnLabel_59:
   \   000016   7006         JNZ     ??mpu_read_mem_0
   2430                  return -1;
   \                     ??mpu_read_mem_1:
   \   000018   7AFF         MOV     R2,#-0x1
   \   00001A   7BFF         MOV     R3,#-0x1
   \   00001C   804B         SJMP    ??mpu_read_mem_2
   2431              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_mem_0:
   \   00001E   90....       MOV     DPTR,#st + 6
   \   000021   E0           MOVX    A,@DPTR
   \   000022   60F4         JZ      ??mpu_read_mem_1
   2432                  return -1;
   2433          
   2434              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   000024   EB           MOV     A,R3
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   F0           MOVX    @DPTR,A
   2435              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   00002C   7401         MOV     A,#0x1
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine27 & 0xFFFF
   2436          
   2437              /* Check bank boundaries. */
   2438              if (tmp[1] + length > st.hw->bank_size)
   \                     ??CrossCallReturnLabel_30:
   \   000034   C082         PUSH    DPL
   \   000036   C083         PUSH    DPH
   \   000038   7401         MOV     A,#0x1
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   2E           ADD     A,R6
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   3F           ADDC    A,R7
   \   000042   FB           MOV     R3,A
   \   000043   D083         POP     DPH
   \   000045   D082         POP     DPL
   \   000047   C3           CLR     C
   \   000048   E0           MOVX    A,@DPTR
   \   000049   9A           SUBB    A,R2
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   9B           SUBB    A,R3
   \   00004D   40C9         JC      ??mpu_read_mem_1
   2439                  return -1;
   2440          
   2441              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   00004F                ; Setup parameters for call to function I2C_Write
   \   00004F   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000052   70C4         JNZ     ??mpu_read_mem_1
   2442                  return -1;
   2443              if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
   \   000054                ; Setup parameters for call to function I2C_Read
   \   000054   AC..         MOV     R4,?V0 + 0
   \   000056   AD..         MOV     R5,?V0 + 1
   \   000058   EE           MOV     A,R6
   \   000059   FB           MOV     R3,A
   \   00005A   90....       MOV     DPTR,#st
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2415         ADD     A,#0x15
   \   000060   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000063   70B3         JNZ     ??mpu_read_mem_1
   2444                  return -1;
   2445              return 0;
   \   000065   7A00         MOV     R2,#0x0
   \   000067   7B00         MOV     R3,#0x0
   \                     ??mpu_read_mem_2:
   \   000069   80..         SJMP    ?Subroutine5
   2446          }
   2447          
   2448          /**
   2449           *  @brief      Load and verify DMP image.
   2450           *  @param[in]  length      Length of DMP image.
   2451           *  @param[in]  firmware    DMP code.
   2452           *  @param[in]  start_addr  Starting address of DMP code memory.
   2453           *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
   2454           *  @return     0 if successful.
   2455           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2456          int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
   \                     mpu_load_firmware:
   2457              unsigned short start_addr, unsigned short sample_rate)
   2458          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   \   000012   7428         MOV     A,#0x28
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00001A   742A         MOV     A,#0x2a
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 6,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 7,A
   2459              unsigned short ii;
   2460              unsigned short this_write;
   2461              /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
   2462          #define LOAD_CHUNK  (16)
   2463              unsigned char cur[LOAD_CHUNK], tmp[2];
   2464          
   2465              if (st.chip_cfg.dmp_loaded)
   \   000026   90....       MOV     DPTR,#st + 30
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6007         JZ      ??mpu_load_firmware_0
   2466                  /* DMP should only be loaded once. */
   2467                  return -1;
   \                     ??mpu_load_firmware_1:
   \   00002C   7AFF         MOV     R2,#-0x1
   \                     ??mpu_load_firmware_2:
   \   00002E   7BFF         MOV     R3,#-0x1
   \   000030   02....       LJMP    ??CrossCallReturnLabel_250 & 0xFFFF
   2468          
   2469              if (!firmware)
   \                     ??mpu_load_firmware_0:
   \   000033   EC           MOV     A,R4
   \   000034   45..         ORL     A,?V0 + 5
   \   000036   60F4         JZ      ??mpu_load_firmware_1
   2470                  return -1;
   2471              for (ii = 0; ii < length; ii += this_write) {
   \   000038   7E00         MOV     R6,#0x0
   \   00003A   7F00         MOV     R7,#0x0
   \   00003C   8008         SJMP    ??mpu_load_firmware_3
   \                     ??mpu_load_firmware_4:
   \   00003E   EE           MOV     A,R6
   \   00003F   25..         ADD     A,?V0 + 10
   \   000041   FE           MOV     R6,A
   \   000042   EF           MOV     A,R7
   \   000043   35..         ADDC    A,?V0 + 11
   \   000045   FF           MOV     R7,A
   \                     ??mpu_load_firmware_3:
   \   000046   C3           CLR     C
   \   000047   EE           MOV     A,R6
   \   000048   95..         SUBB    A,?V0 + 2
   \   00004A   EF           MOV     A,R7
   \   00004B   95..         SUBB    A,?V0 + 3
   \   00004D   4003         JC      $+5
   \   00004F   02....       LJMP    ??mpu_load_firmware_5 & 0xFFFF
   2472                  this_write = min(LOAD_CHUNK, length - ii);
   \   000052   E5..         MOV     A,?V0 + 2
   \   000054   C3           CLR     C
   \   000055   9E           SUBB    A,R6
   \   000056   F8           MOV     R0,A
   \   000057   E5..         MOV     A,?V0 + 3
   \   000059   9F           SUBB    A,R7
   \   00005A   F9           MOV     R1,A
   \   00005B   C3           CLR     C
   \   00005C   E8           MOV     A,R0
   \   00005D   9411         SUBB    A,#0x11
   \   00005F   E9           MOV     A,R1
   \   000060   9400         SUBB    A,#0x0
   \   000062   4008         JC      ??mpu_load_firmware_6
   \   000064   75..10       MOV     ?V0 + 10,#0x10
   \   000067   75..00       MOV     ?V0 + 11,#0x0
   \   00006A   8004         SJMP    ??mpu_load_firmware_7
   \                     ??mpu_load_firmware_6:
   \   00006C   88..         MOV     ?V0 + 10,R0
   \   00006E   89..         MOV     ?V0 + 11,R1
   2473                  if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
   \                     ??mpu_load_firmware_7:
   \   000070   E5..         MOV     A,?V0 + 4
   \   000072   2E           ADD     A,R6
   \   000073   F5..         MOV     ?V0 + 12,A
   \   000075   E5..         MOV     A,?V0 + 5
   \   000077   3F           ADDC    A,R7
   \   000078   F5..         MOV     ?V0 + 13,A
   \   00007A                ; Setup parameters for call to function mpu_write_mem
   \   00007A   78..         MOV     R0,#?V0 + 12
   \   00007C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007F   AC..         MOV     R4,?V0 + 10
   \   000081   AD..         MOV     R5,?V0 + 11
   \   000083   EE           MOV     A,R6
   \   000084   FA           MOV     R2,A
   \   000085   EF           MOV     A,R7
   \   000086   FB           MOV     R3,A
   \   000087   12....       LCALL   ??mpu_write_mem?relay
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   8B..         MOV     ?V0 + 9,R3
   \   000091   EA           MOV     A,R2
   \   000092   45..         ORL     A,?V0 + 9
   \   000094   7096         JNZ     ??mpu_load_firmware_1
   2474                      return -1;
   2475                  if (mpu_read_mem(ii, this_write, cur))
   \   000096                ; Setup parameters for call to function mpu_read_mem
   \   000096   7402         MOV     A,#0x2
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   8582..       MOV     ?V0 + 8,DPL
   \   00009E   8583..       MOV     ?V0 + 9,DPH
   \   0000A1   78..         MOV     R0,#?V0 + 8
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A6   AC..         MOV     R4,?V0 + 10
   \   0000A8   AD..         MOV     R5,?V0 + 11
   \   0000AA   EE           MOV     A,R6
   \   0000AB   FA           MOV     R2,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   FB           MOV     R3,A
   \   0000AE   12....       LCALL   ??mpu_read_mem?relay
   \   0000B1   7402         MOV     A,#0x2
   \   0000B3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B6   8B..         MOV     ?V0 + 9,R3
   \   0000B8   EA           MOV     A,R2
   \   0000B9   45..         ORL     A,?V0 + 9
   \   0000BB   6003         JZ      $+5
   \   0000BD   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2476                      return -1;
   2477                  if (memcmp(firmware+ii, cur, this_write))
   \   0000C0                ; Setup parameters for call to function memcmp
   \   0000C0   78..         MOV     R0,#?V0 + 10
   \   0000C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C5   7404         MOV     A,#0x4
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   AC82         MOV     R4,DPL
   \   0000CC   AD83         MOV     R5,DPH
   \   0000CE   AA..         MOV     R2,?V0 + 12
   \   0000D0   AB..         MOV     R3,?V0 + 13
   \   0000D2   12....       LCALL   ??memcmp?relay
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DA   8B..         MOV     ?V0 + 9,R3
   \   0000DC   EA           MOV     A,R2
   \   0000DD   45..         ORL     A,?V0 + 9
   \   0000DF   7003         JNZ     $+5
   \   0000E1   02....       LJMP    ??mpu_load_firmware_4 & 0xFFFF
   2478                      return -2;
   \   0000E4   7AFE         MOV     R2,#-0x2
   \   0000E6   02....       LJMP    ??mpu_load_firmware_2 & 0xFFFF
   2479              }
   2480          
   2481              /* Set program start address. */
   2482              tmp[0] = start_addr >> 8;
   \                     ??mpu_load_firmware_5:
   \   0000E9   85..82       MOV     DPL,?XSP + 0
   \   0000EC   85..83       MOV     DPH,?XSP + 1
   \   0000EF   E5..         MOV     A,?V0 + 1
   \   0000F1   F0           MOVX    @DPTR,A
   2483              tmp[1] = start_addr & 0xFF;
   \   0000F2   7401         MOV     A,#0x1
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E5..         MOV     A,?V0 + 0
   \   0000F9   12....       LCALL   ?Subroutine60 & 0xFFFF
   2484              if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
   \                     ??CrossCallReturnLabel_94:
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   241A         ADD     A,#0x1a
   \   0000FF   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000102   6003         JZ      $+5
   \   000104   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2485                  return -1;
   2486          
   2487              st.chip_cfg.dmp_loaded = 1;
   \   000107   90....       MOV     DPTR,#st + 30
   \   00010A   7401         MOV     A,#0x1
   \   00010C   F0           MOVX    @DPTR,A
   2488              st.chip_cfg.dmp_sample_rate = sample_rate;
   \   00010D   A3           INC     DPTR
   \   00010E   E5..         MOV     A,?V0 + 6
   \   000110   F0           MOVX    @DPTR,A
   \   000111   A3           INC     DPTR
   \   000112   E5..         MOV     A,?V0 + 7
   \   000114   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   2489              return 0;
   \                     ??CrossCallReturnLabel_250:
   \   000117   7412         MOV     A,#0x12
   \   000119   02....       LJMP    ?Subroutine7 & 0xFFFF
   2490          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000003   7B02         MOV     R3,#0x2
   \   000005   90....       MOV     DPTR,#st
   \   000008   22           RET
   2491          
   2492          /**
   2493           *  @brief      Enable/disable DMP support.
   2494           *  @param[in]  enable  1 to turn on the DMP.
   2495           *  @return     0 if successful.
   2496           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2497          int mpu_set_dmp_state(unsigned char enable)
   \                     mpu_set_dmp_state:
   2498          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2499              unsigned char tmp;
   2500              if (st.chip_cfg.dmp_on == enable)
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   700C         JNZ     ??mpu_set_dmp_state_0
   2501                  return 0;
   \                     ??mpu_set_dmp_state_1:
   \   000013   7A00         MOV     R2,#0x0
   \   000015   7B00         MOV     R3,#0x0
   \                     ??mpu_set_dmp_state_2:
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001C   02....       LJMP    ?Subroutine4 & 0xFFFF
   2502          
   2503              if (enable) {
   \                     ??mpu_set_dmp_state_0:
   \   00001F   EE           MOV     A,R6
   \   000020   6030         JZ      ??mpu_set_dmp_state_3
   2504                  if (!st.chip_cfg.dmp_loaded)
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   7006         JNZ     ??mpu_set_dmp_state_4
   2505                      return -1;
   \   000026   7AFF         MOV     R2,#-0x1
   \   000028   7BFF         MOV     R3,#-0x1
   \   00002A   80EB         SJMP    ??mpu_set_dmp_state_2
   2506                  /* Disable data ready interrupt. */
   2507                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_4:
   \   00002C                ; Setup parameters for call to function set_int_enable
   \   00002C   7900         MOV     R1,#0x0
   \   00002E   12....       LCALL   ??set_int_enable?relay
   2508                  /* Disable bypass mode. */
   2509                  mpu_set_bypass(0);
   \   000031                ; Setup parameters for call to function mpu_set_bypass
   \   000031   7900         MOV     R1,#0x0
   \   000033   12....       LCALL   ??mpu_set_bypass?relay
   2510                  /* Keep constant sample rate, FIFO rate controlled by DMP. */
   2511                  mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
   \   000036                ; Setup parameters for call to function mpu_set_sample_rate
   \   000036   90....       MOV     DPTR,#st + 31
   \   000039   12....       LCALL   ?Subroutine38 & 0xFFFF
   2512                  /* Remove FIFO elements. */
   2513                  tmp = 0;
   \                     ??CrossCallReturnLabel_45:
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   E4           CLR     A
   \   000043   12....       LCALL   ?Subroutine29 & 0xFFFF
   2514                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2515                  st.chip_cfg.dmp_on = 1;
   \                     ??CrossCallReturnLabel_33:
   \   000046   7401         MOV     A,#0x1
   \   000048   F0           MOVX    @DPTR,A
   2516                  /* Enable DMP interrupt. */
   2517                  set_int_enable(1);
   \   000049                ; Setup parameters for call to function set_int_enable
   \   000049   F9           MOV     R1,A
   \   00004A   12....       LCALL   ??set_int_enable?relay
   2518                  mpu_reset_fifo();
   \   00004D                ; Setup parameters for call to function mpu_reset_fifo
   \                     ??mpu_set_dmp_state_5:
   \   00004D   12....       LCALL   ??mpu_reset_fifo?relay
   \   000050   80C1         SJMP    ??mpu_set_dmp_state_1
   2519              } else {
   2520                  /* Disable DMP interrupt. */
   2521                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_3:
   \   000052                ; Setup parameters for call to function set_int_enable
   \   000052   7900         MOV     R1,#0x0
   \   000054   12....       LCALL   ??set_int_enable?relay
   2522                  /* Restore FIFO settings. */
   2523                  tmp = st.chip_cfg.fifo_enable;
   \   000057   90....       MOV     DPTR,#st + 11
   \   00005A   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   00005D   12....       LCALL   ?Subroutine29 & 0xFFFF
   2524                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2525                  st.chip_cfg.dmp_on = 0;
   \                     ??CrossCallReturnLabel_34:
   \   000060   E4           CLR     A
   \   000061   F0           MOVX    @DPTR,A
   2526                  mpu_reset_fifo();
   \   000062                ; Setup parameters for call to function mpu_reset_fifo
   \   000062   80E9         SJMP    ??mpu_set_dmp_state_5
   2527              }
   2528              return 0;
   2529          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000003   7A23         MOV     R2,#0x23
   \   000005   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   000008   90....       MOV     DPTR,#st + 29
   \   00000B   22           RET
   2530          
   2531          /**
   2532           *  @brief      Get DMP state.
   2533           *  @param[out] enabled 1 if enabled.
   2534           *  @return     0 if successful.
   2535           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2536          int mpu_get_dmp_state(unsigned char *enabled)
   \                     mpu_get_dmp_state:
   2537          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2538              enabled[0] = st.chip_cfg.dmp_on;
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   02....       LJMP    ?Subroutine1 & 0xFFFF
   2539              return 0;
   2540          }
   2541          
   2542          
   2543          /* This initialization is similar to the one in ak8975.c. */
   2544          //static int setup_compass(void)
   2545          //{
   2546          //#ifdef AK89xx_SECONDARY
   2547          //    unsigned char data[4], akm_addr;
   2548          //
   2549          //    mpu_set_bypass(1);
   2550          //
   2551          //    /* Find compass. Possible addresses range from 0x0C to 0x0F. */
   2552          //    for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
   2553          //        int result;
   2554          //        result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
   2555          //        if (!result && (data[0] == AKM_WHOAMI))
   2556          //            break;
   2557          //    }
   2558          //
   2559          //    if (akm_addr > 0x0F) {
   2560          //        /* TODO: Handle this case in all compass-related functions. */
   2561          //        log_e("Compass not found.\n");
   2562          //        return -1;
   2563          //    }
   2564          //
   2565          //    st.chip_cfg.compass_addr = akm_addr;
   2566          //
   2567          //    data[0] = AKM_POWER_DOWN;
   2568          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2569          //        return -1;
   2570          //    delay_ms(1);
   2571          //
   2572          //    data[0] = AKM_FUSE_ROM_ACCESS;
   2573          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2574          //        return -1;
   2575          //    delay_ms(1);
   2576          //
   2577          //    /* Get sensitivity adjustment data from fuse ROM. */
   2578          //    if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
   2579          //        return -1;
   2580          //    st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
   2581          //    st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
   2582          //    st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
   2583          //
   2584          //    data[0] = AKM_POWER_DOWN;
   2585          //    if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2586          //        return -1;
   2587          //    delay_ms(1);
   2588          //
   2589          //    mpu_set_bypass(0);
   2590          //
   2591          //    /* Set up master mode, master clock, and ES bit. */
   2592          //    data[0] = 0x40;
   2593          //    if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   2594          //        return -1;
   2595          //
   2596          //    /* Slave 0 reads from AKM data registers. */
   2597          //    data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
   2598          //    if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
   2599          //        return -1;
   2600          //
   2601          //    /* Compass reads start at this register. */
   2602          //    data[0] = AKM_REG_ST1;
   2603          //    if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
   2604          //        return -1;
   2605          //
   2606          //    /* Enable slave 0, 8-byte reads. */
   2607          //    data[0] = BIT_SLAVE_EN | 8;
   2608          //    if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
   2609          //        return -1;
   2610          //
   2611          //    /* Slave 1 changes AKM measurement mode. */
   2612          //    data[0] = st.chip_cfg.compass_addr;
   2613          //    if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
   2614          //        return -1;
   2615          //
   2616          //    /* AKM measurement mode register. */
   2617          //    data[0] = AKM_REG_CNTL;
   2618          //    if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
   2619          //        return -1;
   2620          //
   2621          //    /* Enable slave 1, 1-byte writes. */
   2622          //    data[0] = BIT_SLAVE_EN | 1;
   2623          //    if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
   2624          //        return -1;
   2625          //
   2626          //    /* Set slave 1 data. */
   2627          //    data[0] = AKM_SINGLE_MEASUREMENT;
   2628          //    if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
   2629          //        return -1;
   2630          //
   2631          //    /* Trigger slave 0 and slave 1 actions at each sample. */
   2632          //    data[0] = 0x03;
   2633          //    if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
   2634          //        return -1;
   2635          //
   2636          //#ifdef MPU9150
   2637          //    /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
   2638          //    data[0] = BIT_I2C_MST_VDDIO;
   2639          //    if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
   2640          //        return -1;
   2641          //#endif
   2642          //
   2643          //    return 0;
   2644          //#else
   2645          //    return -1;
   2646          //#endif
   2647          //}
   2648          
   2649          /**
   2650           *  @brief      Read raw compass data.
   2651           *  @param[out] data        Raw data in hardware units.
   2652           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   2653           *  @return     0 if successful.
   2654           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2655          int mpu_get_compass_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_compass_reg:
   2656          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2657          #ifdef AK89xx_SECONDARY
   2658              unsigned char tmp[9];
   2659          
   2660              if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   2661                  return -1;
   2662          
   2663          #ifdef AK89xx_BYPASS
   2664              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
   2665                  return -1;
   2666              tmp[8] = AKM_SINGLE_MEASUREMENT;
   2667              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
   2668                  return -1;
   2669          #else
   2670              if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
   2671                  return -1;
   2672          #endif
   2673          
   2674          #if defined AK8975_SECONDARY
   2675              /* AK8975 doesn't have the overrun error bit. */
   2676              if (!(tmp[0] & AKM_DATA_READY))
   2677                  return -2;
   2678              if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
   2679                  return -3;
   2680          #elif defined AK8963_SECONDARY
   2681              /* AK8963 doesn't have the data read error bit. */
   2682              if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
   2683                  return -2;
   2684              if (tmp[7] & AKM_OVERFLOW)
   2685                  return -3;
   2686          #endif
   2687              data[0] = (tmp[2] << 8) | tmp[1];
   2688              data[1] = (tmp[4] << 8) | tmp[3];
   2689              data[2] = (tmp[6] << 8) | tmp[5];
   2690          
   2691              data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
   2692              data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
   2693              data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
   2694          
   2695              if (timestamp)
   2696                  get_ms(timestamp);
   2697              return 0;
   2698          #else
   2699              return -1;
   \   000000   02....       LJMP    ?Subroutine2 & 0xFFFF
   2700          #endif
   2701          }
   2702          
   2703          /**
   2704           *  @brief      Get the compass full-scale range.
   2705           *  @param[out] fsr Current full-scale range.
   2706           *  @return     0 if successful.
   2707           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2708          int mpu_get_compass_fsr(unsigned short *fsr)
   \                     mpu_get_compass_fsr:
   2709          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2710          #ifdef AK89xx_SECONDARY
   2711              fsr[0] = st.hw->compass_fsr;
   2712              return 0;
   2713          #else
   2714              return -1;
   \   000000   02....       LJMP    ?Subroutine2 & 0xFFFF
   2715          #endif
   2716          }
   2717          
   2718          /**
   2719           *  @brief      Enters LP accel motion interrupt mode.
   2720           *  The behavior of this feature is very different between the MPU6050 and the
   2721           *  MPU6500. Each chip's version of this feature is explained below.
   2722           *
   2723           *  \n MPU6050:
   2724           *  \n When this mode is first enabled, the hardware captures a single accel
   2725           *  sample, and subsequent samples are compared with this one to determine if
   2726           *  the device is in motion. Therefore, whenever this "locked" sample needs to
   2727           *  be changed, this function must be called again.
   2728           *
   2729           *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
   2730           *  increments.
   2731           *
   2732           *  \n Low-power accel mode supports the following frequencies:
   2733           *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
   2734           *
   2735           *  \n MPU6500:
   2736           *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
   2737           *  sample. The hardware monitors the accel data and detects any large change
   2738           *  over a short period of time.
   2739           *
   2740           *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
   2741           *  increments.
   2742           *
   2743           *  \n MPU6500 Low-power accel mode supports the following frequencies:
   2744           *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
   2745           *
   2746           *  \n\n NOTES:
   2747           *  \n The driver will round down @e thresh to the nearest supported value if
   2748           *  an unsupported threshold is selected.
   2749           *  \n To select a fractional wake-up frequency, round down the value passed to
   2750           *  @e lpa_freq.
   2751           *  \n The MPU6500 does not support a delay parameter. If this function is used
   2752           *  for the MPU6500, the value passed to @e time will be ignored.
   2753           *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
   2754           *  the previous configuration.
   2755           *
   2756           *  @param[in]  thresh      Motion threshold in mg.
   2757           *  @param[in]  time        Duration in milliseconds that the accel data must
   2758           *                          exceed @e thresh before motion is reported.
   2759           *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
   2760           *  @return     0 if successful.
   2761           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2762          int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
   \                     mpu_lp_motion_interrupt:
   2763              unsigned char lpa_freq)
   2764          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
   2765              unsigned char data[3];
   2766          
   2767              if (lpa_freq) {
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??mpu_lp_motion_interrupt_0 & 0xFFFF
   2768                  unsigned char thresh_hw;
   2769          
   2770          #if defined MPU6050
   2771                  /* TODO: Make these const/#defines. */
   2772                  /* 1LSb = 32mg. */
   2773                  if (thresh > 8160)
   \   000013   C3           CLR     C
   \   000014   EA           MOV     A,R2
   \   000015   94E1         SUBB    A,#-0x1f
   \   000017   EB           MOV     A,R3
   \   000018   941F         SUBB    A,#0x1f
   \   00001A   4005         JC      ??mpu_lp_motion_interrupt_1
   2774                      thresh_hw = 255;
   \   00001C   75..FF       MOV     ?V0 + 0,#-0x1
   \   00001F   8019         SJMP    ??mpu_lp_motion_interrupt_2
   2775                  else if (thresh < 32)
   \                     ??mpu_lp_motion_interrupt_1:
   \   000021   C3           CLR     C
   \   000022   EA           MOV     A,R2
   \   000023   9420         SUBB    A,#0x20
   \   000025   EB           MOV     A,R3
   \   000026   9400         SUBB    A,#0x0
   \   000028   5005         JNC     ??mpu_lp_motion_interrupt_3
   2776                      thresh_hw = 1;
   \   00002A   75..01       MOV     ?V0 + 0,#0x1
   \   00002D   800B         SJMP    ??mpu_lp_motion_interrupt_2
   2777                  else
   2778                      thresh_hw = thresh >> 5;
   \                     ??mpu_lp_motion_interrupt_3:
   \   00002F   8A..         MOV     ?V0 + 0,R2
   \   000031   8B..         MOV     ?V0 + 1,R3
   \   000033   7405         MOV     A,#0x5
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?US_SHR
   2779          #elif defined MPU6500
   2780                  /* 1LSb = 4mg. */
   2781                  if (thresh > 1020)
   2782                      thresh_hw = 255;
   2783                  else if (thresh < 4)
   2784                      thresh_hw = 1;
   2785                  else
   2786                      thresh_hw = thresh >> 2;
   2787          #endif
   2788          
   2789                  if (!time)
   \                     ??mpu_lp_motion_interrupt_2:
   \   00003A   EF           MOV     A,R7
   \   00003B   7002         JNZ     ??mpu_lp_motion_interrupt_4
   2790                      /* Minimum duration must be 1ms. */
   2791                      time = 1;
   \   00003D   7F01         MOV     R7,#0x1
   2792          
   2793          #if defined MPU6050
   2794                  if (lpa_freq > 40)
   \                     ??mpu_lp_motion_interrupt_4:
   \   00003F   EE           MOV     A,R6
   \   000040   C3           CLR     C
   \   000041   9429         SUBB    A,#0x29
   \   000043   4007         JC      ??mpu_lp_motion_interrupt_5
   2795          #elif defined MPU6500
   2796                  if (lpa_freq > 640)
   2797          #endif
   2798                      /* At this point, the chip has not been re-configured, so the
   2799                       * function can safely exit.
   2800                       */
   2801                      return -1;
   \                     ??mpu_lp_motion_interrupt_6:
   \   000045   7AFF         MOV     R2,#-0x1
   \   000047   7BFF         MOV     R3,#-0x1
   \   000049   02....       LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
   2802          
   2803                  if (!st.chip_cfg.int_motion_only) {
   \                     ??mpu_lp_motion_interrupt_5:
   \   00004C   90....       MOV     DPTR,#st + 16
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   7042         JNZ     ??mpu_lp_motion_interrupt_8
   2804                      /* Store current settings for later. */
   2805                      if (st.chip_cfg.dmp_on) {
   \   000052   90....       MOV     DPTR,#st + 29
   \   000055   E0           MOVX    A,@DPTR
   \   000056   600C         JZ      ??mpu_lp_motion_interrupt_9
   2806                          mpu_set_dmp_state(0);
   \   000058                ; Setup parameters for call to function mpu_set_dmp_state
   \   000058   7900         MOV     R1,#0x0
   \   00005A   12....       LCALL   ??mpu_set_dmp_state?relay
   2807                          st.chip_cfg.cache.dmp_on = 1;
   \   00005D   90....       MOV     DPTR,#st + 26
   \   000060   7401         MOV     A,#0x1
   \   000062   8004         SJMP    ??mpu_lp_motion_interrupt_10
   2808                      } else
   2809                          st.chip_cfg.cache.dmp_on = 0;
   \                     ??mpu_lp_motion_interrupt_9:
   \   000064   90....       MOV     DPTR,#st + 26
   \   000067   E4           CLR     A
   \                     ??mpu_lp_motion_interrupt_10:
   \   000068   F0           MOVX    @DPTR,A
   2810                      mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
   \   000069                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000069   7A..         MOV     R2,#(st + 17) & 0xff
   \   00006B   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   00006D   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2811                      mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
   \   000070                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000070   7A..         MOV     R2,#(st + 19) & 0xff
   \   000072   7B..         MOV     R3,#((st + 19) >> 8) & 0xff
   \   000074   12....       LCALL   ??mpu_get_accel_fsr?relay
   2812                      mpu_get_lpf(&st.chip_cfg.cache.lpf);
   \   000077                ; Setup parameters for call to function mpu_get_lpf
   \   000077   7A..         MOV     R2,#(st + 20) & 0xff
   \   000079   7B..         MOV     R3,#((st + 20) >> 8) & 0xff
   \   00007B   12....       LCALL   ??mpu_get_lpf?relay
   2813                      mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
   \   00007E                ; Setup parameters for call to function mpu_get_sample_rate
   \   00007E   7A..         MOV     R2,#(st + 22) & 0xff
   \   000080   7B..         MOV     R3,#((st + 22) >> 8) & 0xff
   \   000082   12....       LCALL   ??mpu_get_sample_rate?relay
   2814                      st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
   \   000085   90....       MOV     DPTR,#st + 6
   \   000088   E0           MOVX    A,@DPTR
   \   000089   90....       MOV     DPTR,#st + 24
   \   00008C   F0           MOVX    @DPTR,A
   2815                      mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
   \   00008D                ; Setup parameters for call to function mpu_get_fifo_config
   \   00008D   7A..         MOV     R2,#(st + 25) & 0xff
   \   00008F   7B..         MOV     R3,#((st + 25) >> 8) & 0xff
   \   000091   12....       LCALL   ??mpu_get_fifo_config?relay
   2816                  }
   2817          
   2818          #ifdef MPU6050
   2819                  /* Disable hardware interrupts for now. */
   2820                  set_int_enable(0);
   \                     ??mpu_lp_motion_interrupt_8:
   \   000094                ; Setup parameters for call to function set_int_enable
   \   000094   7900         MOV     R1,#0x0
   \   000096   12....       LCALL   ??set_int_enable?relay
   2821          
   2822                  /* Enter full-power accel-only mode. */
   2823                  mpu_lp_accel_mode(0);
   \   000099                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000099   7900         MOV     R1,#0x0
   \   00009B   12....       LCALL   ??mpu_lp_accel_mode?relay
   2824          
   2825                  /* Override current LPF (and HPF) settings to obtain a valid accel
   2826                   * reading.
   2827                   */
   2828                  data[0] = INV_FILTER_256HZ_NOLPF2;
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   E4           CLR     A
   \   0000A5   12....       LCALL   ?Subroutine35 & 0xFFFF
   2829                  if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \                     ??CrossCallReturnLabel_201:
   \   0000A8   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000AB   7098         JNZ     ??mpu_lp_motion_interrupt_6
   2830                      return -1;
   2831          
   2832                  /* NOTE: Digital high pass filter should be configured here. Since this
   2833                   * driver doesn't modify those bits anywhere, they should already be
   2834                   * cleared by default.
   2835                   */
   2836          
   2837                  /* Configure the device to send motion interrupts. */
   2838                  /* Enable motion interrupt. */
   2839                  data[0] = BIT_MOT_INT_EN;
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   7440         MOV     A,#0x40
   \   0000B5   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   2840                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \                     ??CrossCallReturnLabel_258:
   \   0000B8   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   0000BB   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   0000BE   6003         JZ      $+5
   \   0000C0   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2841                      goto lp_int_restore;
   2842          
   2843                  /* Set motion interrupt parameters. */
   2844                  data[0] = thresh_hw;
   \   0000C3   85..82       MOV     DPL,?XSP + 0
   \   0000C6   85..83       MOV     DPH,?XSP + 1
   \   0000C9   E5..         MOV     A,?V0 + 0
   \   0000CB   F0           MOVX    @DPTR,A
   2845                  data[1] = time;
   \   0000CC   7401         MOV     A,#0x1
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   EF           MOV     A,R7
   \   0000D2   12....       LCALL   ?Subroutine60 & 0xFFFF
   2846                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
   \                     ??CrossCallReturnLabel_95:
   \   0000D5   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   0000D8   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   0000DB   6003         JZ      $+5
   \   0000DD   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2847                      goto lp_int_restore;
   2848          
   2849                  /* Force hardware to "lock" current accel sample. */
   2850                  delay_ms(5);
   \   0000E0                ; Setup parameters for call to function delay_ms
   \   0000E0   7A05         MOV     R2,#0x5
   \   0000E2   7B00         MOV     R3,#0x0
   \   0000E4   12....       LCALL   ??delay_ms?relay
   2851                  data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
   \   0000E7   90....       MOV     DPTR,#st + 5
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   33           RLC     A
   \   0000EC   33           RLC     A
   \   0000ED   33           RLC     A
   \   0000EE   54F8         ANL     A,#0xf8
   \   0000F0   4407         ORL     A,#0x7
   \   0000F2   85..82       MOV     DPL,?XSP + 0
   \   0000F5   85..83       MOV     DPH,?XSP + 1
   \   0000F8   12....       LCALL   ?Subroutine23 & 0xFFFF
   2852                  if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??CrossCallReturnLabel_213:
   \   0000FB   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   0000FE   7075         JNZ     ??mpu_lp_motion_interrupt_11
   2853                      goto lp_int_restore;
   2854          
   2855                  /* Set up LP accel mode. */
   2856                  data[0] = BIT_LPA_CYCLE;
   \   000100   85..82       MOV     DPL,?XSP + 0
   \   000103   85..83       MOV     DPH,?XSP + 1
   \   000106   7420         MOV     A,#0x20
   \   000108   F0           MOVX    @DPTR,A
   2857                  if (lpa_freq == 1)
   \   000109   7401         MOV     A,#0x1
   \   00010B   6E           XRL     A,R6
   \   00010C   7008         JNZ     ??mpu_lp_motion_interrupt_12
   2858                      data[1] = INV_LPA_1_25HZ;
   \   00010E   7401         MOV     A,#0x1
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   E4           CLR     A
   \   000114   8023         SJMP    ??mpu_lp_motion_interrupt_13
   2859                  else if (lpa_freq <= 5)
   \                     ??mpu_lp_motion_interrupt_12:
   \   000116   EE           MOV     A,R6
   \   000117   C3           CLR     C
   \   000118   9406         SUBB    A,#0x6
   \   00011A   5009         JNC     ??mpu_lp_motion_interrupt_14
   2860                      data[1] = INV_LPA_5HZ;
   \   00011C   7401         MOV     A,#0x1
   \   00011E   12....       LCALL   ?XSTACK_DISP0_8
   \   000121   7401         MOV     A,#0x1
   \   000123   8014         SJMP    ??mpu_lp_motion_interrupt_13
   2861                  else if (lpa_freq <= 20)
   \                     ??mpu_lp_motion_interrupt_14:
   \   000125   EE           MOV     A,R6
   \   000126   C3           CLR     C
   \   000127   9415         SUBB    A,#0x15
   \   000129   7401         MOV     A,#0x1
   \   00012B   5007         JNC     ??mpu_lp_motion_interrupt_15
   2862                      data[1] = INV_LPA_20HZ;
   \   00012D   12....       LCALL   ?XSTACK_DISP0_8
   \   000130   7402         MOV     A,#0x2
   \   000132   8005         SJMP    ??mpu_lp_motion_interrupt_13
   2863                  else
   2864                      data[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_motion_interrupt_15:
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   7403         MOV     A,#0x3
   \                     ??mpu_lp_motion_interrupt_13:
   \   000139   F0           MOVX    @DPTR,A
   2865                  data[1] = (data[1] << 6) | BIT_STBY_XYZG;
   \   00013A   7401         MOV     A,#0x1
   \   00013C   12....       LCALL   ?XSTACK_DISP0_8
   \   00013F   12....       LCALL   ?Subroutine10 & 0xFFFF
   2866                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \                     ??CrossCallReturnLabel_273:
   \   000142   7031         JNZ     ??mpu_lp_motion_interrupt_11
   2867                      goto lp_int_restore;
   2868          
   2869                  st.chip_cfg.int_motion_only = 1;
   \   000144   90....       MOV     DPTR,#st + 16
   \   000147   7401         MOV     A,#0x1
   \   000149   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   2870                  return 0;
   2871          #elif defined MPU6500
   2872                  /* Disable hardware interrupts. */
   2873                  set_int_enable(0);
   2874          
   2875                  /* Enter full-power accel-only mode, no FIFO/DMP. */
   2876                  data[0] = 0;
   2877                  data[1] = 0;
   2878                  data[2] = BIT_STBY_XYZG;
   2879                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
   2880                      goto lp_int_restore;
   2881          
   2882                  /* Set motion threshold. */
   2883                  data[0] = thresh_hw;
   2884                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
   2885                      goto lp_int_restore;
   2886          
   2887                  /* Set wake frequency. */
   2888                  if (lpa_freq == 1)
   2889                      data[0] = INV_LPA_1_25HZ;
   2890                  else if (lpa_freq == 2)
   2891                      data[0] = INV_LPA_2_5HZ;
   2892                  else if (lpa_freq <= 5)
   2893                      data[0] = INV_LPA_5HZ;
   2894                  else if (lpa_freq <= 10)
   2895                      data[0] = INV_LPA_10HZ;
   2896                  else if (lpa_freq <= 20)
   2897                      data[0] = INV_LPA_20HZ;
   2898                  else if (lpa_freq <= 40)
   2899                      data[0] = INV_LPA_40HZ;
   2900                  else if (lpa_freq <= 80)
   2901                      data[0] = INV_LPA_80HZ;
   2902                  else if (lpa_freq <= 160)
   2903                      data[0] = INV_LPA_160HZ;
   2904                  else if (lpa_freq <= 320)
   2905                      data[0] = INV_LPA_320HZ;
   2906                  else
   2907                      data[0] = INV_LPA_640HZ;
   2908                  if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
   2909                      goto lp_int_restore;
   2910          
   2911                  /* Enable motion interrupt (MPU6500 version). */
   2912                  data[0] = BITS_WOM_EN;
   2913                  if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2914                      goto lp_int_restore;
   2915          
   2916                  /* Enable cycle mode. */
   2917                  data[0] = BIT_LPA_CYCLE;
   2918                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   2919                      goto lp_int_restore;
   2920          
   2921                  /* Enable interrupt. */
   2922                  data[0] = BIT_MOT_INT_EN;
   2923                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   2924                      goto lp_int_restore;
   2925          
   2926                  st.chip_cfg.int_motion_only = 1;
   2927                  return 0;
   2928          #endif
   2929              } else {
   \                     ??CrossCallReturnLabel_251:
   \   00014C   8066         SJMP    ??mpu_lp_motion_interrupt_7
   2930                  /* Don't "restore" the previous state if no state has been saved. */
   2931                  int ii;
   2932                  char *cache_ptr = (char*)&st.chip_cfg.cache;
   2933                  for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
   \                     ??mpu_lp_motion_interrupt_0:
   \   00014E   7800         MOV     R0,#0x0
   \   000150   7900         MOV     R1,#0x0
   2934                      if (cache_ptr[ii] != 0)
   \                     ??mpu_lp_motion_interrupt_16:
   \   000152   74..         MOV     A,#(st + 17) & 0xff
   \   000154   28           ADD     A,R0
   \   000155   F582         MOV     DPL,A
   \   000157   74..         MOV     A,#((st + 17) >> 8) & 0xff
   \   000159   39           ADDC    A,R1
   \   00015A   F583         MOV     DPH,A
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   7016         JNZ     ??mpu_lp_motion_interrupt_11
   2935                          goto lp_int_restore;
   2936                  }
   \   00015F   E8           MOV     A,R0
   \   000160   2401         ADD     A,#0x1
   \   000162   08           INC     R0
   \   000163   E9           MOV     A,R1
   \   000164   3400         ADDC    A,#0x0
   \   000166   F9           MOV     R1,A
   \   000167   C3           CLR     C
   \   000168   E8           MOV     A,R0
   \   000169   940A         SUBB    A,#0xa
   \   00016B   E9           MOV     A,R1
   \   00016C   9400         SUBB    A,#0x0
   \   00016E   4003         JC      $+5
   \   000170   02....       LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
   \   000173   80DD         SJMP    ??mpu_lp_motion_interrupt_16
   2937                  /* If we reach this point, motion interrupt mode hasn't been used yet. */
   2938                  return -1;
   2939              }
   2940          lp_int_restore:
   2941              /* Set to invalid values to ensure no I2C writes are skipped. */
   2942              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_lp_motion_interrupt_11:
   \   000175   12....       LCALL   ?Subroutine58 & 0xFFFF
   2943              st.chip_cfg.accel_fsr = 0xFF;
   2944              st.chip_cfg.lpf = 0xFF;
   2945              st.chip_cfg.sample_rate = 0xFFFF;
   2946              st.chip_cfg.sensors = 0xFF;
   2947              st.chip_cfg.fifo_enable = 0xFF;
   2948              st.chip_cfg.clk_src = INV_CLK_PLL;
   2949              mpu_set_sensors(st.chip_cfg.cache.sensors_on);
   \                     ??CrossCallReturnLabel_93:
   \   000178                ; Setup parameters for call to function mpu_set_sensors
   \   000178   90....       MOV     DPTR,#st + 24
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   F9           MOV     R1,A
   \   00017D   12....       LCALL   ??mpu_set_sensors?relay
   2950              mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
   \   000180                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   000180   90....       MOV     DPTR,#st + 17
   \   000183   12....       LCALL   ?Subroutine49 & 0xFFFF
   2951              mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
   \                     ??CrossCallReturnLabel_76:
   \   000186                ; Setup parameters for call to function mpu_set_accel_fsr
   \   000186   90....       MOV     DPTR,#st + 19
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   F9           MOV     R1,A
   \   00018B   12....       LCALL   ??mpu_set_accel_fsr?relay
   2952              mpu_set_lpf(st.chip_cfg.cache.lpf);
   \   00018E                ; Setup parameters for call to function mpu_set_lpf
   \   00018E   90....       MOV     DPTR,#st + 20
   \   000191   12....       LCALL   ?Subroutine50 & 0xFFFF
   2953              mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
   \                     ??CrossCallReturnLabel_78:
   \   000194                ; Setup parameters for call to function mpu_set_sample_rate
   \   000194   90....       MOV     DPTR,#st + 22
   \   000197   12....       LCALL   ?Subroutine38 & 0xFFFF
   2954              mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
   \                     ??CrossCallReturnLabel_46:
   \   00019A                ; Setup parameters for call to function mpu_configure_fifo
   \   00019A   90....       MOV     DPTR,#st + 25
   \   00019D   E0           MOVX    A,@DPTR
   \   00019E   F9           MOV     R1,A
   \   00019F   12....       LCALL   ??mpu_configure_fifo?relay
   2955          
   2956              if (st.chip_cfg.cache.dmp_on)
   \   0001A2   90....       MOV     DPTR,#st + 26
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   6005         JZ      ??mpu_lp_motion_interrupt_17
   2957                  mpu_set_dmp_state(1);
   \   0001A8                ; Setup parameters for call to function mpu_set_dmp_state
   \   0001A8   7901         MOV     R1,#0x1
   \   0001AA   12....       LCALL   ??mpu_set_dmp_state?relay
   2958          
   2959          #ifdef MPU6500
   2960              /* Disable motion interrupt (MPU6500 version). */
   2961              data[0] = 0;
   2962              if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2963                  goto lp_int_restore;
   2964          #endif
   2965          
   2966              st.chip_cfg.int_motion_only = 0;
   \                     ??mpu_lp_motion_interrupt_17:
   \   0001AD   90....       MOV     DPTR,#st + 16
   \   0001B0   E4           CLR     A
   \   0001B1   F0           MOVX    @DPTR,A
   2967              return 0;
   \   0001B2   FA           MOV     R2,A
   \   0001B3   FB           MOV     R3,A
   \                     ??mpu_lp_motion_interrupt_7:
   \   0001B4   7403         MOV     A,#0x3
   \   0001B6   02....       LJMP    ??Subroutine129_0 & 0xFFFF
   2968          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   000003   8B..         MOV     ?V0 + 3,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 3
   \   000008   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for st>`:
   \   000000   ....         DW reg
   \   000002   ....         DW hw
   \   000004   00           DB 0
   \   000005   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00000D   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000015   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001D   00000000     DB 0, 0, 0, 0
   \   000021   ....         DW test

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_420c0000:
   \   000000   00000C42     DD 420C0000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_47800000:
   \   000000   00008047     DD 47800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_43030000:
   \   000000   00000343     DD 43030000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42830000:
   \   000000   00008342     DD 42830000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42033333:
   \   000000   33330342     DD 42033333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41833333:
   \   000000   33338341     DD 41833333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3eae147b:
   \   000000   7B14AE3E     DD 3EAE147BH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f845a1d:
   \   000000   1D5A843F     DD 3F845A1DH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_37800000:
   \   000000   00008037     DD 37800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_bf800000:
   \   000000   000080BF     DD 0BF800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e0f5c2a:
   \   000000   2A5C0F3E     DD 3E0F5C2AH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e99999a:
   \   000000   9A99993E     DD 3E99999AH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f733334:
   \   000000   3433733F     DD 3F733334H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41c80000:
   \   000000   0000C841     DD 41C80000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f85e354:
   \   000000   54E3853F     DD 3F85E354H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41200000:
   \   000000   00002041     DD 41200000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42d20001:
   \   000000   0100D242     DD 42D20001H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_45000000:
   \   000000   00000045     DD 45000000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffff0000:
   \   000000   0000FFFF     DD -65536

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_orientation_matrix_to_scalar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_orientation_matrix_to_scalar

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_row_2_scale?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_row_2_scale

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_ms?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_ms

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??set_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    set_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reg_dump?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reg_dump

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_accel_mode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_accel_mode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_temperature?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_temperature

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_bias?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_bias

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reset_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reset_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_fifo_config?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_fifo_config

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_configure_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_configure_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_power_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_power_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sensors?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sensors

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_int_status?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_int_status

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo_stream?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo_stream

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_bypass?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_bypass

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_level?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_level

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_latched?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_latched

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_accel_prod_shift?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_accel_prod_shift

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??accel_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    accel_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gyro_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gyro_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_st_biases?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_st_biases

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_write_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_write_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_load_firmware?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_load_firmware

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_motion_interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_motion_interrupt
   2969          
   2970          /**
   2971           *  @}
   2972           */
   2973          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     accel_self_test                    0      0     86
       -> get_accel_prod_shift          0      0     76
       -> labs                          0      0     76
     get_accel_prod_shift               1      0     67
       -> I2C_Read                      0      0     58
     get_ms                             0      0      0
     get_st_biases                      1      0    103
       -> I2C_Write                     0      0    110
       -> delay_ms                      0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> delay_ms                      0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> delay_ms                      0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Write                     0      0    110
       -> delay_ms                      0      0    110
       -> I2C_Write                     0      0    110
       -> I2C_Read                      0      0    110
       -> I2C_Read                      0      0    110
     gyro_self_test                     0      0     77
       -> I2C_Read                      0      0     58
       -> labs                          0      0     58
     inv_orientation_matrix_to_scalar
                                        0      0     14
       -> inv_row_2_scale               0      0     28
       -> inv_row_2_scale               0      0     28
       -> inv_row_2_scale               0      0     28
     inv_row_2_scale                    2      0     14
     mpu_configure_fifo                 0      0     60
       -> set_int_enable                0      0     24
       -> set_int_enable                0      0     24
       -> mpu_reset_fifo                0      0     24
     mpu_get_accel_fsr                  3      0     48
     mpu_get_accel_reg                  0      0     16
       -> I2C_Read                      0      0     32
     mpu_get_accel_sens                 2      0     46
     mpu_get_compass_fsr                0      0      0
     mpu_get_compass_reg                0      0      0
     mpu_get_compass_sample_rate        2      0      0
     mpu_get_dmp_state                  3      0      0
     mpu_get_fifo_config                3      0     48
     mpu_get_gyro_fsr                   2      0     48
     mpu_get_gyro_reg                   0      0     16
       -> I2C_Read                      0      0     32
     mpu_get_gyro_sens                  0      0     55
     mpu_get_int_status                 0      0     12
       -> I2C_Read                      0      0     24
     mpu_get_lpf                        2      0     48
     mpu_get_power_state                2      0      0
     mpu_get_sample_rate                2      0     48
     mpu_get_temperature                0      0     18
       -> I2C_Read                      0      0     36
     mpu_init                           0      0     18
       -> I2C_Write                     0      0     32
       -> delay_ms                      0      0     32
       -> I2C_Write                     0      0     32
       -> I2C_Read                      0      0     32
       -> memset                        0      0     36
       -> mpu_set_gyro_fsr              0      0     32
       -> mpu_set_accel_fsr             0      0     32
       -> mpu_set_lpf                   0      0     32
       -> mpu_set_sample_rate           0      0     32
       -> mpu_configure_fifo            0      0     32
       -> mpu_set_bypass                0      0     32
       -> mpu_set_sensors               0      0     32
       -> I2C_Read                      0      0     32
     mpu_load_firmware                  1      0     46
       -> mpu_write_mem                 0      0     84
       -> mpu_read_mem                  0      0     84
       -> memcmp                        0      0     84
       -> I2C_Write                     0      0     80
     mpu_lp_accel_mode                  1      0     27
       -> mpu_set_int_latched           0      0     24
       -> I2C_Write                     0      0     24
       -> mpu_set_int_latched           0      0     24
       -> mpu_set_lpf                   0      0     24
       -> mpu_set_lpf                   0      0     24
       -> mpu_set_lpf                   0      0     24
       -> mpu_set_lpf                   0      0     24
       -> I2C_Write                     0      0     24
       -> mpu_configure_fifo            0      0     24
     mpu_lp_motion_interrupt            1      0     15
       -> mpu_set_dmp_state             0      0     30
       -> mpu_get_gyro_fsr              0      0     30
       -> mpu_get_accel_fsr             0      0     30
       -> mpu_get_lpf                   0      0     30
       -> mpu_get_sample_rate           0      0     30
       -> mpu_get_fifo_config           0      0     30
       -> set_int_enable                0      0     30
       -> mpu_lp_accel_mode             0      0     30
       -> I2C_Write                     0      0     30
       -> I2C_Write                     0      0     30
       -> I2C_Write                     0      0     30
       -> delay_ms                      0      0     30
       -> I2C_Write                     0      0     30
       -> I2C_Write                     0      0     30
       -> mpu_set_sensors               0      0     30
       -> mpu_set_gyro_fsr              0      0     30
       -> mpu_set_accel_fsr             0      0     30
       -> mpu_set_lpf                   0      0     30
       -> mpu_set_sample_rate           0      0     30
       -> mpu_configure_fifo            0      0     30
       -> mpu_set_dmp_state             0      0     30
     mpu_read_fifo                      1      0     42
       -> I2C_Read                      0      0     72
       -> I2C_Read                      0      0     72
       -> mpu_reset_fifo                0      0     72
       -> I2C_Read                      0      0     72
     mpu_read_fifo_stream               1      0     20
       -> I2C_Read                      0      0     36
       -> I2C_Read                      0      0     36
       -> mpu_reset_fifo                0      0     36
       -> I2C_Read                      0      0     36
     mpu_read_mem                       2      0     56
       -> I2C_Write                     0      0     28
       -> I2C_Read                      0      0     28
     mpu_read_reg                       0      0      9
       -> I2C_Read                      0      0     18
     mpu_reg_dump                       0      0     11
       -> I2C_Read                      0      0     22
     mpu_reset_fifo                     0      0     47
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> delay_ms                      0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> delay_ms                      0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
     mpu_run_self_test                  0      0     94
       -> mpu_set_dmp_state             0      0     96
       -> mpu_get_gyro_fsr              0      0     96
       -> mpu_get_accel_fsr             0      0     96
       -> mpu_get_lpf                   0      0     96
       -> mpu_get_sample_rate           0      0     96
       -> mpu_get_fifo_config           0      0     96
       -> get_st_biases                 0      0     96
       -> get_st_biases                 0      0     96
       -> accel_self_test               0      0     96
       -> gyro_self_test                0      0     96
       -> mpu_set_gyro_fsr              0      0     96
       -> mpu_set_accel_fsr             0      0     96
       -> mpu_set_lpf                   0      0     96
       -> mpu_set_sample_rate           0      0     96
       -> mpu_set_sensors               0      0     96
       -> mpu_configure_fifo            0      0     96
       -> mpu_set_dmp_state             0      0     96
     mpu_set_accel_bias                 1      0     44
       -> I2C_Read                      0      0     88
       -> I2C_Read                      0      0     88
       -> I2C_Write                     0      0     88
     mpu_set_accel_fsr                  0      0     59
       -> I2C_Write                     0      0     22
     mpu_set_bypass                     0      0     27
       -> I2C_Read                      0      0     22
       -> I2C_Write                     0      0     22
       -> delay_ms                      0      0     22
       -> I2C_Write                     0      0     22
       -> I2C_Read                      0      0     22
       -> I2C_Write                     0      0     22
       -> delay_ms                      0      0     22
       -> I2C_Write                     0      0     22
     mpu_set_compass_sample_rate        0      0      0
     mpu_set_dmp_state                  1      0     58
       -> set_int_enable                0      0     20
       -> mpu_set_bypass                0      0     20
       -> mpu_set_sample_rate           0      0     20
       -> I2C_Write                     0      0     20
       -> set_int_enable                0      0     20
       -> mpu_reset_fifo                0      0     20
       -> set_int_enable                0      0     20
       -> I2C_Write                     0      0     20
       -> mpu_reset_fifo                0      0     20
     mpu_set_gyro_fsr                   0      0     59
       -> I2C_Write                     0      0     22
     mpu_set_int_latched                0      0     23
       -> I2C_Write                     0      0     22
     mpu_set_int_level                  2      0      0
     mpu_set_lpf                        0      0     59
       -> I2C_Write                     0      0     22
     mpu_set_sample_rate                1      0     59
       -> mpu_lp_accel_mode             0      0     22
       -> mpu_lp_accel_mode             0      0     22
       -> I2C_Write                     0      0     22
       -> mpu_set_lpf                   0      0     22
     mpu_set_sensors                    0      0     59
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22
       -> mpu_set_int_latched           0      0     22
       -> delay_ms                      0      0     22
     mpu_write_mem                      2      0     56
       -> I2C_Write                     0      0     28
       -> I2C_Write                     0      0     28
     run_self_test                      0      0     46
       -> mpu_run_self_test             0      0     92
       -> mpu_get_gyro_sens             0      0     92
       -> dmp_set_gyro_bias             0      0     92
       -> mpu_get_accel_sens            0      0     92
       -> dmp_set_accel_bias            0      0     92
     set_int_enable                     0      0     26
       -> I2C_Write                     0      0     22
       -> I2C_Write                     0      0     22


   Segment part sizes:

     Function/Label                           Bytes
     --------------                           -----
     run_self_test                             334
     ??Subroutine104_0                           8
     ?Subroutine45                               8
     inv_orientation_matrix_to_scalar
                                                69
     ?Subroutine55                              13
     inv_row_2_scale                            72
     ?Subroutine56                               6
     ?Subroutine24                               1
     ??Subroutine105_0                          11
     ??Subroutine112_0                           2
     ??Subroutine113_0                           7
     ??Subroutine128_0                           8
     get_ms                                      3
     hw                                         10
     reg                                        27
     test                                       39
     st                                         35
     set_int_enable                            106
     ?Subroutine3                                2
     ??Subroutine114_0                           8
     ?Subroutine102                              8
     ?Subroutine103                              9
     ??Subroutine132_0                           7
     ?Subroutine94                               7
     ?Subroutine76                               4
     ?Subroutine100                             11
     ?Subroutine78                               2
     ??Subroutine133_0                           7
     ?Subroutine98                               9
     ??Subroutine137_0                           3
     ??Subroutine138_0                           9
     mpu_reg_dump                               80
     ?Subroutine47                              13
     ?Subroutine25                               9
     ?Subroutine67                               9
     ?Subroutine82                               6
     ?Subroutine97                              14
     mpu_read_reg                               57
     ?Subroutine4                                5
     ?Subroutine31                               4
     ?Subroutine75                               8
     ?Subroutine52                               4
     mpu_init                                  367
     ?Subroutine8                                5
     ?Subroutine66                              12
     ?Subroutine63                               4
     ?Subroutine77                               7
     ??Subroutine119_0                          12
     ?Subroutine84                               3
     ??Subroutine125_0                           4
     ?Subroutine99                               4
     ?Subroutine11                               3
     ??Subroutine126_0                           2
     ??Subroutine127_0                           9
     ?Subroutine92                              14
     ??Subroutine136_0                           6
     mpu_lp_accel_mode                         163
     ?Subroutine9                                5
     ?Subroutine69                              10
     ?Subroutine101                              8
     ?Subroutine10                               8
     ??Subroutine134_0                           3
     ??Subroutine135_0                           6
     mpu_get_gyro_reg                           88
     ?Subroutine46                              10
     ?Subroutine39                              12
     ?Subroutine28                              16
     ?Subroutine89                               6
     ?Subroutine48                              11
     mpu_get_accel_reg                          86
     ?Subroutine0                                2
     mpu_get_temperature                       190
     ?Subroutine83                               8
     ?Subroutine15                              11
     mpu_set_accel_bias                        573
     ?Subroutine70                               9
     ?Subroutine65                               1
     ??Subroutine106_0                           5
     ?Subroutine61                               8
     ?Subroutine41                              12
     ?Subroutine40                               9
     ?Subroutine36                               4
     ??Subroutine117_0                          10
     ??Subroutine118_0                           4
     ?Subroutine93                               8
     ?Subroutine87                               6
     mpu_reset_fifo                            263
     ?Subroutine34                               2
     ??Subroutine107_0                           1
     ??Subroutine108_0                           6
     ??Subroutine109_0                           8
     ?Subroutine20                               3
     ??Subroutine116_0                           8
     ?Subroutine33                               1
     ??Subroutine120_0                           1
     ??Subroutine121_0                           4
     ??Subroutine122_0                           4
     ?Subroutine81                              14
     ?Subroutine57                               1
     mpu_get_gyro_fsr                           78
     ??Subroutine111_0                           3
     mpu_set_gyro_fsr                          121
     ?Subroutine90                               6
     ??Subroutine110_0                           7
     ?Subroutine19                              14
     ?Subroutine86                              10
     ?Subroutine32                               9
     mpu_get_accel_fsr                          79
     mpu_set_accel_fsr                         111
     ??Subroutine123_0                          13
     ?Subroutine80                               4
     ?Subroutine96                              11
     mpu_get_lpf                                89
     mpu_set_lpf                               156
     mpu_get_sample_rate                        35
     ?Subroutine64                               3
     ??Subroutine131_0                           6
     mpu_set_sample_rate                       164
     ?Subroutine88                              10
     ?Subroutine37                               3
     mpu_get_compass_sample_rate                19
     mpu_set_compass_sample_rate                 0
     ?Subroutine2                                7
     mpu_get_gyro_sens                          67
     mpu_get_accel_sens                        104
     mpu_get_fifo_config                        10
     ?Subroutine1                                5
     mpu_configure_fifo                        112
     ??Subroutine130_0                           5
     mpu_get_power_state                        21
     mpu_set_sensors                           162
     mpu_get_int_status                         64
     mpu_read_fifo                             466
     ?Subroutine59                               2
     ??Subroutine115_0                          12
     ?Subroutine51                              10
     ?Subroutine42                              20
     ?Subroutine85                              13
     ?Subroutine43                               7
     ?Subroutine17                               8
     ?Subroutine12                              11
     ?Subroutine6                                8
     ?Subroutine21                              13
     ?Subroutine79                               7
     ?Subroutine91                              11
     mpu_read_fifo_stream                      215
     ?Subroutine18                               5
     mpu_set_bypass                            252
     mpu_set_int_level                          11
     mpu_set_int_latched                       107
     get_accel_prod_shift                      266
     ?Subroutine7                                8
     ?Subroutine30                               7
     accel_self_test                           313
     ?Subroutine72                              13
     ?Subroutine71                              14
     ?Subroutine62                              16
     ?Subroutine53                               9
     ?Subroutine95                              11
     ?Subroutine74                               1
     gyro_self_test                            363
     get_st_biases                            1323
     ?Subroutine68                               3
     ?Subroutine35                               1
     ?Subroutine26                               6
     ?Subroutine23                               1
     ?Subroutine22                               3
     ??Subroutine124_0                           5
     ?Subroutine13                               6
     mpu_run_self_test                         304
     ?Subroutine73                               9
     ?Subroutine54                               9
     ?Subroutine38                               7
     ?Subroutine58                              23
     ?Subroutine50                               7
     ?Subroutine49                               7
     mpu_write_mem                             105
     ?Subroutine5                                2
     ??Subroutine129_0                           3
     ?Subroutine44                              12
     ?Subroutine27                              11
     ?Subroutine14                              39
     mpu_read_mem                              107
     mpu_load_firmware                         284
     ?Subroutine60                               9
     mpu_set_dmp_state                         100
     ?Subroutine29                              12
     mpu_get_dmp_state                          10
     mpu_get_compass_reg                         3
     mpu_get_compass_fsr                         3
     mpu_lp_motion_interrupt                   441
     ?Subroutine16                               9
     ?<Initializer for st>                      35
     __Constant_420c0000                         4
     __Constant_47800000                         4
     __Constant_43030000                         4
     __Constant_42830000                         4
     __Constant_42033333                         4
     __Constant_41833333                         4
     __Constant_0                                4
     __Constant_3eae147b                         4
     __Constant_3f845a1d                         4
     __Constant_37800000                         4
     __Constant_bf800000                         4
     __Constant_1                                4
     __Constant_3e0f5c2a                         4
     __Constant_3e99999a                         4
     __Constant_3f733334                         4
     __Constant_41c80000                         4
     __Constant_3f85e354                         4
     __Constant_41200000                         4
     __Constant_42d20001                         4
     __Constant_45000000                         4
     __Constant_ffff0000                         4
     ??run_self_test?relay                       6
     ??inv_orientation_matrix_to_scalar?relay    6
     ??inv_row_2_scale?relay                     6
     ??get_ms?relay                              6
     ??set_int_enable?relay                      6
     ??mpu_reg_dump?relay                        6
     ??mpu_read_reg?relay                        6
     ??mpu_init?relay                            6
     ??mpu_lp_accel_mode?relay                   6
     ??mpu_get_gyro_reg?relay                    6
     ??mpu_get_accel_reg?relay                   6
     ??mpu_get_temperature?relay                 6
     ??mpu_set_accel_bias?relay                  6
     ??mpu_reset_fifo?relay                      6
     ??mpu_get_gyro_fsr?relay                    6
     ??mpu_set_gyro_fsr?relay                    6
     ??mpu_get_accel_fsr?relay                   6
     ??mpu_set_accel_fsr?relay                   6
     ??mpu_get_lpf?relay                         6
     ??mpu_set_lpf?relay                         6
     ??mpu_get_sample_rate?relay                 6
     ??mpu_set_sample_rate?relay                 6
     ??mpu_get_compass_sample_rate?relay         6
     ??mpu_set_compass_sample_rate?relay         6
     ??mpu_get_gyro_sens?relay                   6
     ??mpu_get_accel_sens?relay                  6
     ??mpu_get_fifo_config?relay                 6
     ??mpu_configure_fifo?relay                  6
     ??mpu_get_power_state?relay                 6
     ??mpu_set_sensors?relay                     6
     ??mpu_get_int_status?relay                  6
     ??mpu_read_fifo?relay                       6
     ??mpu_read_fifo_stream?relay                6
     ??mpu_set_bypass?relay                      6
     ??mpu_set_int_level?relay                   6
     ??mpu_set_int_latched?relay                 6
     ??get_accel_prod_shift?relay                6
     ??accel_self_test?relay                     6
     ??gyro_self_test?relay                      6
     ??get_st_biases?relay                       6
     ??mpu_run_self_test?relay                   6
     ??mpu_write_mem?relay                       6
     ??mpu_read_mem?relay                        6
     ??mpu_load_firmware?relay                   6
     ??mpu_set_dmp_state?relay                   6
     ??mpu_get_dmp_state?relay                   6
     ??mpu_get_compass_reg?relay                 6
     ??mpu_get_compass_fsr?relay                 6
     ??mpu_lp_motion_interrupt?relay             6

 
 9 574 bytes in segment BANKED_CODE
   294 bytes in segment BANK_RELAYS
    35 bytes in segment XDATA_I
    35 bytes in segment XDATA_ID
   160 bytes in segment XDATA_ROM_C
 
 9 903 bytes of CODE  memory
    76 bytes of CONST memory (+ 84 bytes shared)
    35 bytes of XDATA memory

Errors: none
Warnings: none
